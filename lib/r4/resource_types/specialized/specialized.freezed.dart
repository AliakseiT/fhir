// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'specialized.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
ActivityDefinition _$ActivityDefinitionFromJson(Map<String, dynamic> json) {
  return _ActivityDefinition.fromJson(json);
}

class _$ActivityDefinitionTearOff {
  const _$ActivityDefinitionTearOff();

  _ActivityDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'ActivityDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
          ActivityDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Code kind,
      Canonical profile,
      CodeableConcept code,
      Code intent,
      Code priority,
      Boolean doNotPerform,
      Timing timingTiming,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Range timingRange,
      Duration timingDuration,
      Reference location,
      List<ActivityDefinitionParticipant> participant,
      Reference productReference,
      CodeableConcept productCodeableConcept,
      Quantity quantity,
      List<Dosage> dosage,
      List<CodeableConcept> bodySite,
      List<Reference> specimenRequirement,
      List<Reference> observationRequirement,
      List<Reference> observationResultRequirement,
      Canonical transform,
      List<ActivityDefinitionDynamicValue> dynamicValue}) {
    return _ActivityDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      subtitle: subtitle,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      library: library,
      kind: kind,
      profile: profile,
      code: code,
      intent: intent,
      priority: priority,
      doNotPerform: doNotPerform,
      timingTiming: timingTiming,
      timingDateTime: timingDateTime,
      timingAge: timingAge,
      timingPeriod: timingPeriod,
      timingRange: timingRange,
      timingDuration: timingDuration,
      location: location,
      participant: participant,
      productReference: productReference,
      productCodeableConcept: productCodeableConcept,
      quantity: quantity,
      dosage: dosage,
      bodySite: bodySite,
      specimenRequirement: specimenRequirement,
      observationRequirement: observationRequirement,
      observationResultRequirement: observationResultRequirement,
      transform: transform,
      dynamicValue: dynamicValue,
    );
  }
}

// ignore: unused_element
const $ActivityDefinition = _$ActivityDefinitionTearOff();

mixin _$ActivityDefinition {
  @JsonKey(required: true, defaultValue: 'ActivityDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get subtitle;
  @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
  ActivityDefinitionStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  List<Canonical> get library;
  Code get kind;
  Canonical get profile;
  CodeableConcept get code;
  Code get intent;
  Code get priority;
  Boolean get doNotPerform;
  Timing get timingTiming;
  FhirDateTime get timingDateTime;
  Age get timingAge;
  Period get timingPeriod;
  Range get timingRange;
  Duration get timingDuration;
  Reference get location;
  List<ActivityDefinitionParticipant> get participant;
  Reference get productReference;
  CodeableConcept get productCodeableConcept;
  Quantity get quantity;
  List<Dosage> get dosage;
  List<CodeableConcept> get bodySite;
  List<Reference> get specimenRequirement;
  List<Reference> get observationRequirement;
  List<Reference> get observationResultRequirement;
  Canonical get transform;
  List<ActivityDefinitionDynamicValue> get dynamicValue;

  Map<String, dynamic> toJson();
  $ActivityDefinitionCopyWith<ActivityDefinition> get copyWith;
}

abstract class $ActivityDefinitionCopyWith<$Res> {
  factory $ActivityDefinitionCopyWith(
          ActivityDefinition value, $Res Function(ActivityDefinition) then) =
      _$ActivityDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ActivityDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
          ActivityDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Code kind,
      Canonical profile,
      CodeableConcept code,
      Code intent,
      Code priority,
      Boolean doNotPerform,
      Timing timingTiming,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Range timingRange,
      Duration timingDuration,
      Reference location,
      List<ActivityDefinitionParticipant> participant,
      Reference productReference,
      CodeableConcept productCodeableConcept,
      Quantity quantity,
      List<Dosage> dosage,
      List<CodeableConcept> bodySite,
      List<Reference> specimenRequirement,
      List<Reference> observationRequirement,
      List<Reference> observationResultRequirement,
      Canonical transform,
      List<ActivityDefinitionDynamicValue> dynamicValue});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $CodeableConceptCopyWith<$Res> get code;
  $TimingCopyWith<$Res> get timingTiming;
  $AgeCopyWith<$Res> get timingAge;
  $PeriodCopyWith<$Res> get timingPeriod;
  $RangeCopyWith<$Res> get timingRange;
  $DurationCopyWith<$Res> get timingDuration;
  $ReferenceCopyWith<$Res> get location;
  $ReferenceCopyWith<$Res> get productReference;
  $CodeableConceptCopyWith<$Res> get productCodeableConcept;
  $QuantityCopyWith<$Res> get quantity;
}

class _$ActivityDefinitionCopyWithImpl<$Res>
    implements $ActivityDefinitionCopyWith<$Res> {
  _$ActivityDefinitionCopyWithImpl(this._value, this._then);

  final ActivityDefinition _value;
  // ignore: unused_field
  final $Res Function(ActivityDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object kind = freezed,
    Object profile = freezed,
    Object code = freezed,
    Object intent = freezed,
    Object priority = freezed,
    Object doNotPerform = freezed,
    Object timingTiming = freezed,
    Object timingDateTime = freezed,
    Object timingAge = freezed,
    Object timingPeriod = freezed,
    Object timingRange = freezed,
    Object timingDuration = freezed,
    Object location = freezed,
    Object participant = freezed,
    Object productReference = freezed,
    Object productCodeableConcept = freezed,
    Object quantity = freezed,
    Object dosage = freezed,
    Object bodySite = freezed,
    Object specimenRequirement = freezed,
    Object observationRequirement = freezed,
    Object observationResultRequirement = freezed,
    Object transform = freezed,
    Object dynamicValue = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ActivityDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      kind: kind == freezed ? _value.kind : kind as Code,
      profile: profile == freezed ? _value.profile : profile as Canonical,
      code: code == freezed ? _value.code : code as CodeableConcept,
      intent: intent == freezed ? _value.intent : intent as Code,
      priority: priority == freezed ? _value.priority : priority as Code,
      doNotPerform: doNotPerform == freezed
          ? _value.doNotPerform
          : doNotPerform as Boolean,
      timingTiming: timingTiming == freezed
          ? _value.timingTiming
          : timingTiming as Timing,
      timingDateTime: timingDateTime == freezed
          ? _value.timingDateTime
          : timingDateTime as FhirDateTime,
      timingAge: timingAge == freezed ? _value.timingAge : timingAge as Age,
      timingPeriod: timingPeriod == freezed
          ? _value.timingPeriod
          : timingPeriod as Period,
      timingRange:
          timingRange == freezed ? _value.timingRange : timingRange as Range,
      timingDuration: timingDuration == freezed
          ? _value.timingDuration
          : timingDuration as Duration,
      location: location == freezed ? _value.location : location as Reference,
      participant: participant == freezed
          ? _value.participant
          : participant as List<ActivityDefinitionParticipant>,
      productReference: productReference == freezed
          ? _value.productReference
          : productReference as Reference,
      productCodeableConcept: productCodeableConcept == freezed
          ? _value.productCodeableConcept
          : productCodeableConcept as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      dosage: dosage == freezed ? _value.dosage : dosage as List<Dosage>,
      bodySite: bodySite == freezed
          ? _value.bodySite
          : bodySite as List<CodeableConcept>,
      specimenRequirement: specimenRequirement == freezed
          ? _value.specimenRequirement
          : specimenRequirement as List<Reference>,
      observationRequirement: observationRequirement == freezed
          ? _value.observationRequirement
          : observationRequirement as List<Reference>,
      observationResultRequirement: observationResultRequirement == freezed
          ? _value.observationResultRequirement
          : observationResultRequirement as List<Reference>,
      transform:
          transform == freezed ? _value.transform : transform as Canonical,
      dynamicValue: dynamicValue == freezed
          ? _value.dynamicValue
          : dynamicValue as List<ActivityDefinitionDynamicValue>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $TimingCopyWith<$Res> get timingTiming {
    if (_value.timingTiming == null) {
      return null;
    }
    return $TimingCopyWith<$Res>(_value.timingTiming, (value) {
      return _then(_value.copyWith(timingTiming: value));
    });
  }

  @override
  $AgeCopyWith<$Res> get timingAge {
    if (_value.timingAge == null) {
      return null;
    }
    return $AgeCopyWith<$Res>(_value.timingAge, (value) {
      return _then(_value.copyWith(timingAge: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get timingPeriod {
    if (_value.timingPeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.timingPeriod, (value) {
      return _then(_value.copyWith(timingPeriod: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get timingRange {
    if (_value.timingRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.timingRange, (value) {
      return _then(_value.copyWith(timingRange: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get timingDuration {
    if (_value.timingDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.timingDuration, (value) {
      return _then(_value.copyWith(timingDuration: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get location {
    if (_value.location == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.location, (value) {
      return _then(_value.copyWith(location: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get productReference {
    if (_value.productReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.productReference, (value) {
      return _then(_value.copyWith(productReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get productCodeableConcept {
    if (_value.productCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.productCodeableConcept,
        (value) {
      return _then(_value.copyWith(productCodeableConcept: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get quantity {
    if (_value.quantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.quantity, (value) {
      return _then(_value.copyWith(quantity: value));
    });
  }
}

abstract class _$ActivityDefinitionCopyWith<$Res>
    implements $ActivityDefinitionCopyWith<$Res> {
  factory _$ActivityDefinitionCopyWith(
          _ActivityDefinition value, $Res Function(_ActivityDefinition) then) =
      __$ActivityDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ActivityDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
          ActivityDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Code kind,
      Canonical profile,
      CodeableConcept code,
      Code intent,
      Code priority,
      Boolean doNotPerform,
      Timing timingTiming,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Range timingRange,
      Duration timingDuration,
      Reference location,
      List<ActivityDefinitionParticipant> participant,
      Reference productReference,
      CodeableConcept productCodeableConcept,
      Quantity quantity,
      List<Dosage> dosage,
      List<CodeableConcept> bodySite,
      List<Reference> specimenRequirement,
      List<Reference> observationRequirement,
      List<Reference> observationResultRequirement,
      Canonical transform,
      List<ActivityDefinitionDynamicValue> dynamicValue});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $TimingCopyWith<$Res> get timingTiming;
  @override
  $AgeCopyWith<$Res> get timingAge;
  @override
  $PeriodCopyWith<$Res> get timingPeriod;
  @override
  $RangeCopyWith<$Res> get timingRange;
  @override
  $DurationCopyWith<$Res> get timingDuration;
  @override
  $ReferenceCopyWith<$Res> get location;
  @override
  $ReferenceCopyWith<$Res> get productReference;
  @override
  $CodeableConceptCopyWith<$Res> get productCodeableConcept;
  @override
  $QuantityCopyWith<$Res> get quantity;
}

class __$ActivityDefinitionCopyWithImpl<$Res>
    extends _$ActivityDefinitionCopyWithImpl<$Res>
    implements _$ActivityDefinitionCopyWith<$Res> {
  __$ActivityDefinitionCopyWithImpl(
      _ActivityDefinition _value, $Res Function(_ActivityDefinition) _then)
      : super(_value, (v) => _then(v as _ActivityDefinition));

  @override
  _ActivityDefinition get _value => super._value as _ActivityDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object kind = freezed,
    Object profile = freezed,
    Object code = freezed,
    Object intent = freezed,
    Object priority = freezed,
    Object doNotPerform = freezed,
    Object timingTiming = freezed,
    Object timingDateTime = freezed,
    Object timingAge = freezed,
    Object timingPeriod = freezed,
    Object timingRange = freezed,
    Object timingDuration = freezed,
    Object location = freezed,
    Object participant = freezed,
    Object productReference = freezed,
    Object productCodeableConcept = freezed,
    Object quantity = freezed,
    Object dosage = freezed,
    Object bodySite = freezed,
    Object specimenRequirement = freezed,
    Object observationRequirement = freezed,
    Object observationResultRequirement = freezed,
    Object transform = freezed,
    Object dynamicValue = freezed,
  }) {
    return _then(_ActivityDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ActivityDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      kind: kind == freezed ? _value.kind : kind as Code,
      profile: profile == freezed ? _value.profile : profile as Canonical,
      code: code == freezed ? _value.code : code as CodeableConcept,
      intent: intent == freezed ? _value.intent : intent as Code,
      priority: priority == freezed ? _value.priority : priority as Code,
      doNotPerform: doNotPerform == freezed
          ? _value.doNotPerform
          : doNotPerform as Boolean,
      timingTiming: timingTiming == freezed
          ? _value.timingTiming
          : timingTiming as Timing,
      timingDateTime: timingDateTime == freezed
          ? _value.timingDateTime
          : timingDateTime as FhirDateTime,
      timingAge: timingAge == freezed ? _value.timingAge : timingAge as Age,
      timingPeriod: timingPeriod == freezed
          ? _value.timingPeriod
          : timingPeriod as Period,
      timingRange:
          timingRange == freezed ? _value.timingRange : timingRange as Range,
      timingDuration: timingDuration == freezed
          ? _value.timingDuration
          : timingDuration as Duration,
      location: location == freezed ? _value.location : location as Reference,
      participant: participant == freezed
          ? _value.participant
          : participant as List<ActivityDefinitionParticipant>,
      productReference: productReference == freezed
          ? _value.productReference
          : productReference as Reference,
      productCodeableConcept: productCodeableConcept == freezed
          ? _value.productCodeableConcept
          : productCodeableConcept as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      dosage: dosage == freezed ? _value.dosage : dosage as List<Dosage>,
      bodySite: bodySite == freezed
          ? _value.bodySite
          : bodySite as List<CodeableConcept>,
      specimenRequirement: specimenRequirement == freezed
          ? _value.specimenRequirement
          : specimenRequirement as List<Reference>,
      observationRequirement: observationRequirement == freezed
          ? _value.observationRequirement
          : observationRequirement as List<Reference>,
      observationResultRequirement: observationResultRequirement == freezed
          ? _value.observationResultRequirement
          : observationResultRequirement as List<Reference>,
      transform:
          transform == freezed ? _value.transform : transform as Canonical,
      dynamicValue: dynamicValue == freezed
          ? _value.dynamicValue
          : dynamicValue as List<ActivityDefinitionDynamicValue>,
    ));
  }
}

@JsonSerializable()
class _$_ActivityDefinition implements _ActivityDefinition {
  const _$_ActivityDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ActivityDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.subtitle,
      @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.library,
      this.kind,
      this.profile,
      this.code,
      this.intent,
      this.priority,
      this.doNotPerform,
      this.timingTiming,
      this.timingDateTime,
      this.timingAge,
      this.timingPeriod,
      this.timingRange,
      this.timingDuration,
      this.location,
      this.participant,
      this.productReference,
      this.productCodeableConcept,
      this.quantity,
      this.dosage,
      this.bodySite,
      this.specimenRequirement,
      this.observationRequirement,
      this.observationResultRequirement,
      this.transform,
      this.dynamicValue})
      : assert(resourceType != null);

  factory _$_ActivityDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_ActivityDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ActivityDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
  final ActivityDefinitionStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<Canonical> library;
  @override
  final Code kind;
  @override
  final Canonical profile;
  @override
  final CodeableConcept code;
  @override
  final Code intent;
  @override
  final Code priority;
  @override
  final Boolean doNotPerform;
  @override
  final Timing timingTiming;
  @override
  final FhirDateTime timingDateTime;
  @override
  final Age timingAge;
  @override
  final Period timingPeriod;
  @override
  final Range timingRange;
  @override
  final Duration timingDuration;
  @override
  final Reference location;
  @override
  final List<ActivityDefinitionParticipant> participant;
  @override
  final Reference productReference;
  @override
  final CodeableConcept productCodeableConcept;
  @override
  final Quantity quantity;
  @override
  final List<Dosage> dosage;
  @override
  final List<CodeableConcept> bodySite;
  @override
  final List<Reference> specimenRequirement;
  @override
  final List<Reference> observationRequirement;
  @override
  final List<Reference> observationResultRequirement;
  @override
  final Canonical transform;
  @override
  final List<ActivityDefinitionDynamicValue> dynamicValue;

  @override
  String toString() {
    return 'ActivityDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, subtitle: $subtitle, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, library: $library, kind: $kind, profile: $profile, code: $code, intent: $intent, priority: $priority, doNotPerform: $doNotPerform, timingTiming: $timingTiming, timingDateTime: $timingDateTime, timingAge: $timingAge, timingPeriod: $timingPeriod, timingRange: $timingRange, timingDuration: $timingDuration, location: $location, participant: $participant, productReference: $productReference, productCodeableConcept: $productCodeableConcept, quantity: $quantity, dosage: $dosage, bodySite: $bodySite, specimenRequirement: $specimenRequirement, observationRequirement: $observationRequirement, observationResultRequirement: $observationResultRequirement, transform: $transform, dynamicValue: $dynamicValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ActivityDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.library, library) || const DeepCollectionEquality().equals(other.library, library)) &&
            (identical(other.kind, kind) || const DeepCollectionEquality().equals(other.kind, kind)) &&
            (identical(other.profile, profile) || const DeepCollectionEquality().equals(other.profile, profile)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.intent, intent) || const DeepCollectionEquality().equals(other.intent, intent)) &&
            (identical(other.priority, priority) || const DeepCollectionEquality().equals(other.priority, priority)) &&
            (identical(other.doNotPerform, doNotPerform) || const DeepCollectionEquality().equals(other.doNotPerform, doNotPerform)) &&
            (identical(other.timingTiming, timingTiming) || const DeepCollectionEquality().equals(other.timingTiming, timingTiming)) &&
            (identical(other.timingDateTime, timingDateTime) || const DeepCollectionEquality().equals(other.timingDateTime, timingDateTime)) &&
            (identical(other.timingAge, timingAge) || const DeepCollectionEquality().equals(other.timingAge, timingAge)) &&
            (identical(other.timingPeriod, timingPeriod) || const DeepCollectionEquality().equals(other.timingPeriod, timingPeriod)) &&
            (identical(other.timingRange, timingRange) || const DeepCollectionEquality().equals(other.timingRange, timingRange)) &&
            (identical(other.timingDuration, timingDuration) || const DeepCollectionEquality().equals(other.timingDuration, timingDuration)) &&
            (identical(other.location, location) || const DeepCollectionEquality().equals(other.location, location)) &&
            (identical(other.participant, participant) || const DeepCollectionEquality().equals(other.participant, participant)) &&
            (identical(other.productReference, productReference) || const DeepCollectionEquality().equals(other.productReference, productReference)) &&
            (identical(other.productCodeableConcept, productCodeableConcept) || const DeepCollectionEquality().equals(other.productCodeableConcept, productCodeableConcept)) &&
            (identical(other.quantity, quantity) || const DeepCollectionEquality().equals(other.quantity, quantity)) &&
            (identical(other.dosage, dosage) || const DeepCollectionEquality().equals(other.dosage, dosage)) &&
            (identical(other.bodySite, bodySite) || const DeepCollectionEquality().equals(other.bodySite, bodySite)) &&
            (identical(other.specimenRequirement, specimenRequirement) || const DeepCollectionEquality().equals(other.specimenRequirement, specimenRequirement)) &&
            (identical(other.observationRequirement, observationRequirement) || const DeepCollectionEquality().equals(other.observationRequirement, observationRequirement)) &&
            (identical(other.observationResultRequirement, observationResultRequirement) || const DeepCollectionEquality().equals(other.observationResultRequirement, observationResultRequirement)) &&
            (identical(other.transform, transform) || const DeepCollectionEquality().equals(other.transform, transform)) &&
            (identical(other.dynamicValue, dynamicValue) || const DeepCollectionEquality().equals(other.dynamicValue, dynamicValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(library) ^
      const DeepCollectionEquality().hash(kind) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(intent) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(doNotPerform) ^
      const DeepCollectionEquality().hash(timingTiming) ^
      const DeepCollectionEquality().hash(timingDateTime) ^
      const DeepCollectionEquality().hash(timingAge) ^
      const DeepCollectionEquality().hash(timingPeriod) ^
      const DeepCollectionEquality().hash(timingRange) ^
      const DeepCollectionEquality().hash(timingDuration) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(participant) ^
      const DeepCollectionEquality().hash(productReference) ^
      const DeepCollectionEquality().hash(productCodeableConcept) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(dosage) ^
      const DeepCollectionEquality().hash(bodySite) ^
      const DeepCollectionEquality().hash(specimenRequirement) ^
      const DeepCollectionEquality().hash(observationRequirement) ^
      const DeepCollectionEquality().hash(observationResultRequirement) ^
      const DeepCollectionEquality().hash(transform) ^
      const DeepCollectionEquality().hash(dynamicValue);

  @override
  _$ActivityDefinitionCopyWith<_ActivityDefinition> get copyWith =>
      __$ActivityDefinitionCopyWithImpl<_ActivityDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ActivityDefinitionToJson(this);
  }
}

abstract class _ActivityDefinition implements ActivityDefinition {
  const factory _ActivityDefinition(
          {@required
          @JsonKey(required: true, defaultValue: 'ActivityDefinition')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          FhirUri url,
          List<Identifier> identifier,
          String version,
          String name,
          String title,
          String subtitle,
          @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
              ActivityDefinitionStatus status,
          Boolean experimental,
          CodeableConcept subjectCodeableConcept,
          Reference subjectReference,
          FhirDateTime date,
          String publisher,
          List<ContactDetail> contact,
          Markdown description,
          List<UsageContext> useContext,
          List<CodeableConcept> jurisdiction,
          Markdown purpose,
          String usage,
          Markdown copyright,
          Date approvalDate,
          Date lastReviewDate,
          Period effectivePeriod,
          List<CodeableConcept> topic,
          List<ContactDetail> author,
          List<ContactDetail> editor,
          List<ContactDetail> reviewer,
          List<ContactDetail> endorser,
          List<RelatedArtifact> relatedArtifact,
          List<Canonical> library,
          Code kind,
          Canonical profile,
          CodeableConcept code,
          Code intent,
          Code priority,
          Boolean doNotPerform,
          Timing timingTiming,
          FhirDateTime timingDateTime,
          Age timingAge,
          Period timingPeriod,
          Range timingRange,
          Duration timingDuration,
          Reference location,
          List<ActivityDefinitionParticipant> participant,
          Reference productReference,
          CodeableConcept productCodeableConcept,
          Quantity quantity,
          List<Dosage> dosage,
          List<CodeableConcept> bodySite,
          List<Reference> specimenRequirement,
          List<Reference> observationRequirement,
          List<Reference> observationResultRequirement,
          Canonical transform,
          List<ActivityDefinitionDynamicValue> dynamicValue}) =
      _$_ActivityDefinition;

  factory _ActivityDefinition.fromJson(Map<String, dynamic> json) =
      _$_ActivityDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ActivityDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: ActivityDefinitionStatus.unknown)
  ActivityDefinitionStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<Canonical> get library;
  @override
  Code get kind;
  @override
  Canonical get profile;
  @override
  CodeableConcept get code;
  @override
  Code get intent;
  @override
  Code get priority;
  @override
  Boolean get doNotPerform;
  @override
  Timing get timingTiming;
  @override
  FhirDateTime get timingDateTime;
  @override
  Age get timingAge;
  @override
  Period get timingPeriod;
  @override
  Range get timingRange;
  @override
  Duration get timingDuration;
  @override
  Reference get location;
  @override
  List<ActivityDefinitionParticipant> get participant;
  @override
  Reference get productReference;
  @override
  CodeableConcept get productCodeableConcept;
  @override
  Quantity get quantity;
  @override
  List<Dosage> get dosage;
  @override
  List<CodeableConcept> get bodySite;
  @override
  List<Reference> get specimenRequirement;
  @override
  List<Reference> get observationRequirement;
  @override
  List<Reference> get observationResultRequirement;
  @override
  Canonical get transform;
  @override
  List<ActivityDefinitionDynamicValue> get dynamicValue;
  @override
  _$ActivityDefinitionCopyWith<_ActivityDefinition> get copyWith;
}

ActivityDefinitionParticipant _$ActivityDefinitionParticipantFromJson(
    Map<String, dynamic> json) {
  return _ActivityDefinitionParticipant.fromJson(json);
}

class _$ActivityDefinitionParticipantTearOff {
  const _$ActivityDefinitionParticipantTearOff();

  _ActivityDefinitionParticipant call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Code type,
      CodeableConcept role}) {
    return _ActivityDefinitionParticipant(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      role: role,
    );
  }
}

// ignore: unused_element
const $ActivityDefinitionParticipant = _$ActivityDefinitionParticipantTearOff();

mixin _$ActivityDefinitionParticipant {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Code get type;
  CodeableConcept get role;

  Map<String, dynamic> toJson();
  $ActivityDefinitionParticipantCopyWith<ActivityDefinitionParticipant>
      get copyWith;
}

abstract class $ActivityDefinitionParticipantCopyWith<$Res> {
  factory $ActivityDefinitionParticipantCopyWith(
          ActivityDefinitionParticipant value,
          $Res Function(ActivityDefinitionParticipant) then) =
      _$ActivityDefinitionParticipantCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Code type,
      CodeableConcept role});

  $CodeableConceptCopyWith<$Res> get role;
}

class _$ActivityDefinitionParticipantCopyWithImpl<$Res>
    implements $ActivityDefinitionParticipantCopyWith<$Res> {
  _$ActivityDefinitionParticipantCopyWithImpl(this._value, this._then);

  final ActivityDefinitionParticipant _value;
  // ignore: unused_field
  final $Res Function(ActivityDefinitionParticipant) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object role = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as Code,
      role: role == freezed ? _value.role : role as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get role {
    if (_value.role == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value));
    });
  }
}

abstract class _$ActivityDefinitionParticipantCopyWith<$Res>
    implements $ActivityDefinitionParticipantCopyWith<$Res> {
  factory _$ActivityDefinitionParticipantCopyWith(
          _ActivityDefinitionParticipant value,
          $Res Function(_ActivityDefinitionParticipant) then) =
      __$ActivityDefinitionParticipantCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Code type,
      CodeableConcept role});

  @override
  $CodeableConceptCopyWith<$Res> get role;
}

class __$ActivityDefinitionParticipantCopyWithImpl<$Res>
    extends _$ActivityDefinitionParticipantCopyWithImpl<$Res>
    implements _$ActivityDefinitionParticipantCopyWith<$Res> {
  __$ActivityDefinitionParticipantCopyWithImpl(
      _ActivityDefinitionParticipant _value,
      $Res Function(_ActivityDefinitionParticipant) _then)
      : super(_value, (v) => _then(v as _ActivityDefinitionParticipant));

  @override
  _ActivityDefinitionParticipant get _value =>
      super._value as _ActivityDefinitionParticipant;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object role = freezed,
  }) {
    return _then(_ActivityDefinitionParticipant(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as Code,
      role: role == freezed ? _value.role : role as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_ActivityDefinitionParticipant
    implements _ActivityDefinitionParticipant {
  const _$_ActivityDefinitionParticipant(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.role});

  factory _$_ActivityDefinitionParticipant.fromJson(
          Map<String, dynamic> json) =>
      _$_$_ActivityDefinitionParticipantFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Code type;
  @override
  final CodeableConcept role;

  @override
  String toString() {
    return 'ActivityDefinitionParticipant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, role: $role)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ActivityDefinitionParticipant &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(role);

  @override
  _$ActivityDefinitionParticipantCopyWith<_ActivityDefinitionParticipant>
      get copyWith => __$ActivityDefinitionParticipantCopyWithImpl<
          _ActivityDefinitionParticipant>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ActivityDefinitionParticipantToJson(this);
  }
}

abstract class _ActivityDefinitionParticipant
    implements ActivityDefinitionParticipant {
  const factory _ActivityDefinitionParticipant(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Code type,
      CodeableConcept role}) = _$_ActivityDefinitionParticipant;

  factory _ActivityDefinitionParticipant.fromJson(Map<String, dynamic> json) =
      _$_ActivityDefinitionParticipant.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Code get type;
  @override
  CodeableConcept get role;
  @override
  _$ActivityDefinitionParticipantCopyWith<_ActivityDefinitionParticipant>
      get copyWith;
}

ActivityDefinitionDynamicValue _$ActivityDefinitionDynamicValueFromJson(
    Map<String, dynamic> json) {
  return _ActivityDefinitionDynamicValue.fromJson(json);
}

class _$ActivityDefinitionDynamicValueTearOff {
  const _$ActivityDefinitionDynamicValueTearOff();

  _ActivityDefinitionDynamicValue call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      @required @JsonKey(required: true) Expression expression}) {
    return _ActivityDefinitionDynamicValue(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      path: path,
      expression: expression,
    );
  }
}

// ignore: unused_element
const $ActivityDefinitionDynamicValue =
    _$ActivityDefinitionDynamicValueTearOff();

mixin _$ActivityDefinitionDynamicValue {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get path;
  @JsonKey(required: true)
  Expression get expression;

  Map<String, dynamic> toJson();
  $ActivityDefinitionDynamicValueCopyWith<ActivityDefinitionDynamicValue>
      get copyWith;
}

abstract class $ActivityDefinitionDynamicValueCopyWith<$Res> {
  factory $ActivityDefinitionDynamicValueCopyWith(
          ActivityDefinitionDynamicValue value,
          $Res Function(ActivityDefinitionDynamicValue) then) =
      _$ActivityDefinitionDynamicValueCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      @JsonKey(required: true) Expression expression});

  $ExpressionCopyWith<$Res> get expression;
}

class _$ActivityDefinitionDynamicValueCopyWithImpl<$Res>
    implements $ActivityDefinitionDynamicValueCopyWith<$Res> {
  _$ActivityDefinitionDynamicValueCopyWithImpl(this._value, this._then);

  final ActivityDefinitionDynamicValue _value;
  // ignore: unused_field
  final $Res Function(ActivityDefinitionDynamicValue) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object path = freezed,
    Object expression = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      path: path == freezed ? _value.path : path as String,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }

  @override
  $ExpressionCopyWith<$Res> get expression {
    if (_value.expression == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.expression, (value) {
      return _then(_value.copyWith(expression: value));
    });
  }
}

abstract class _$ActivityDefinitionDynamicValueCopyWith<$Res>
    implements $ActivityDefinitionDynamicValueCopyWith<$Res> {
  factory _$ActivityDefinitionDynamicValueCopyWith(
          _ActivityDefinitionDynamicValue value,
          $Res Function(_ActivityDefinitionDynamicValue) then) =
      __$ActivityDefinitionDynamicValueCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      @JsonKey(required: true) Expression expression});

  @override
  $ExpressionCopyWith<$Res> get expression;
}

class __$ActivityDefinitionDynamicValueCopyWithImpl<$Res>
    extends _$ActivityDefinitionDynamicValueCopyWithImpl<$Res>
    implements _$ActivityDefinitionDynamicValueCopyWith<$Res> {
  __$ActivityDefinitionDynamicValueCopyWithImpl(
      _ActivityDefinitionDynamicValue _value,
      $Res Function(_ActivityDefinitionDynamicValue) _then)
      : super(_value, (v) => _then(v as _ActivityDefinitionDynamicValue));

  @override
  _ActivityDefinitionDynamicValue get _value =>
      super._value as _ActivityDefinitionDynamicValue;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object path = freezed,
    Object expression = freezed,
  }) {
    return _then(_ActivityDefinitionDynamicValue(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      path: path == freezed ? _value.path : path as String,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }
}

@JsonSerializable()
class _$_ActivityDefinitionDynamicValue
    implements _ActivityDefinitionDynamicValue {
  const _$_ActivityDefinitionDynamicValue(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.path,
      @required @JsonKey(required: true) this.expression})
      : assert(expression != null);

  factory _$_ActivityDefinitionDynamicValue.fromJson(
          Map<String, dynamic> json) =>
      _$_$_ActivityDefinitionDynamicValueFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String path;
  @override
  @JsonKey(required: true)
  final Expression expression;

  @override
  String toString() {
    return 'ActivityDefinitionDynamicValue(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, path: $path, expression: $expression)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ActivityDefinitionDynamicValue &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.expression, expression) ||
                const DeepCollectionEquality()
                    .equals(other.expression, expression)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(expression);

  @override
  _$ActivityDefinitionDynamicValueCopyWith<_ActivityDefinitionDynamicValue>
      get copyWith => __$ActivityDefinitionDynamicValueCopyWithImpl<
          _ActivityDefinitionDynamicValue>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ActivityDefinitionDynamicValueToJson(this);
  }
}

abstract class _ActivityDefinitionDynamicValue
    implements ActivityDefinitionDynamicValue {
  const factory _ActivityDefinitionDynamicValue(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String path,
          @required @JsonKey(required: true) Expression expression}) =
      _$_ActivityDefinitionDynamicValue;

  factory _ActivityDefinitionDynamicValue.fromJson(Map<String, dynamic> json) =
      _$_ActivityDefinitionDynamicValue.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get path;
  @override
  @JsonKey(required: true)
  Expression get expression;
  @override
  _$ActivityDefinitionDynamicValueCopyWith<_ActivityDefinitionDynamicValue>
      get copyWith;
}

DeviceDefinition _$DeviceDefinitionFromJson(Map<String, dynamic> json) {
  return _DeviceDefinition.fromJson(json);
}

class _$DeviceDefinitionTearOff {
  const _$DeviceDefinitionTearOff();

  _DeviceDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'DeviceDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<DeviceDefinitionUdiDeviceIdentifier> udiDeviceIdentifier,
      String manufacturerString,
      Reference manufacturerReference,
      List<DeviceDefinitionDeviceName> deviceName,
      String modelNumber,
      CodeableConcept type,
      List<DeviceDefinitionSpecialization> specialization,
      List<String> version,
      List<CodeableConcept> safety,
      List<ProductShelfLife> shelfLifeStorage,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> languageCode,
      List<DeviceDefinitionCapability> capability,
      List<DeviceDefinitionProperty> property,
      Reference owner,
      List<ContactPoint> contact,
      FhirUri url,
      FhirUri onlineInformation,
      List<Annotation> note,
      Quantity quantity,
      Reference parentDevice,
      List<DeviceDefinitionMaterial> material}) {
    return _DeviceDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      udiDeviceIdentifier: udiDeviceIdentifier,
      manufacturerString: manufacturerString,
      manufacturerReference: manufacturerReference,
      deviceName: deviceName,
      modelNumber: modelNumber,
      type: type,
      specialization: specialization,
      version: version,
      safety: safety,
      shelfLifeStorage: shelfLifeStorage,
      physicalCharacteristics: physicalCharacteristics,
      languageCode: languageCode,
      capability: capability,
      property: property,
      owner: owner,
      contact: contact,
      url: url,
      onlineInformation: onlineInformation,
      note: note,
      quantity: quantity,
      parentDevice: parentDevice,
      material: material,
    );
  }
}

// ignore: unused_element
const $DeviceDefinition = _$DeviceDefinitionTearOff();

mixin _$DeviceDefinition {
  @JsonKey(required: true, defaultValue: 'DeviceDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  List<DeviceDefinitionUdiDeviceIdentifier> get udiDeviceIdentifier;
  String get manufacturerString;
  Reference get manufacturerReference;
  List<DeviceDefinitionDeviceName> get deviceName;
  String get modelNumber;
  CodeableConcept get type;
  List<DeviceDefinitionSpecialization> get specialization;
  List<String> get version;
  List<CodeableConcept> get safety;
  List<ProductShelfLife> get shelfLifeStorage;
  ProdCharacteristic get physicalCharacteristics;
  List<CodeableConcept> get languageCode;
  List<DeviceDefinitionCapability> get capability;
  List<DeviceDefinitionProperty> get property;
  Reference get owner;
  List<ContactPoint> get contact;
  FhirUri get url;
  FhirUri get onlineInformation;
  List<Annotation> get note;
  Quantity get quantity;
  Reference get parentDevice;
  List<DeviceDefinitionMaterial> get material;

  Map<String, dynamic> toJson();
  $DeviceDefinitionCopyWith<DeviceDefinition> get copyWith;
}

abstract class $DeviceDefinitionCopyWith<$Res> {
  factory $DeviceDefinitionCopyWith(
          DeviceDefinition value, $Res Function(DeviceDefinition) then) =
      _$DeviceDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'DeviceDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<DeviceDefinitionUdiDeviceIdentifier> udiDeviceIdentifier,
      String manufacturerString,
      Reference manufacturerReference,
      List<DeviceDefinitionDeviceName> deviceName,
      String modelNumber,
      CodeableConcept type,
      List<DeviceDefinitionSpecialization> specialization,
      List<String> version,
      List<CodeableConcept> safety,
      List<ProductShelfLife> shelfLifeStorage,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> languageCode,
      List<DeviceDefinitionCapability> capability,
      List<DeviceDefinitionProperty> property,
      Reference owner,
      List<ContactPoint> contact,
      FhirUri url,
      FhirUri onlineInformation,
      List<Annotation> note,
      Quantity quantity,
      Reference parentDevice,
      List<DeviceDefinitionMaterial> material});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $ReferenceCopyWith<$Res> get manufacturerReference;
  $CodeableConceptCopyWith<$Res> get type;
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
  $ReferenceCopyWith<$Res> get owner;
  $QuantityCopyWith<$Res> get quantity;
  $ReferenceCopyWith<$Res> get parentDevice;
}

class _$DeviceDefinitionCopyWithImpl<$Res>
    implements $DeviceDefinitionCopyWith<$Res> {
  _$DeviceDefinitionCopyWithImpl(this._value, this._then);

  final DeviceDefinition _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object udiDeviceIdentifier = freezed,
    Object manufacturerString = freezed,
    Object manufacturerReference = freezed,
    Object deviceName = freezed,
    Object modelNumber = freezed,
    Object type = freezed,
    Object specialization = freezed,
    Object version = freezed,
    Object safety = freezed,
    Object shelfLifeStorage = freezed,
    Object physicalCharacteristics = freezed,
    Object languageCode = freezed,
    Object capability = freezed,
    Object property = freezed,
    Object owner = freezed,
    Object contact = freezed,
    Object url = freezed,
    Object onlineInformation = freezed,
    Object note = freezed,
    Object quantity = freezed,
    Object parentDevice = freezed,
    Object material = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      udiDeviceIdentifier: udiDeviceIdentifier == freezed
          ? _value.udiDeviceIdentifier
          : udiDeviceIdentifier as List<DeviceDefinitionUdiDeviceIdentifier>,
      manufacturerString: manufacturerString == freezed
          ? _value.manufacturerString
          : manufacturerString as String,
      manufacturerReference: manufacturerReference == freezed
          ? _value.manufacturerReference
          : manufacturerReference as Reference,
      deviceName: deviceName == freezed
          ? _value.deviceName
          : deviceName as List<DeviceDefinitionDeviceName>,
      modelNumber:
          modelNumber == freezed ? _value.modelNumber : modelNumber as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      specialization: specialization == freezed
          ? _value.specialization
          : specialization as List<DeviceDefinitionSpecialization>,
      version: version == freezed ? _value.version : version as List<String>,
      safety:
          safety == freezed ? _value.safety : safety as List<CodeableConcept>,
      shelfLifeStorage: shelfLifeStorage == freezed
          ? _value.shelfLifeStorage
          : shelfLifeStorage as List<ProductShelfLife>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      languageCode: languageCode == freezed
          ? _value.languageCode
          : languageCode as List<CodeableConcept>,
      capability: capability == freezed
          ? _value.capability
          : capability as List<DeviceDefinitionCapability>,
      property: property == freezed
          ? _value.property
          : property as List<DeviceDefinitionProperty>,
      owner: owner == freezed ? _value.owner : owner as Reference,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactPoint>,
      url: url == freezed ? _value.url : url as FhirUri,
      onlineInformation: onlineInformation == freezed
          ? _value.onlineInformation
          : onlineInformation as FhirUri,
      note: note == freezed ? _value.note : note as List<Annotation>,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      parentDevice: parentDevice == freezed
          ? _value.parentDevice
          : parentDevice as Reference,
      material: material == freezed
          ? _value.material
          : material as List<DeviceDefinitionMaterial>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get manufacturerReference {
    if (_value.manufacturerReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.manufacturerReference, (value) {
      return _then(_value.copyWith(manufacturerReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics {
    if (_value.physicalCharacteristics == null) {
      return null;
    }
    return $ProdCharacteristicCopyWith<$Res>(_value.physicalCharacteristics,
        (value) {
      return _then(_value.copyWith(physicalCharacteristics: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get owner {
    if (_value.owner == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.owner, (value) {
      return _then(_value.copyWith(owner: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get quantity {
    if (_value.quantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.quantity, (value) {
      return _then(_value.copyWith(quantity: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get parentDevice {
    if (_value.parentDevice == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.parentDevice, (value) {
      return _then(_value.copyWith(parentDevice: value));
    });
  }
}

abstract class _$DeviceDefinitionCopyWith<$Res>
    implements $DeviceDefinitionCopyWith<$Res> {
  factory _$DeviceDefinitionCopyWith(
          _DeviceDefinition value, $Res Function(_DeviceDefinition) then) =
      __$DeviceDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'DeviceDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<DeviceDefinitionUdiDeviceIdentifier> udiDeviceIdentifier,
      String manufacturerString,
      Reference manufacturerReference,
      List<DeviceDefinitionDeviceName> deviceName,
      String modelNumber,
      CodeableConcept type,
      List<DeviceDefinitionSpecialization> specialization,
      List<String> version,
      List<CodeableConcept> safety,
      List<ProductShelfLife> shelfLifeStorage,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> languageCode,
      List<DeviceDefinitionCapability> capability,
      List<DeviceDefinitionProperty> property,
      Reference owner,
      List<ContactPoint> contact,
      FhirUri url,
      FhirUri onlineInformation,
      List<Annotation> note,
      Quantity quantity,
      Reference parentDevice,
      List<DeviceDefinitionMaterial> material});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $ReferenceCopyWith<$Res> get manufacturerReference;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
  @override
  $ReferenceCopyWith<$Res> get owner;
  @override
  $QuantityCopyWith<$Res> get quantity;
  @override
  $ReferenceCopyWith<$Res> get parentDevice;
}

class __$DeviceDefinitionCopyWithImpl<$Res>
    extends _$DeviceDefinitionCopyWithImpl<$Res>
    implements _$DeviceDefinitionCopyWith<$Res> {
  __$DeviceDefinitionCopyWithImpl(
      _DeviceDefinition _value, $Res Function(_DeviceDefinition) _then)
      : super(_value, (v) => _then(v as _DeviceDefinition));

  @override
  _DeviceDefinition get _value => super._value as _DeviceDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object udiDeviceIdentifier = freezed,
    Object manufacturerString = freezed,
    Object manufacturerReference = freezed,
    Object deviceName = freezed,
    Object modelNumber = freezed,
    Object type = freezed,
    Object specialization = freezed,
    Object version = freezed,
    Object safety = freezed,
    Object shelfLifeStorage = freezed,
    Object physicalCharacteristics = freezed,
    Object languageCode = freezed,
    Object capability = freezed,
    Object property = freezed,
    Object owner = freezed,
    Object contact = freezed,
    Object url = freezed,
    Object onlineInformation = freezed,
    Object note = freezed,
    Object quantity = freezed,
    Object parentDevice = freezed,
    Object material = freezed,
  }) {
    return _then(_DeviceDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      udiDeviceIdentifier: udiDeviceIdentifier == freezed
          ? _value.udiDeviceIdentifier
          : udiDeviceIdentifier as List<DeviceDefinitionUdiDeviceIdentifier>,
      manufacturerString: manufacturerString == freezed
          ? _value.manufacturerString
          : manufacturerString as String,
      manufacturerReference: manufacturerReference == freezed
          ? _value.manufacturerReference
          : manufacturerReference as Reference,
      deviceName: deviceName == freezed
          ? _value.deviceName
          : deviceName as List<DeviceDefinitionDeviceName>,
      modelNumber:
          modelNumber == freezed ? _value.modelNumber : modelNumber as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      specialization: specialization == freezed
          ? _value.specialization
          : specialization as List<DeviceDefinitionSpecialization>,
      version: version == freezed ? _value.version : version as List<String>,
      safety:
          safety == freezed ? _value.safety : safety as List<CodeableConcept>,
      shelfLifeStorage: shelfLifeStorage == freezed
          ? _value.shelfLifeStorage
          : shelfLifeStorage as List<ProductShelfLife>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      languageCode: languageCode == freezed
          ? _value.languageCode
          : languageCode as List<CodeableConcept>,
      capability: capability == freezed
          ? _value.capability
          : capability as List<DeviceDefinitionCapability>,
      property: property == freezed
          ? _value.property
          : property as List<DeviceDefinitionProperty>,
      owner: owner == freezed ? _value.owner : owner as Reference,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactPoint>,
      url: url == freezed ? _value.url : url as FhirUri,
      onlineInformation: onlineInformation == freezed
          ? _value.onlineInformation
          : onlineInformation as FhirUri,
      note: note == freezed ? _value.note : note as List<Annotation>,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      parentDevice: parentDevice == freezed
          ? _value.parentDevice
          : parentDevice as Reference,
      material: material == freezed
          ? _value.material
          : material as List<DeviceDefinitionMaterial>,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinition implements _DeviceDefinition {
  const _$_DeviceDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'DeviceDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.udiDeviceIdentifier,
      this.manufacturerString,
      this.manufacturerReference,
      this.deviceName,
      this.modelNumber,
      this.type,
      this.specialization,
      this.version,
      this.safety,
      this.shelfLifeStorage,
      this.physicalCharacteristics,
      this.languageCode,
      this.capability,
      this.property,
      this.owner,
      this.contact,
      this.url,
      this.onlineInformation,
      this.note,
      this.quantity,
      this.parentDevice,
      this.material})
      : assert(resourceType != null);

  factory _$_DeviceDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'DeviceDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final List<DeviceDefinitionUdiDeviceIdentifier> udiDeviceIdentifier;
  @override
  final String manufacturerString;
  @override
  final Reference manufacturerReference;
  @override
  final List<DeviceDefinitionDeviceName> deviceName;
  @override
  final String modelNumber;
  @override
  final CodeableConcept type;
  @override
  final List<DeviceDefinitionSpecialization> specialization;
  @override
  final List<String> version;
  @override
  final List<CodeableConcept> safety;
  @override
  final List<ProductShelfLife> shelfLifeStorage;
  @override
  final ProdCharacteristic physicalCharacteristics;
  @override
  final List<CodeableConcept> languageCode;
  @override
  final List<DeviceDefinitionCapability> capability;
  @override
  final List<DeviceDefinitionProperty> property;
  @override
  final Reference owner;
  @override
  final List<ContactPoint> contact;
  @override
  final FhirUri url;
  @override
  final FhirUri onlineInformation;
  @override
  final List<Annotation> note;
  @override
  final Quantity quantity;
  @override
  final Reference parentDevice;
  @override
  final List<DeviceDefinitionMaterial> material;

  @override
  String toString() {
    return 'DeviceDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, udiDeviceIdentifier: $udiDeviceIdentifier, manufacturerString: $manufacturerString, manufacturerReference: $manufacturerReference, deviceName: $deviceName, modelNumber: $modelNumber, type: $type, specialization: $specialization, version: $version, safety: $safety, shelfLifeStorage: $shelfLifeStorage, physicalCharacteristics: $physicalCharacteristics, languageCode: $languageCode, capability: $capability, property: $property, owner: $owner, contact: $contact, url: $url, onlineInformation: $onlineInformation, note: $note, quantity: $quantity, parentDevice: $parentDevice, material: $material)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.udiDeviceIdentifier, udiDeviceIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.udiDeviceIdentifier, udiDeviceIdentifier)) &&
            (identical(other.manufacturerString, manufacturerString) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturerString, manufacturerString)) &&
            (identical(other.manufacturerReference, manufacturerReference) ||
                const DeepCollectionEquality().equals(
                    other.manufacturerReference, manufacturerReference)) &&
            (identical(other.deviceName, deviceName) ||
                const DeepCollectionEquality()
                    .equals(other.deviceName, deviceName)) &&
            (identical(other.modelNumber, modelNumber) ||
                const DeepCollectionEquality()
                    .equals(other.modelNumber, modelNumber)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.specialization, specialization) ||
                const DeepCollectionEquality()
                    .equals(other.specialization, specialization)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.safety, safety) ||
                const DeepCollectionEquality().equals(other.safety, safety)) &&
            (identical(other.shelfLifeStorage, shelfLifeStorage) ||
                const DeepCollectionEquality()
                    .equals(other.shelfLifeStorage, shelfLifeStorage)) &&
            (identical(other.physicalCharacteristics, physicalCharacteristics) ||
                const DeepCollectionEquality().equals(
                    other.physicalCharacteristics, physicalCharacteristics)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.capability, capability) ||
                const DeepCollectionEquality()
                    .equals(other.capability, capability)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality().equals(other.property, property)) &&
            (identical(other.owner, owner) || const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.contact, contact) || const DeepCollectionEquality().equals(other.contact, contact)) &&
            (identical(other.url, url) || const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.onlineInformation, onlineInformation) || const DeepCollectionEquality().equals(other.onlineInformation, onlineInformation)) &&
            (identical(other.note, note) || const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.quantity, quantity) || const DeepCollectionEquality().equals(other.quantity, quantity)) &&
            (identical(other.parentDevice, parentDevice) || const DeepCollectionEquality().equals(other.parentDevice, parentDevice)) &&
            (identical(other.material, material) || const DeepCollectionEquality().equals(other.material, material)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(udiDeviceIdentifier) ^
      const DeepCollectionEquality().hash(manufacturerString) ^
      const DeepCollectionEquality().hash(manufacturerReference) ^
      const DeepCollectionEquality().hash(deviceName) ^
      const DeepCollectionEquality().hash(modelNumber) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(specialization) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(safety) ^
      const DeepCollectionEquality().hash(shelfLifeStorage) ^
      const DeepCollectionEquality().hash(physicalCharacteristics) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(capability) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(onlineInformation) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(parentDevice) ^
      const DeepCollectionEquality().hash(material);

  @override
  _$DeviceDefinitionCopyWith<_DeviceDefinition> get copyWith =>
      __$DeviceDefinitionCopyWithImpl<_DeviceDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionToJson(this);
  }
}

abstract class _DeviceDefinition implements DeviceDefinition {
  const factory _DeviceDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'DeviceDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<DeviceDefinitionUdiDeviceIdentifier> udiDeviceIdentifier,
      String manufacturerString,
      Reference manufacturerReference,
      List<DeviceDefinitionDeviceName> deviceName,
      String modelNumber,
      CodeableConcept type,
      List<DeviceDefinitionSpecialization> specialization,
      List<String> version,
      List<CodeableConcept> safety,
      List<ProductShelfLife> shelfLifeStorage,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> languageCode,
      List<DeviceDefinitionCapability> capability,
      List<DeviceDefinitionProperty> property,
      Reference owner,
      List<ContactPoint> contact,
      FhirUri url,
      FhirUri onlineInformation,
      List<Annotation> note,
      Quantity quantity,
      Reference parentDevice,
      List<DeviceDefinitionMaterial> material}) = _$_DeviceDefinition;

  factory _DeviceDefinition.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'DeviceDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  List<DeviceDefinitionUdiDeviceIdentifier> get udiDeviceIdentifier;
  @override
  String get manufacturerString;
  @override
  Reference get manufacturerReference;
  @override
  List<DeviceDefinitionDeviceName> get deviceName;
  @override
  String get modelNumber;
  @override
  CodeableConcept get type;
  @override
  List<DeviceDefinitionSpecialization> get specialization;
  @override
  List<String> get version;
  @override
  List<CodeableConcept> get safety;
  @override
  List<ProductShelfLife> get shelfLifeStorage;
  @override
  ProdCharacteristic get physicalCharacteristics;
  @override
  List<CodeableConcept> get languageCode;
  @override
  List<DeviceDefinitionCapability> get capability;
  @override
  List<DeviceDefinitionProperty> get property;
  @override
  Reference get owner;
  @override
  List<ContactPoint> get contact;
  @override
  FhirUri get url;
  @override
  FhirUri get onlineInformation;
  @override
  List<Annotation> get note;
  @override
  Quantity get quantity;
  @override
  Reference get parentDevice;
  @override
  List<DeviceDefinitionMaterial> get material;
  @override
  _$DeviceDefinitionCopyWith<_DeviceDefinition> get copyWith;
}

DeviceDefinitionUdiDeviceIdentifier
    _$DeviceDefinitionUdiDeviceIdentifierFromJson(Map<String, dynamic> json) {
  return _DeviceDefinitionUdiDeviceIdentifier.fromJson(json);
}

class _$DeviceDefinitionUdiDeviceIdentifierTearOff {
  const _$DeviceDefinitionUdiDeviceIdentifierTearOff();

  _DeviceDefinitionUdiDeviceIdentifier call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String deviceIdentifier,
      FhirUri issuer,
      FhirUri jurisdiction}) {
    return _DeviceDefinitionUdiDeviceIdentifier(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      deviceIdentifier: deviceIdentifier,
      issuer: issuer,
      jurisdiction: jurisdiction,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionUdiDeviceIdentifier =
    _$DeviceDefinitionUdiDeviceIdentifierTearOff();

mixin _$DeviceDefinitionUdiDeviceIdentifier {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get deviceIdentifier;
  FhirUri get issuer;
  FhirUri get jurisdiction;

  Map<String, dynamic> toJson();
  $DeviceDefinitionUdiDeviceIdentifierCopyWith<
      DeviceDefinitionUdiDeviceIdentifier> get copyWith;
}

abstract class $DeviceDefinitionUdiDeviceIdentifierCopyWith<$Res> {
  factory $DeviceDefinitionUdiDeviceIdentifierCopyWith(
          DeviceDefinitionUdiDeviceIdentifier value,
          $Res Function(DeviceDefinitionUdiDeviceIdentifier) then) =
      _$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String deviceIdentifier,
      FhirUri issuer,
      FhirUri jurisdiction});
}

class _$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<$Res>
    implements $DeviceDefinitionUdiDeviceIdentifierCopyWith<$Res> {
  _$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl(this._value, this._then);

  final DeviceDefinitionUdiDeviceIdentifier _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionUdiDeviceIdentifier) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object deviceIdentifier = freezed,
    Object issuer = freezed,
    Object jurisdiction = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      deviceIdentifier: deviceIdentifier == freezed
          ? _value.deviceIdentifier
          : deviceIdentifier as String,
      issuer: issuer == freezed ? _value.issuer : issuer as FhirUri,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as FhirUri,
    ));
  }
}

abstract class _$DeviceDefinitionUdiDeviceIdentifierCopyWith<$Res>
    implements $DeviceDefinitionUdiDeviceIdentifierCopyWith<$Res> {
  factory _$DeviceDefinitionUdiDeviceIdentifierCopyWith(
          _DeviceDefinitionUdiDeviceIdentifier value,
          $Res Function(_DeviceDefinitionUdiDeviceIdentifier) then) =
      __$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String deviceIdentifier,
      FhirUri issuer,
      FhirUri jurisdiction});
}

class __$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<$Res>
    extends _$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<$Res>
    implements _$DeviceDefinitionUdiDeviceIdentifierCopyWith<$Res> {
  __$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl(
      _DeviceDefinitionUdiDeviceIdentifier _value,
      $Res Function(_DeviceDefinitionUdiDeviceIdentifier) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionUdiDeviceIdentifier));

  @override
  _DeviceDefinitionUdiDeviceIdentifier get _value =>
      super._value as _DeviceDefinitionUdiDeviceIdentifier;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object deviceIdentifier = freezed,
    Object issuer = freezed,
    Object jurisdiction = freezed,
  }) {
    return _then(_DeviceDefinitionUdiDeviceIdentifier(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      deviceIdentifier: deviceIdentifier == freezed
          ? _value.deviceIdentifier
          : deviceIdentifier as String,
      issuer: issuer == freezed ? _value.issuer : issuer as FhirUri,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as FhirUri,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionUdiDeviceIdentifier
    implements _DeviceDefinitionUdiDeviceIdentifier {
  const _$_DeviceDefinitionUdiDeviceIdentifier(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.deviceIdentifier,
      this.issuer,
      this.jurisdiction});

  factory _$_DeviceDefinitionUdiDeviceIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionUdiDeviceIdentifierFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String deviceIdentifier;
  @override
  final FhirUri issuer;
  @override
  final FhirUri jurisdiction;

  @override
  String toString() {
    return 'DeviceDefinitionUdiDeviceIdentifier(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, deviceIdentifier: $deviceIdentifier, issuer: $issuer, jurisdiction: $jurisdiction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionUdiDeviceIdentifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.deviceIdentifier, deviceIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.deviceIdentifier, deviceIdentifier)) &&
            (identical(other.issuer, issuer) ||
                const DeepCollectionEquality().equals(other.issuer, issuer)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(deviceIdentifier) ^
      const DeepCollectionEquality().hash(issuer) ^
      const DeepCollectionEquality().hash(jurisdiction);

  @override
  _$DeviceDefinitionUdiDeviceIdentifierCopyWith<
          _DeviceDefinitionUdiDeviceIdentifier>
      get copyWith => __$DeviceDefinitionUdiDeviceIdentifierCopyWithImpl<
          _DeviceDefinitionUdiDeviceIdentifier>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionUdiDeviceIdentifierToJson(this);
  }
}

abstract class _DeviceDefinitionUdiDeviceIdentifier
    implements DeviceDefinitionUdiDeviceIdentifier {
  const factory _DeviceDefinitionUdiDeviceIdentifier(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String deviceIdentifier,
      FhirUri issuer,
      FhirUri jurisdiction}) = _$_DeviceDefinitionUdiDeviceIdentifier;

  factory _DeviceDefinitionUdiDeviceIdentifier.fromJson(
          Map<String, dynamic> json) =
      _$_DeviceDefinitionUdiDeviceIdentifier.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get deviceIdentifier;
  @override
  FhirUri get issuer;
  @override
  FhirUri get jurisdiction;
  @override
  _$DeviceDefinitionUdiDeviceIdentifierCopyWith<
      _DeviceDefinitionUdiDeviceIdentifier> get copyWith;
}

DeviceDefinitionDeviceName _$DeviceDefinitionDeviceNameFromJson(
    Map<String, dynamic> json) {
  return _DeviceDefinitionDeviceName.fromJson(json);
}

class _$DeviceDefinitionDeviceNameTearOff {
  const _$DeviceDefinitionDeviceNameTearOff();

  _DeviceDefinitionDeviceName call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      @JsonKey(unknownEnumValue: DeviceNameType.unknown) DeviceNameType type}) {
    return _DeviceDefinitionDeviceName(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      type: type,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionDeviceName = _$DeviceDefinitionDeviceNameTearOff();

mixin _$DeviceDefinitionDeviceName {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  @JsonKey(unknownEnumValue: DeviceNameType.unknown)
  DeviceNameType get type;

  Map<String, dynamic> toJson();
  $DeviceDefinitionDeviceNameCopyWith<DeviceDefinitionDeviceName> get copyWith;
}

abstract class $DeviceDefinitionDeviceNameCopyWith<$Res> {
  factory $DeviceDefinitionDeviceNameCopyWith(DeviceDefinitionDeviceName value,
          $Res Function(DeviceDefinitionDeviceName) then) =
      _$DeviceDefinitionDeviceNameCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      @JsonKey(unknownEnumValue: DeviceNameType.unknown) DeviceNameType type});
}

class _$DeviceDefinitionDeviceNameCopyWithImpl<$Res>
    implements $DeviceDefinitionDeviceNameCopyWith<$Res> {
  _$DeviceDefinitionDeviceNameCopyWithImpl(this._value, this._then);

  final DeviceDefinitionDeviceName _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionDeviceName) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as DeviceNameType,
    ));
  }
}

abstract class _$DeviceDefinitionDeviceNameCopyWith<$Res>
    implements $DeviceDefinitionDeviceNameCopyWith<$Res> {
  factory _$DeviceDefinitionDeviceNameCopyWith(
          _DeviceDefinitionDeviceName value,
          $Res Function(_DeviceDefinitionDeviceName) then) =
      __$DeviceDefinitionDeviceNameCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      @JsonKey(unknownEnumValue: DeviceNameType.unknown) DeviceNameType type});
}

class __$DeviceDefinitionDeviceNameCopyWithImpl<$Res>
    extends _$DeviceDefinitionDeviceNameCopyWithImpl<$Res>
    implements _$DeviceDefinitionDeviceNameCopyWith<$Res> {
  __$DeviceDefinitionDeviceNameCopyWithImpl(_DeviceDefinitionDeviceName _value,
      $Res Function(_DeviceDefinitionDeviceName) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionDeviceName));

  @override
  _DeviceDefinitionDeviceName get _value =>
      super._value as _DeviceDefinitionDeviceName;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
  }) {
    return _then(_DeviceDefinitionDeviceName(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as DeviceNameType,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionDeviceName implements _DeviceDefinitionDeviceName {
  const _$_DeviceDefinitionDeviceName(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      @JsonKey(unknownEnumValue: DeviceNameType.unknown) this.type});

  factory _$_DeviceDefinitionDeviceName.fromJson(Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionDeviceNameFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  @JsonKey(unknownEnumValue: DeviceNameType.unknown)
  final DeviceNameType type;

  @override
  String toString() {
    return 'DeviceDefinitionDeviceName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionDeviceName &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type);

  @override
  _$DeviceDefinitionDeviceNameCopyWith<_DeviceDefinitionDeviceName>
      get copyWith => __$DeviceDefinitionDeviceNameCopyWithImpl<
          _DeviceDefinitionDeviceName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionDeviceNameToJson(this);
  }
}

abstract class _DeviceDefinitionDeviceName
    implements DeviceDefinitionDeviceName {
  const factory _DeviceDefinitionDeviceName(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      @JsonKey(unknownEnumValue: DeviceNameType.unknown)
          DeviceNameType type}) = _$_DeviceDefinitionDeviceName;

  factory _DeviceDefinitionDeviceName.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinitionDeviceName.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  @JsonKey(unknownEnumValue: DeviceNameType.unknown)
  DeviceNameType get type;
  @override
  _$DeviceDefinitionDeviceNameCopyWith<_DeviceDefinitionDeviceName>
      get copyWith;
}

DeviceDefinitionSpecialization _$DeviceDefinitionSpecializationFromJson(
    Map<String, dynamic> json) {
  return _DeviceDefinitionSpecialization.fromJson(json);
}

class _$DeviceDefinitionSpecializationTearOff {
  const _$DeviceDefinitionSpecializationTearOff();

  _DeviceDefinitionSpecialization call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String systemType,
      String version}) {
    return _DeviceDefinitionSpecialization(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      systemType: systemType,
      version: version,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionSpecialization =
    _$DeviceDefinitionSpecializationTearOff();

mixin _$DeviceDefinitionSpecialization {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get systemType;
  String get version;

  Map<String, dynamic> toJson();
  $DeviceDefinitionSpecializationCopyWith<DeviceDefinitionSpecialization>
      get copyWith;
}

abstract class $DeviceDefinitionSpecializationCopyWith<$Res> {
  factory $DeviceDefinitionSpecializationCopyWith(
          DeviceDefinitionSpecialization value,
          $Res Function(DeviceDefinitionSpecialization) then) =
      _$DeviceDefinitionSpecializationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String systemType,
      String version});
}

class _$DeviceDefinitionSpecializationCopyWithImpl<$Res>
    implements $DeviceDefinitionSpecializationCopyWith<$Res> {
  _$DeviceDefinitionSpecializationCopyWithImpl(this._value, this._then);

  final DeviceDefinitionSpecialization _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionSpecialization) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object systemType = freezed,
    Object version = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      systemType:
          systemType == freezed ? _value.systemType : systemType as String,
      version: version == freezed ? _value.version : version as String,
    ));
  }
}

abstract class _$DeviceDefinitionSpecializationCopyWith<$Res>
    implements $DeviceDefinitionSpecializationCopyWith<$Res> {
  factory _$DeviceDefinitionSpecializationCopyWith(
          _DeviceDefinitionSpecialization value,
          $Res Function(_DeviceDefinitionSpecialization) then) =
      __$DeviceDefinitionSpecializationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String systemType,
      String version});
}

class __$DeviceDefinitionSpecializationCopyWithImpl<$Res>
    extends _$DeviceDefinitionSpecializationCopyWithImpl<$Res>
    implements _$DeviceDefinitionSpecializationCopyWith<$Res> {
  __$DeviceDefinitionSpecializationCopyWithImpl(
      _DeviceDefinitionSpecialization _value,
      $Res Function(_DeviceDefinitionSpecialization) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionSpecialization));

  @override
  _DeviceDefinitionSpecialization get _value =>
      super._value as _DeviceDefinitionSpecialization;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object systemType = freezed,
    Object version = freezed,
  }) {
    return _then(_DeviceDefinitionSpecialization(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      systemType:
          systemType == freezed ? _value.systemType : systemType as String,
      version: version == freezed ? _value.version : version as String,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionSpecialization
    implements _DeviceDefinitionSpecialization {
  const _$_DeviceDefinitionSpecialization(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.systemType,
      this.version});

  factory _$_DeviceDefinitionSpecialization.fromJson(
          Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionSpecializationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String systemType;
  @override
  final String version;

  @override
  String toString() {
    return 'DeviceDefinitionSpecialization(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, systemType: $systemType, version: $version)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionSpecialization &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.systemType, systemType) ||
                const DeepCollectionEquality()
                    .equals(other.systemType, systemType)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(systemType) ^
      const DeepCollectionEquality().hash(version);

  @override
  _$DeviceDefinitionSpecializationCopyWith<_DeviceDefinitionSpecialization>
      get copyWith => __$DeviceDefinitionSpecializationCopyWithImpl<
          _DeviceDefinitionSpecialization>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionSpecializationToJson(this);
  }
}

abstract class _DeviceDefinitionSpecialization
    implements DeviceDefinitionSpecialization {
  const factory _DeviceDefinitionSpecialization(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String systemType,
      String version}) = _$_DeviceDefinitionSpecialization;

  factory _DeviceDefinitionSpecialization.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinitionSpecialization.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get systemType;
  @override
  String get version;
  @override
  _$DeviceDefinitionSpecializationCopyWith<_DeviceDefinitionSpecialization>
      get copyWith;
}

DeviceDefinitionCapability _$DeviceDefinitionCapabilityFromJson(
    Map<String, dynamic> json) {
  return _DeviceDefinitionCapability.fromJson(json);
}

class _$DeviceDefinitionCapabilityTearOff {
  const _$DeviceDefinitionCapabilityTearOff();

  _DeviceDefinitionCapability call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept type,
      List<CodeableConcept> description}) {
    return _DeviceDefinitionCapability(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      description: description,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionCapability = _$DeviceDefinitionCapabilityTearOff();

mixin _$DeviceDefinitionCapability {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get type;
  List<CodeableConcept> get description;

  Map<String, dynamic> toJson();
  $DeviceDefinitionCapabilityCopyWith<DeviceDefinitionCapability> get copyWith;
}

abstract class $DeviceDefinitionCapabilityCopyWith<$Res> {
  factory $DeviceDefinitionCapabilityCopyWith(DeviceDefinitionCapability value,
          $Res Function(DeviceDefinitionCapability) then) =
      _$DeviceDefinitionCapabilityCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept type,
      List<CodeableConcept> description});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$DeviceDefinitionCapabilityCopyWithImpl<$Res>
    implements $DeviceDefinitionCapabilityCopyWith<$Res> {
  _$DeviceDefinitionCapabilityCopyWithImpl(this._value, this._then);

  final DeviceDefinitionCapability _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionCapability) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object description = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      description: description == freezed
          ? _value.description
          : description as List<CodeableConcept>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$DeviceDefinitionCapabilityCopyWith<$Res>
    implements $DeviceDefinitionCapabilityCopyWith<$Res> {
  factory _$DeviceDefinitionCapabilityCopyWith(
          _DeviceDefinitionCapability value,
          $Res Function(_DeviceDefinitionCapability) then) =
      __$DeviceDefinitionCapabilityCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept type,
      List<CodeableConcept> description});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$DeviceDefinitionCapabilityCopyWithImpl<$Res>
    extends _$DeviceDefinitionCapabilityCopyWithImpl<$Res>
    implements _$DeviceDefinitionCapabilityCopyWith<$Res> {
  __$DeviceDefinitionCapabilityCopyWithImpl(_DeviceDefinitionCapability _value,
      $Res Function(_DeviceDefinitionCapability) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionCapability));

  @override
  _DeviceDefinitionCapability get _value =>
      super._value as _DeviceDefinitionCapability;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object description = freezed,
  }) {
    return _then(_DeviceDefinitionCapability(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      description: description == freezed
          ? _value.description
          : description as List<CodeableConcept>,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionCapability implements _DeviceDefinitionCapability {
  const _$_DeviceDefinitionCapability(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.type,
      this.description})
      : assert(type != null);

  factory _$_DeviceDefinitionCapability.fromJson(Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionCapabilityFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept type;
  @override
  final List<CodeableConcept> description;

  @override
  String toString() {
    return 'DeviceDefinitionCapability(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionCapability &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description);

  @override
  _$DeviceDefinitionCapabilityCopyWith<_DeviceDefinitionCapability>
      get copyWith => __$DeviceDefinitionCapabilityCopyWithImpl<
          _DeviceDefinitionCapability>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionCapabilityToJson(this);
  }
}

abstract class _DeviceDefinitionCapability
    implements DeviceDefinitionCapability {
  const factory _DeviceDefinitionCapability(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept type,
      List<CodeableConcept> description}) = _$_DeviceDefinitionCapability;

  factory _DeviceDefinitionCapability.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinitionCapability.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get type;
  @override
  List<CodeableConcept> get description;
  @override
  _$DeviceDefinitionCapabilityCopyWith<_DeviceDefinitionCapability>
      get copyWith;
}

DeviceDefinitionProperty _$DeviceDefinitionPropertyFromJson(
    Map<String, dynamic> json) {
  return _DeviceDefinitionProperty.fromJson(json);
}

class _$DeviceDefinitionPropertyTearOff {
  const _$DeviceDefinitionPropertyTearOff();

  _DeviceDefinitionProperty call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept type,
      List<Quantity> valueQuantity,
      List<CodeableConcept> valueCode}) {
    return _DeviceDefinitionProperty(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      valueQuantity: valueQuantity,
      valueCode: valueCode,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionProperty = _$DeviceDefinitionPropertyTearOff();

mixin _$DeviceDefinitionProperty {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get type;
  List<Quantity> get valueQuantity;
  List<CodeableConcept> get valueCode;

  Map<String, dynamic> toJson();
  $DeviceDefinitionPropertyCopyWith<DeviceDefinitionProperty> get copyWith;
}

abstract class $DeviceDefinitionPropertyCopyWith<$Res> {
  factory $DeviceDefinitionPropertyCopyWith(DeviceDefinitionProperty value,
          $Res Function(DeviceDefinitionProperty) then) =
      _$DeviceDefinitionPropertyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept type,
      List<Quantity> valueQuantity,
      List<CodeableConcept> valueCode});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$DeviceDefinitionPropertyCopyWithImpl<$Res>
    implements $DeviceDefinitionPropertyCopyWith<$Res> {
  _$DeviceDefinitionPropertyCopyWithImpl(this._value, this._then);

  final DeviceDefinitionProperty _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionProperty) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object valueQuantity = freezed,
    Object valueCode = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      valueQuantity: valueQuantity == freezed
          ? _value.valueQuantity
          : valueQuantity as List<Quantity>,
      valueCode: valueCode == freezed
          ? _value.valueCode
          : valueCode as List<CodeableConcept>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$DeviceDefinitionPropertyCopyWith<$Res>
    implements $DeviceDefinitionPropertyCopyWith<$Res> {
  factory _$DeviceDefinitionPropertyCopyWith(_DeviceDefinitionProperty value,
          $Res Function(_DeviceDefinitionProperty) then) =
      __$DeviceDefinitionPropertyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept type,
      List<Quantity> valueQuantity,
      List<CodeableConcept> valueCode});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$DeviceDefinitionPropertyCopyWithImpl<$Res>
    extends _$DeviceDefinitionPropertyCopyWithImpl<$Res>
    implements _$DeviceDefinitionPropertyCopyWith<$Res> {
  __$DeviceDefinitionPropertyCopyWithImpl(_DeviceDefinitionProperty _value,
      $Res Function(_DeviceDefinitionProperty) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionProperty));

  @override
  _DeviceDefinitionProperty get _value =>
      super._value as _DeviceDefinitionProperty;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object valueQuantity = freezed,
    Object valueCode = freezed,
  }) {
    return _then(_DeviceDefinitionProperty(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      valueQuantity: valueQuantity == freezed
          ? _value.valueQuantity
          : valueQuantity as List<Quantity>,
      valueCode: valueCode == freezed
          ? _value.valueCode
          : valueCode as List<CodeableConcept>,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionProperty implements _DeviceDefinitionProperty {
  const _$_DeviceDefinitionProperty(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.type,
      this.valueQuantity,
      this.valueCode})
      : assert(type != null);

  factory _$_DeviceDefinitionProperty.fromJson(Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionPropertyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept type;
  @override
  final List<Quantity> valueQuantity;
  @override
  final List<CodeableConcept> valueCode;

  @override
  String toString() {
    return 'DeviceDefinitionProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, valueQuantity: $valueQuantity, valueCode: $valueCode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionProperty &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.valueQuantity, valueQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.valueQuantity, valueQuantity)) &&
            (identical(other.valueCode, valueCode) ||
                const DeepCollectionEquality()
                    .equals(other.valueCode, valueCode)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(valueQuantity) ^
      const DeepCollectionEquality().hash(valueCode);

  @override
  _$DeviceDefinitionPropertyCopyWith<_DeviceDefinitionProperty> get copyWith =>
      __$DeviceDefinitionPropertyCopyWithImpl<_DeviceDefinitionProperty>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionPropertyToJson(this);
  }
}

abstract class _DeviceDefinitionProperty implements DeviceDefinitionProperty {
  const factory _DeviceDefinitionProperty(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept type,
      List<Quantity> valueQuantity,
      List<CodeableConcept> valueCode}) = _$_DeviceDefinitionProperty;

  factory _DeviceDefinitionProperty.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinitionProperty.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get type;
  @override
  List<Quantity> get valueQuantity;
  @override
  List<CodeableConcept> get valueCode;
  @override
  _$DeviceDefinitionPropertyCopyWith<_DeviceDefinitionProperty> get copyWith;
}

DeviceDefinitionMaterial _$DeviceDefinitionMaterialFromJson(
    Map<String, dynamic> json) {
  return _DeviceDefinitionMaterial.fromJson(json);
}

class _$DeviceDefinitionMaterialTearOff {
  const _$DeviceDefinitionMaterialTearOff();

  _DeviceDefinitionMaterial call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept substance,
      Boolean alternate,
      Boolean allergenicIndicator}) {
    return _DeviceDefinitionMaterial(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      substance: substance,
      alternate: alternate,
      allergenicIndicator: allergenicIndicator,
    );
  }
}

// ignore: unused_element
const $DeviceDefinitionMaterial = _$DeviceDefinitionMaterialTearOff();

mixin _$DeviceDefinitionMaterial {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get substance;
  Boolean get alternate;
  Boolean get allergenicIndicator;

  Map<String, dynamic> toJson();
  $DeviceDefinitionMaterialCopyWith<DeviceDefinitionMaterial> get copyWith;
}

abstract class $DeviceDefinitionMaterialCopyWith<$Res> {
  factory $DeviceDefinitionMaterialCopyWith(DeviceDefinitionMaterial value,
          $Res Function(DeviceDefinitionMaterial) then) =
      _$DeviceDefinitionMaterialCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept substance,
      Boolean alternate,
      Boolean allergenicIndicator});

  $CodeableConceptCopyWith<$Res> get substance;
}

class _$DeviceDefinitionMaterialCopyWithImpl<$Res>
    implements $DeviceDefinitionMaterialCopyWith<$Res> {
  _$DeviceDefinitionMaterialCopyWithImpl(this._value, this._then);

  final DeviceDefinitionMaterial _value;
  // ignore: unused_field
  final $Res Function(DeviceDefinitionMaterial) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substance = freezed,
    Object alternate = freezed,
    Object allergenicIndicator = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substance: substance == freezed
          ? _value.substance
          : substance as CodeableConcept,
      alternate: alternate == freezed ? _value.alternate : alternate as Boolean,
      allergenicIndicator: allergenicIndicator == freezed
          ? _value.allergenicIndicator
          : allergenicIndicator as Boolean,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get substance {
    if (_value.substance == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.substance, (value) {
      return _then(_value.copyWith(substance: value));
    });
  }
}

abstract class _$DeviceDefinitionMaterialCopyWith<$Res>
    implements $DeviceDefinitionMaterialCopyWith<$Res> {
  factory _$DeviceDefinitionMaterialCopyWith(_DeviceDefinitionMaterial value,
          $Res Function(_DeviceDefinitionMaterial) then) =
      __$DeviceDefinitionMaterialCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept substance,
      Boolean alternate,
      Boolean allergenicIndicator});

  @override
  $CodeableConceptCopyWith<$Res> get substance;
}

class __$DeviceDefinitionMaterialCopyWithImpl<$Res>
    extends _$DeviceDefinitionMaterialCopyWithImpl<$Res>
    implements _$DeviceDefinitionMaterialCopyWith<$Res> {
  __$DeviceDefinitionMaterialCopyWithImpl(_DeviceDefinitionMaterial _value,
      $Res Function(_DeviceDefinitionMaterial) _then)
      : super(_value, (v) => _then(v as _DeviceDefinitionMaterial));

  @override
  _DeviceDefinitionMaterial get _value =>
      super._value as _DeviceDefinitionMaterial;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substance = freezed,
    Object alternate = freezed,
    Object allergenicIndicator = freezed,
  }) {
    return _then(_DeviceDefinitionMaterial(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substance: substance == freezed
          ? _value.substance
          : substance as CodeableConcept,
      alternate: alternate == freezed ? _value.alternate : alternate as Boolean,
      allergenicIndicator: allergenicIndicator == freezed
          ? _value.allergenicIndicator
          : allergenicIndicator as Boolean,
    ));
  }
}

@JsonSerializable()
class _$_DeviceDefinitionMaterial implements _DeviceDefinitionMaterial {
  const _$_DeviceDefinitionMaterial(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.substance,
      this.alternate,
      this.allergenicIndicator})
      : assert(substance != null);

  factory _$_DeviceDefinitionMaterial.fromJson(Map<String, dynamic> json) =>
      _$_$_DeviceDefinitionMaterialFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept substance;
  @override
  final Boolean alternate;
  @override
  final Boolean allergenicIndicator;

  @override
  String toString() {
    return 'DeviceDefinitionMaterial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substance: $substance, alternate: $alternate, allergenicIndicator: $allergenicIndicator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DeviceDefinitionMaterial &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)) &&
            (identical(other.alternate, alternate) ||
                const DeepCollectionEquality()
                    .equals(other.alternate, alternate)) &&
            (identical(other.allergenicIndicator, allergenicIndicator) ||
                const DeepCollectionEquality()
                    .equals(other.allergenicIndicator, allergenicIndicator)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(substance) ^
      const DeepCollectionEquality().hash(alternate) ^
      const DeepCollectionEquality().hash(allergenicIndicator);

  @override
  _$DeviceDefinitionMaterialCopyWith<_DeviceDefinitionMaterial> get copyWith =>
      __$DeviceDefinitionMaterialCopyWithImpl<_DeviceDefinitionMaterial>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DeviceDefinitionMaterialToJson(this);
  }
}

abstract class _DeviceDefinitionMaterial implements DeviceDefinitionMaterial {
  const factory _DeviceDefinitionMaterial(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept substance,
      Boolean alternate,
      Boolean allergenicIndicator}) = _$_DeviceDefinitionMaterial;

  factory _DeviceDefinitionMaterial.fromJson(Map<String, dynamic> json) =
      _$_DeviceDefinitionMaterial.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get substance;
  @override
  Boolean get alternate;
  @override
  Boolean get allergenicIndicator;
  @override
  _$DeviceDefinitionMaterialCopyWith<_DeviceDefinitionMaterial> get copyWith;
}

EffectEvidenceSynthesis _$EffectEvidenceSynthesisFromJson(
    Map<String, dynamic> json) {
  return _EffectEvidenceSynthesis.fromJson(json);
}

class _$EffectEvidenceSynthesisTearOff {
  const _$EffectEvidenceSynthesisTearOff();

  _EffectEvidenceSynthesis call(
      {@required
      @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
          EffectEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @required
      @JsonKey(required: true)
          Reference population,
      @required
      @JsonKey(required: true)
          Reference exposure,
      @required
      @JsonKey(required: true)
          Reference exposureAlternative,
      @required
      @JsonKey(required: true)
          Reference outcome,
      EffectEvidenceSynthesisSampleSize sampleSize,
      List<EffectEvidenceSynthesisResultsByExposure> resultsByExposure,
      List<EffectEvidenceSynthesisEffectEstimate> effectEstimate,
      List<EffectEvidenceSynthesisCertainty> certainty}) {
    return _EffectEvidenceSynthesis(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      status: status,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      note: note,
      useContext: useContext,
      jurisdiction: jurisdiction,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      synthesisType: synthesisType,
      studyType: studyType,
      population: population,
      exposure: exposure,
      exposureAlternative: exposureAlternative,
      outcome: outcome,
      sampleSize: sampleSize,
      resultsByExposure: resultsByExposure,
      effectEstimate: effectEstimate,
      certainty: certainty,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesis = _$EffectEvidenceSynthesisTearOff();

mixin _$EffectEvidenceSynthesis {
  @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
  EffectEvidenceSynthesisStatus get status;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<Annotation> get note;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  CodeableConcept get synthesisType;
  CodeableConcept get studyType;
  @JsonKey(required: true)
  Reference get population;
  @JsonKey(required: true)
  Reference get exposure;
  @JsonKey(required: true)
  Reference get exposureAlternative;
  @JsonKey(required: true)
  Reference get outcome;
  EffectEvidenceSynthesisSampleSize get sampleSize;
  List<EffectEvidenceSynthesisResultsByExposure> get resultsByExposure;
  List<EffectEvidenceSynthesisEffectEstimate> get effectEstimate;
  List<EffectEvidenceSynthesisCertainty> get certainty;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisCopyWith<EffectEvidenceSynthesis> get copyWith;
}

abstract class $EffectEvidenceSynthesisCopyWith<$Res> {
  factory $EffectEvidenceSynthesisCopyWith(EffectEvidenceSynthesis value,
          $Res Function(EffectEvidenceSynthesis) then) =
      _$EffectEvidenceSynthesisCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
          EffectEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @JsonKey(required: true)
          Reference population,
      @JsonKey(required: true)
          Reference exposure,
      @JsonKey(required: true)
          Reference exposureAlternative,
      @JsonKey(required: true)
          Reference outcome,
      EffectEvidenceSynthesisSampleSize sampleSize,
      List<EffectEvidenceSynthesisResultsByExposure> resultsByExposure,
      List<EffectEvidenceSynthesisEffectEstimate> effectEstimate,
      List<EffectEvidenceSynthesisCertainty> certainty});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $CodeableConceptCopyWith<$Res> get synthesisType;
  $CodeableConceptCopyWith<$Res> get studyType;
  $ReferenceCopyWith<$Res> get population;
  $ReferenceCopyWith<$Res> get exposure;
  $ReferenceCopyWith<$Res> get exposureAlternative;
  $ReferenceCopyWith<$Res> get outcome;
  $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize;
}

class _$EffectEvidenceSynthesisCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisCopyWith<$Res> {
  _$EffectEvidenceSynthesisCopyWithImpl(this._value, this._then);

  final EffectEvidenceSynthesis _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesis) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object synthesisType = freezed,
    Object studyType = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object exposureAlternative = freezed,
    Object outcome = freezed,
    Object sampleSize = freezed,
    Object resultsByExposure = freezed,
    Object effectEstimate = freezed,
    Object certainty = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed
          ? _value.status
          : status as EffectEvidenceSynthesisStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      synthesisType: synthesisType == freezed
          ? _value.synthesisType
          : synthesisType as CodeableConcept,
      studyType: studyType == freezed
          ? _value.studyType
          : studyType as CodeableConcept,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      exposureAlternative: exposureAlternative == freezed
          ? _value.exposureAlternative
          : exposureAlternative as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
      sampleSize: sampleSize == freezed
          ? _value.sampleSize
          : sampleSize as EffectEvidenceSynthesisSampleSize,
      resultsByExposure: resultsByExposure == freezed
          ? _value.resultsByExposure
          : resultsByExposure as List<EffectEvidenceSynthesisResultsByExposure>,
      effectEstimate: effectEstimate == freezed
          ? _value.effectEstimate
          : effectEstimate as List<EffectEvidenceSynthesisEffectEstimate>,
      certainty: certainty == freezed
          ? _value.certainty
          : certainty as List<EffectEvidenceSynthesisCertainty>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get synthesisType {
    if (_value.synthesisType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.synthesisType, (value) {
      return _then(_value.copyWith(synthesisType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get studyType {
    if (_value.studyType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.studyType, (value) {
      return _then(_value.copyWith(studyType: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get population {
    if (_value.population == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.population, (value) {
      return _then(_value.copyWith(population: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposure {
    if (_value.exposure == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposure, (value) {
      return _then(_value.copyWith(exposure: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposureAlternative {
    if (_value.exposureAlternative == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposureAlternative, (value) {
      return _then(_value.copyWith(exposureAlternative: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get outcome {
    if (_value.outcome == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.outcome, (value) {
      return _then(_value.copyWith(outcome: value));
    });
  }

  @override
  $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize {
    if (_value.sampleSize == null) {
      return null;
    }
    return $EffectEvidenceSynthesisSampleSizeCopyWith<$Res>(_value.sampleSize,
        (value) {
      return _then(_value.copyWith(sampleSize: value));
    });
  }
}

abstract class _$EffectEvidenceSynthesisCopyWith<$Res>
    implements $EffectEvidenceSynthesisCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisCopyWith(_EffectEvidenceSynthesis value,
          $Res Function(_EffectEvidenceSynthesis) then) =
      __$EffectEvidenceSynthesisCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
          EffectEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @JsonKey(required: true)
          Reference population,
      @JsonKey(required: true)
          Reference exposure,
      @JsonKey(required: true)
          Reference exposureAlternative,
      @JsonKey(required: true)
          Reference outcome,
      EffectEvidenceSynthesisSampleSize sampleSize,
      List<EffectEvidenceSynthesisResultsByExposure> resultsByExposure,
      List<EffectEvidenceSynthesisEffectEstimate> effectEstimate,
      List<EffectEvidenceSynthesisCertainty> certainty});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $CodeableConceptCopyWith<$Res> get synthesisType;
  @override
  $CodeableConceptCopyWith<$Res> get studyType;
  @override
  $ReferenceCopyWith<$Res> get population;
  @override
  $ReferenceCopyWith<$Res> get exposure;
  @override
  $ReferenceCopyWith<$Res> get exposureAlternative;
  @override
  $ReferenceCopyWith<$Res> get outcome;
  @override
  $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize;
}

class __$EffectEvidenceSynthesisCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisCopyWith<$Res> {
  __$EffectEvidenceSynthesisCopyWithImpl(_EffectEvidenceSynthesis _value,
      $Res Function(_EffectEvidenceSynthesis) _then)
      : super(_value, (v) => _then(v as _EffectEvidenceSynthesis));

  @override
  _EffectEvidenceSynthesis get _value =>
      super._value as _EffectEvidenceSynthesis;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object synthesisType = freezed,
    Object studyType = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object exposureAlternative = freezed,
    Object outcome = freezed,
    Object sampleSize = freezed,
    Object resultsByExposure = freezed,
    Object effectEstimate = freezed,
    Object certainty = freezed,
  }) {
    return _then(_EffectEvidenceSynthesis(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed
          ? _value.status
          : status as EffectEvidenceSynthesisStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      synthesisType: synthesisType == freezed
          ? _value.synthesisType
          : synthesisType as CodeableConcept,
      studyType: studyType == freezed
          ? _value.studyType
          : studyType as CodeableConcept,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      exposureAlternative: exposureAlternative == freezed
          ? _value.exposureAlternative
          : exposureAlternative as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
      sampleSize: sampleSize == freezed
          ? _value.sampleSize
          : sampleSize as EffectEvidenceSynthesisSampleSize,
      resultsByExposure: resultsByExposure == freezed
          ? _value.resultsByExposure
          : resultsByExposure as List<EffectEvidenceSynthesisResultsByExposure>,
      effectEstimate: effectEstimate == freezed
          ? _value.effectEstimate
          : effectEstimate as List<EffectEvidenceSynthesisEffectEstimate>,
      certainty: certainty == freezed
          ? _value.certainty
          : certainty as List<EffectEvidenceSynthesisCertainty>,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesis implements _EffectEvidenceSynthesis {
  const _$_EffectEvidenceSynthesis(
      {@required
      @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
          this.status,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.note,
      this.useContext,
      this.jurisdiction,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.synthesisType,
      this.studyType,
      @required
      @JsonKey(required: true)
          this.population,
      @required
      @JsonKey(required: true)
          this.exposure,
      @required
      @JsonKey(required: true)
          this.exposureAlternative,
      @required
      @JsonKey(required: true)
          this.outcome,
      this.sampleSize,
      this.resultsByExposure,
      this.effectEstimate,
      this.certainty})
      : assert(resourceType != null),
        assert(population != null),
        assert(exposure != null),
        assert(exposureAlternative != null),
        assert(outcome != null);

  factory _$_EffectEvidenceSynthesis.fromJson(Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
  final EffectEvidenceSynthesisStatus status;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<Annotation> note;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final CodeableConcept synthesisType;
  @override
  final CodeableConcept studyType;
  @override
  @JsonKey(required: true)
  final Reference population;
  @override
  @JsonKey(required: true)
  final Reference exposure;
  @override
  @JsonKey(required: true)
  final Reference exposureAlternative;
  @override
  @JsonKey(required: true)
  final Reference outcome;
  @override
  final EffectEvidenceSynthesisSampleSize sampleSize;
  @override
  final List<EffectEvidenceSynthesisResultsByExposure> resultsByExposure;
  @override
  final List<EffectEvidenceSynthesisEffectEstimate> effectEstimate;
  @override
  final List<EffectEvidenceSynthesisCertainty> certainty;

  @override
  String toString() {
    return 'EffectEvidenceSynthesis(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, status: $status, date: $date, publisher: $publisher, contact: $contact, description: $description, note: $note, useContext: $useContext, jurisdiction: $jurisdiction, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, synthesisType: $synthesisType, studyType: $studyType, population: $population, exposure: $exposure, exposureAlternative: $exposureAlternative, outcome: $outcome, sampleSize: $sampleSize, resultsByExposure: $resultsByExposure, effectEstimate: $effectEstimate, certainty: $certainty)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesis &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality()
                    .equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) ||
                const DeepCollectionEquality()
                    .equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.synthesisType, synthesisType) || const DeepCollectionEquality().equals(other.synthesisType, synthesisType)) &&
            (identical(other.studyType, studyType) || const DeepCollectionEquality().equals(other.studyType, studyType)) &&
            (identical(other.population, population) || const DeepCollectionEquality().equals(other.population, population)) &&
            (identical(other.exposure, exposure) || const DeepCollectionEquality().equals(other.exposure, exposure)) &&
            (identical(other.exposureAlternative, exposureAlternative) || const DeepCollectionEquality().equals(other.exposureAlternative, exposureAlternative)) &&
            (identical(other.outcome, outcome) || const DeepCollectionEquality().equals(other.outcome, outcome)) &&
            (identical(other.sampleSize, sampleSize) || const DeepCollectionEquality().equals(other.sampleSize, sampleSize)) &&
            (identical(other.resultsByExposure, resultsByExposure) || const DeepCollectionEquality().equals(other.resultsByExposure, resultsByExposure)) &&
            (identical(other.effectEstimate, effectEstimate) || const DeepCollectionEquality().equals(other.effectEstimate, effectEstimate)) &&
            (identical(other.certainty, certainty) || const DeepCollectionEquality().equals(other.certainty, certainty)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(synthesisType) ^
      const DeepCollectionEquality().hash(studyType) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(exposure) ^
      const DeepCollectionEquality().hash(exposureAlternative) ^
      const DeepCollectionEquality().hash(outcome) ^
      const DeepCollectionEquality().hash(sampleSize) ^
      const DeepCollectionEquality().hash(resultsByExposure) ^
      const DeepCollectionEquality().hash(effectEstimate) ^
      const DeepCollectionEquality().hash(certainty);

  @override
  _$EffectEvidenceSynthesisCopyWith<_EffectEvidenceSynthesis> get copyWith =>
      __$EffectEvidenceSynthesisCopyWithImpl<_EffectEvidenceSynthesis>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisToJson(this);
  }
}

abstract class _EffectEvidenceSynthesis implements EffectEvidenceSynthesis {
  const factory _EffectEvidenceSynthesis(
          {@required
          @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          FhirUri url,
          List<Identifier> identifier,
          String version,
          String name,
          String title,
          @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
              EffectEvidenceSynthesisStatus status,
          FhirDateTime date,
          String publisher,
          List<ContactDetail> contact,
          Markdown description,
          List<Annotation> note,
          List<UsageContext> useContext,
          List<CodeableConcept> jurisdiction,
          Markdown copyright,
          Date approvalDate,
          Date lastReviewDate,
          Period effectivePeriod,
          List<CodeableConcept> topic,
          List<ContactDetail> author,
          List<ContactDetail> editor,
          List<ContactDetail> reviewer,
          List<ContactDetail> endorser,
          List<RelatedArtifact> relatedArtifact,
          CodeableConcept synthesisType,
          CodeableConcept studyType,
          @required
          @JsonKey(required: true)
              Reference population,
          @required
          @JsonKey(required: true)
              Reference exposure,
          @required
          @JsonKey(required: true)
              Reference exposureAlternative,
          @required
          @JsonKey(required: true)
              Reference outcome,
          EffectEvidenceSynthesisSampleSize sampleSize,
          List<EffectEvidenceSynthesisResultsByExposure> resultsByExposure,
          List<EffectEvidenceSynthesisEffectEstimate> effectEstimate,
          List<EffectEvidenceSynthesisCertainty> certainty}) =
      _$_EffectEvidenceSynthesis;

  factory _EffectEvidenceSynthesis.fromJson(Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesis.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'EffectEvidenceSynthesis')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  @JsonKey(unknownEnumValue: EffectEvidenceSynthesisStatus.unknown)
  EffectEvidenceSynthesisStatus get status;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<Annotation> get note;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  CodeableConcept get synthesisType;
  @override
  CodeableConcept get studyType;
  @override
  @JsonKey(required: true)
  Reference get population;
  @override
  @JsonKey(required: true)
  Reference get exposure;
  @override
  @JsonKey(required: true)
  Reference get exposureAlternative;
  @override
  @JsonKey(required: true)
  Reference get outcome;
  @override
  EffectEvidenceSynthesisSampleSize get sampleSize;
  @override
  List<EffectEvidenceSynthesisResultsByExposure> get resultsByExposure;
  @override
  List<EffectEvidenceSynthesisEffectEstimate> get effectEstimate;
  @override
  List<EffectEvidenceSynthesisCertainty> get certainty;
  @override
  _$EffectEvidenceSynthesisCopyWith<_EffectEvidenceSynthesis> get copyWith;
}

EffectEvidenceSynthesisSampleSize _$EffectEvidenceSynthesisSampleSizeFromJson(
    Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisSampleSize.fromJson(json);
}

class _$EffectEvidenceSynthesisSampleSizeTearOff {
  const _$EffectEvidenceSynthesisSampleSizeTearOff();

  _EffectEvidenceSynthesisSampleSize call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants}) {
    return _EffectEvidenceSynthesisSampleSize(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      numberOfStudies: numberOfStudies,
      numberOfParticipants: numberOfParticipants,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisSampleSize =
    _$EffectEvidenceSynthesisSampleSizeTearOff();

mixin _$EffectEvidenceSynthesisSampleSize {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  Integer get numberOfStudies;
  Integer get numberOfParticipants;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisSampleSizeCopyWith<EffectEvidenceSynthesisSampleSize>
      get copyWith;
}

abstract class $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> {
  factory $EffectEvidenceSynthesisSampleSizeCopyWith(
          EffectEvidenceSynthesisSampleSize value,
          $Res Function(EffectEvidenceSynthesisSampleSize) then) =
      _$EffectEvidenceSynthesisSampleSizeCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants});
}

class _$EffectEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> {
  _$EffectEvidenceSynthesisSampleSizeCopyWithImpl(this._value, this._then);

  final EffectEvidenceSynthesisSampleSize _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisSampleSize) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object numberOfStudies = freezed,
    Object numberOfParticipants = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      numberOfStudies: numberOfStudies == freezed
          ? _value.numberOfStudies
          : numberOfStudies as Integer,
      numberOfParticipants: numberOfParticipants == freezed
          ? _value.numberOfParticipants
          : numberOfParticipants as Integer,
    ));
  }
}

abstract class _$EffectEvidenceSynthesisSampleSizeCopyWith<$Res>
    implements $EffectEvidenceSynthesisSampleSizeCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisSampleSizeCopyWith(
          _EffectEvidenceSynthesisSampleSize value,
          $Res Function(_EffectEvidenceSynthesisSampleSize) then) =
      __$EffectEvidenceSynthesisSampleSizeCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants});
}

class __$EffectEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisSampleSizeCopyWith<$Res> {
  __$EffectEvidenceSynthesisSampleSizeCopyWithImpl(
      _EffectEvidenceSynthesisSampleSize _value,
      $Res Function(_EffectEvidenceSynthesisSampleSize) _then)
      : super(_value, (v) => _then(v as _EffectEvidenceSynthesisSampleSize));

  @override
  _EffectEvidenceSynthesisSampleSize get _value =>
      super._value as _EffectEvidenceSynthesisSampleSize;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object numberOfStudies = freezed,
    Object numberOfParticipants = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisSampleSize(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      numberOfStudies: numberOfStudies == freezed
          ? _value.numberOfStudies
          : numberOfStudies as Integer,
      numberOfParticipants: numberOfParticipants == freezed
          ? _value.numberOfParticipants
          : numberOfParticipants as Integer,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisSampleSize
    implements _EffectEvidenceSynthesisSampleSize {
  const _$_EffectEvidenceSynthesisSampleSize(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.description,
      this.numberOfStudies,
      this.numberOfParticipants});

  factory _$_EffectEvidenceSynthesisSampleSize.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisSampleSizeFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  final Integer numberOfStudies;
  @override
  final Integer numberOfParticipants;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisSampleSize(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, numberOfStudies: $numberOfStudies, numberOfParticipants: $numberOfParticipants)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisSampleSize &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.numberOfStudies, numberOfStudies) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfStudies, numberOfStudies)) &&
            (identical(other.numberOfParticipants, numberOfParticipants) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfParticipants, numberOfParticipants)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(numberOfStudies) ^
      const DeepCollectionEquality().hash(numberOfParticipants);

  @override
  _$EffectEvidenceSynthesisSampleSizeCopyWith<
          _EffectEvidenceSynthesisSampleSize>
      get copyWith => __$EffectEvidenceSynthesisSampleSizeCopyWithImpl<
          _EffectEvidenceSynthesisSampleSize>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisSampleSizeToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisSampleSize
    implements EffectEvidenceSynthesisSampleSize {
  const factory _EffectEvidenceSynthesisSampleSize(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants}) = _$_EffectEvidenceSynthesisSampleSize;

  factory _EffectEvidenceSynthesisSampleSize.fromJson(
          Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesisSampleSize.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  Integer get numberOfStudies;
  @override
  Integer get numberOfParticipants;
  @override
  _$EffectEvidenceSynthesisSampleSizeCopyWith<
      _EffectEvidenceSynthesisSampleSize> get copyWith;
}

EffectEvidenceSynthesisResultsByExposure
    _$EffectEvidenceSynthesisResultsByExposureFromJson(
        Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisResultsByExposure.fromJson(json);
}

class _$EffectEvidenceSynthesisResultsByExposureTearOff {
  const _$EffectEvidenceSynthesisResultsByExposureTearOff();

  _EffectEvidenceSynthesisResultsByExposure call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
          ResultsByExposureExposureState exposureState,
      CodeableConcept variantState,
      @required
      @JsonKey(required: true)
          Reference riskEvidenceSynthesis}) {
    return _EffectEvidenceSynthesisResultsByExposure(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      exposureState: exposureState,
      variantState: variantState,
      riskEvidenceSynthesis: riskEvidenceSynthesis,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisResultsByExposure =
    _$EffectEvidenceSynthesisResultsByExposureTearOff();

mixin _$EffectEvidenceSynthesisResultsByExposure {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
  ResultsByExposureExposureState get exposureState;
  CodeableConcept get variantState;
  @JsonKey(required: true)
  Reference get riskEvidenceSynthesis;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisResultsByExposureCopyWith<
      EffectEvidenceSynthesisResultsByExposure> get copyWith;
}

abstract class $EffectEvidenceSynthesisResultsByExposureCopyWith<$Res> {
  factory $EffectEvidenceSynthesisResultsByExposureCopyWith(
          EffectEvidenceSynthesisResultsByExposure value,
          $Res Function(EffectEvidenceSynthesisResultsByExposure) then) =
      _$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
          ResultsByExposureExposureState exposureState,
      CodeableConcept variantState,
      @JsonKey(required: true)
          Reference riskEvidenceSynthesis});

  $CodeableConceptCopyWith<$Res> get variantState;
  $ReferenceCopyWith<$Res> get riskEvidenceSynthesis;
}

class _$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisResultsByExposureCopyWith<$Res> {
  _$EffectEvidenceSynthesisResultsByExposureCopyWithImpl(
      this._value, this._then);

  final EffectEvidenceSynthesisResultsByExposure _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisResultsByExposure) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object exposureState = freezed,
    Object variantState = freezed,
    Object riskEvidenceSynthesis = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      exposureState: exposureState == freezed
          ? _value.exposureState
          : exposureState as ResultsByExposureExposureState,
      variantState: variantState == freezed
          ? _value.variantState
          : variantState as CodeableConcept,
      riskEvidenceSynthesis: riskEvidenceSynthesis == freezed
          ? _value.riskEvidenceSynthesis
          : riskEvidenceSynthesis as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get variantState {
    if (_value.variantState == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.variantState, (value) {
      return _then(_value.copyWith(variantState: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get riskEvidenceSynthesis {
    if (_value.riskEvidenceSynthesis == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.riskEvidenceSynthesis, (value) {
      return _then(_value.copyWith(riskEvidenceSynthesis: value));
    });
  }
}

abstract class _$EffectEvidenceSynthesisResultsByExposureCopyWith<$Res>
    implements $EffectEvidenceSynthesisResultsByExposureCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisResultsByExposureCopyWith(
          _EffectEvidenceSynthesisResultsByExposure value,
          $Res Function(_EffectEvidenceSynthesisResultsByExposure) then) =
      __$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
          ResultsByExposureExposureState exposureState,
      CodeableConcept variantState,
      @JsonKey(required: true)
          Reference riskEvidenceSynthesis});

  @override
  $CodeableConceptCopyWith<$Res> get variantState;
  @override
  $ReferenceCopyWith<$Res> get riskEvidenceSynthesis;
}

class __$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisResultsByExposureCopyWith<$Res> {
  __$EffectEvidenceSynthesisResultsByExposureCopyWithImpl(
      _EffectEvidenceSynthesisResultsByExposure _value,
      $Res Function(_EffectEvidenceSynthesisResultsByExposure) _then)
      : super(_value,
            (v) => _then(v as _EffectEvidenceSynthesisResultsByExposure));

  @override
  _EffectEvidenceSynthesisResultsByExposure get _value =>
      super._value as _EffectEvidenceSynthesisResultsByExposure;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object exposureState = freezed,
    Object variantState = freezed,
    Object riskEvidenceSynthesis = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisResultsByExposure(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      exposureState: exposureState == freezed
          ? _value.exposureState
          : exposureState as ResultsByExposureExposureState,
      variantState: variantState == freezed
          ? _value.variantState
          : variantState as CodeableConcept,
      riskEvidenceSynthesis: riskEvidenceSynthesis == freezed
          ? _value.riskEvidenceSynthesis
          : riskEvidenceSynthesis as Reference,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisResultsByExposure
    implements _EffectEvidenceSynthesisResultsByExposure {
  const _$_EffectEvidenceSynthesisResultsByExposure(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.description,
      @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
          this.exposureState,
      this.variantState,
      @required
      @JsonKey(required: true)
          this.riskEvidenceSynthesis})
      : assert(riskEvidenceSynthesis != null);

  factory _$_EffectEvidenceSynthesisResultsByExposure.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisResultsByExposureFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
  final ResultsByExposureExposureState exposureState;
  @override
  final CodeableConcept variantState;
  @override
  @JsonKey(required: true)
  final Reference riskEvidenceSynthesis;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisResultsByExposure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, exposureState: $exposureState, variantState: $variantState, riskEvidenceSynthesis: $riskEvidenceSynthesis)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisResultsByExposure &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.exposureState, exposureState) ||
                const DeepCollectionEquality()
                    .equals(other.exposureState, exposureState)) &&
            (identical(other.variantState, variantState) ||
                const DeepCollectionEquality()
                    .equals(other.variantState, variantState)) &&
            (identical(other.riskEvidenceSynthesis, riskEvidenceSynthesis) ||
                const DeepCollectionEquality().equals(
                    other.riskEvidenceSynthesis, riskEvidenceSynthesis)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(exposureState) ^
      const DeepCollectionEquality().hash(variantState) ^
      const DeepCollectionEquality().hash(riskEvidenceSynthesis);

  @override
  _$EffectEvidenceSynthesisResultsByExposureCopyWith<
          _EffectEvidenceSynthesisResultsByExposure>
      get copyWith => __$EffectEvidenceSynthesisResultsByExposureCopyWithImpl<
          _EffectEvidenceSynthesisResultsByExposure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisResultsByExposureToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisResultsByExposure
    implements EffectEvidenceSynthesisResultsByExposure {
  const factory _EffectEvidenceSynthesisResultsByExposure(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String description,
          @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
              ResultsByExposureExposureState exposureState,
          CodeableConcept variantState,
          @required
          @JsonKey(required: true)
              Reference riskEvidenceSynthesis}) =
      _$_EffectEvidenceSynthesisResultsByExposure;

  factory _EffectEvidenceSynthesisResultsByExposure.fromJson(
          Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesisResultsByExposure.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  @JsonKey(unknownEnumValue: ResultsByExposureExposureState.unknown)
  ResultsByExposureExposureState get exposureState;
  @override
  CodeableConcept get variantState;
  @override
  @JsonKey(required: true)
  Reference get riskEvidenceSynthesis;
  @override
  _$EffectEvidenceSynthesisResultsByExposureCopyWith<
      _EffectEvidenceSynthesisResultsByExposure> get copyWith;
}

EffectEvidenceSynthesisEffectEstimate
    _$EffectEvidenceSynthesisEffectEstimateFromJson(Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisEffectEstimate.fromJson(json);
}

class _$EffectEvidenceSynthesisEffectEstimateTearOff {
  const _$EffectEvidenceSynthesisEffectEstimateTearOff();

  _EffectEvidenceSynthesisEffectEstimate call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      CodeableConcept variantState,
      Decimal value,
      CodeableConcept unitOfMeasure,
      List<EffectEvidenceSynthesisPrecisionEstimate> precisionEstimate}) {
    return _EffectEvidenceSynthesisEffectEstimate(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      type: type,
      variantState: variantState,
      value: value,
      unitOfMeasure: unitOfMeasure,
      precisionEstimate: precisionEstimate,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisEffectEstimate =
    _$EffectEvidenceSynthesisEffectEstimateTearOff();

mixin _$EffectEvidenceSynthesisEffectEstimate {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  CodeableConcept get type;
  CodeableConcept get variantState;
  Decimal get value;
  CodeableConcept get unitOfMeasure;
  List<EffectEvidenceSynthesisPrecisionEstimate> get precisionEstimate;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisEffectEstimateCopyWith<
      EffectEvidenceSynthesisEffectEstimate> get copyWith;
}

abstract class $EffectEvidenceSynthesisEffectEstimateCopyWith<$Res> {
  factory $EffectEvidenceSynthesisEffectEstimateCopyWith(
          EffectEvidenceSynthesisEffectEstimate value,
          $Res Function(EffectEvidenceSynthesisEffectEstimate) then) =
      _$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      CodeableConcept variantState,
      Decimal value,
      CodeableConcept unitOfMeasure,
      List<EffectEvidenceSynthesisPrecisionEstimate> precisionEstimate});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get variantState;
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
}

class _$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisEffectEstimateCopyWith<$Res> {
  _$EffectEvidenceSynthesisEffectEstimateCopyWithImpl(this._value, this._then);

  final EffectEvidenceSynthesisEffectEstimate _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisEffectEstimate) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object type = freezed,
    Object variantState = freezed,
    Object value = freezed,
    Object unitOfMeasure = freezed,
    Object precisionEstimate = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      variantState: variantState == freezed
          ? _value.variantState
          : variantState as CodeableConcept,
      value: value == freezed ? _value.value : value as Decimal,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      precisionEstimate: precisionEstimate == freezed
          ? _value.precisionEstimate
          : precisionEstimate as List<EffectEvidenceSynthesisPrecisionEstimate>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get variantState {
    if (_value.variantState == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.variantState, (value) {
      return _then(_value.copyWith(variantState: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure {
    if (_value.unitOfMeasure == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unitOfMeasure, (value) {
      return _then(_value.copyWith(unitOfMeasure: value));
    });
  }
}

abstract class _$EffectEvidenceSynthesisEffectEstimateCopyWith<$Res>
    implements $EffectEvidenceSynthesisEffectEstimateCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisEffectEstimateCopyWith(
          _EffectEvidenceSynthesisEffectEstimate value,
          $Res Function(_EffectEvidenceSynthesisEffectEstimate) then) =
      __$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      CodeableConcept variantState,
      Decimal value,
      CodeableConcept unitOfMeasure,
      List<EffectEvidenceSynthesisPrecisionEstimate> precisionEstimate});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get variantState;
  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
}

class __$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisEffectEstimateCopyWith<$Res> {
  __$EffectEvidenceSynthesisEffectEstimateCopyWithImpl(
      _EffectEvidenceSynthesisEffectEstimate _value,
      $Res Function(_EffectEvidenceSynthesisEffectEstimate) _then)
      : super(
            _value, (v) => _then(v as _EffectEvidenceSynthesisEffectEstimate));

  @override
  _EffectEvidenceSynthesisEffectEstimate get _value =>
      super._value as _EffectEvidenceSynthesisEffectEstimate;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object type = freezed,
    Object variantState = freezed,
    Object value = freezed,
    Object unitOfMeasure = freezed,
    Object precisionEstimate = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisEffectEstimate(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      variantState: variantState == freezed
          ? _value.variantState
          : variantState as CodeableConcept,
      value: value == freezed ? _value.value : value as Decimal,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      precisionEstimate: precisionEstimate == freezed
          ? _value.precisionEstimate
          : precisionEstimate as List<EffectEvidenceSynthesisPrecisionEstimate>,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisEffectEstimate
    implements _EffectEvidenceSynthesisEffectEstimate {
  const _$_EffectEvidenceSynthesisEffectEstimate(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.description,
      this.type,
      this.variantState,
      this.value,
      this.unitOfMeasure,
      this.precisionEstimate});

  factory _$_EffectEvidenceSynthesisEffectEstimate.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisEffectEstimateFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept variantState;
  @override
  final Decimal value;
  @override
  final CodeableConcept unitOfMeasure;
  @override
  final List<EffectEvidenceSynthesisPrecisionEstimate> precisionEstimate;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisEffectEstimate(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, type: $type, variantState: $variantState, value: $value, unitOfMeasure: $unitOfMeasure, precisionEstimate: $precisionEstimate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisEffectEstimate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.variantState, variantState) ||
                const DeepCollectionEquality()
                    .equals(other.variantState, variantState)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.unitOfMeasure, unitOfMeasure) ||
                const DeepCollectionEquality()
                    .equals(other.unitOfMeasure, unitOfMeasure)) &&
            (identical(other.precisionEstimate, precisionEstimate) ||
                const DeepCollectionEquality()
                    .equals(other.precisionEstimate, precisionEstimate)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(variantState) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(unitOfMeasure) ^
      const DeepCollectionEquality().hash(precisionEstimate);

  @override
  _$EffectEvidenceSynthesisEffectEstimateCopyWith<
          _EffectEvidenceSynthesisEffectEstimate>
      get copyWith => __$EffectEvidenceSynthesisEffectEstimateCopyWithImpl<
          _EffectEvidenceSynthesisEffectEstimate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisEffectEstimateToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisEffectEstimate
    implements EffectEvidenceSynthesisEffectEstimate {
  const factory _EffectEvidenceSynthesisEffectEstimate(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String description,
          CodeableConcept type,
          CodeableConcept variantState,
          Decimal value,
          CodeableConcept unitOfMeasure,
          List<EffectEvidenceSynthesisPrecisionEstimate> precisionEstimate}) =
      _$_EffectEvidenceSynthesisEffectEstimate;

  factory _EffectEvidenceSynthesisEffectEstimate.fromJson(
          Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesisEffectEstimate.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get variantState;
  @override
  Decimal get value;
  @override
  CodeableConcept get unitOfMeasure;
  @override
  List<EffectEvidenceSynthesisPrecisionEstimate> get precisionEstimate;
  @override
  _$EffectEvidenceSynthesisEffectEstimateCopyWith<
      _EffectEvidenceSynthesisEffectEstimate> get copyWith;
}

EffectEvidenceSynthesisPrecisionEstimate
    _$EffectEvidenceSynthesisPrecisionEstimateFromJson(
        Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisPrecisionEstimate.fromJson(json);
}

class _$EffectEvidenceSynthesisPrecisionEstimateTearOff {
  const _$EffectEvidenceSynthesisPrecisionEstimateTearOff();

  _EffectEvidenceSynthesisPrecisionEstimate call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to}) {
    return _EffectEvidenceSynthesisPrecisionEstimate(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      level: level,
      from: from,
      to: to,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisPrecisionEstimate =
    _$EffectEvidenceSynthesisPrecisionEstimateTearOff();

mixin _$EffectEvidenceSynthesisPrecisionEstimate {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  Decimal get level;
  Decimal get from;
  Decimal get to;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisPrecisionEstimateCopyWith<
      EffectEvidenceSynthesisPrecisionEstimate> get copyWith;
}

abstract class $EffectEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  factory $EffectEvidenceSynthesisPrecisionEstimateCopyWith(
          EffectEvidenceSynthesisPrecisionEstimate value,
          $Res Function(EffectEvidenceSynthesisPrecisionEstimate) then) =
      _$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  _$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl(
      this._value, this._then);

  final EffectEvidenceSynthesisPrecisionEstimate _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisPrecisionEstimate) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object level = freezed,
    Object from = freezed,
    Object to = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      level: level == freezed ? _value.level : level as Decimal,
      from: from == freezed ? _value.from : from as Decimal,
      to: to == freezed ? _value.to : to as Decimal,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$EffectEvidenceSynthesisPrecisionEstimateCopyWith<$Res>
    implements $EffectEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisPrecisionEstimateCopyWith(
          _EffectEvidenceSynthesisPrecisionEstimate value,
          $Res Function(_EffectEvidenceSynthesisPrecisionEstimate) then) =
      __$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  __$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl(
      _EffectEvidenceSynthesisPrecisionEstimate _value,
      $Res Function(_EffectEvidenceSynthesisPrecisionEstimate) _then)
      : super(_value,
            (v) => _then(v as _EffectEvidenceSynthesisPrecisionEstimate));

  @override
  _EffectEvidenceSynthesisPrecisionEstimate get _value =>
      super._value as _EffectEvidenceSynthesisPrecisionEstimate;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object level = freezed,
    Object from = freezed,
    Object to = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisPrecisionEstimate(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      level: level == freezed ? _value.level : level as Decimal,
      from: from == freezed ? _value.from : from as Decimal,
      to: to == freezed ? _value.to : to as Decimal,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisPrecisionEstimate
    implements _EffectEvidenceSynthesisPrecisionEstimate {
  const _$_EffectEvidenceSynthesisPrecisionEstimate(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.level,
      this.from,
      this.to});

  factory _$_EffectEvidenceSynthesisPrecisionEstimate.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisPrecisionEstimateFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final Decimal level;
  @override
  final Decimal from;
  @override
  final Decimal to;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisPrecisionEstimate(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, level: $level, from: $from, to: $to)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisPrecisionEstimate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to);

  @override
  _$EffectEvidenceSynthesisPrecisionEstimateCopyWith<
          _EffectEvidenceSynthesisPrecisionEstimate>
      get copyWith => __$EffectEvidenceSynthesisPrecisionEstimateCopyWithImpl<
          _EffectEvidenceSynthesisPrecisionEstimate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisPrecisionEstimateToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisPrecisionEstimate
    implements EffectEvidenceSynthesisPrecisionEstimate {
  const factory _EffectEvidenceSynthesisPrecisionEstimate(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to}) = _$_EffectEvidenceSynthesisPrecisionEstimate;

  factory _EffectEvidenceSynthesisPrecisionEstimate.fromJson(
          Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesisPrecisionEstimate.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  Decimal get level;
  @override
  Decimal get from;
  @override
  Decimal get to;
  @override
  _$EffectEvidenceSynthesisPrecisionEstimateCopyWith<
      _EffectEvidenceSynthesisPrecisionEstimate> get copyWith;
}

EffectEvidenceSynthesisCertainty _$EffectEvidenceSynthesisCertaintyFromJson(
    Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisCertainty.fromJson(json);
}

class _$EffectEvidenceSynthesisCertaintyTearOff {
  const _$EffectEvidenceSynthesisCertaintyTearOff();

  _EffectEvidenceSynthesisCertainty call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<EffectEvidenceSynthesisCertaintySubcomponent>
          certaintySubcomponent}) {
    return _EffectEvidenceSynthesisCertainty(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      rating: rating,
      note: note,
      certaintySubcomponent: certaintySubcomponent,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisCertainty =
    _$EffectEvidenceSynthesisCertaintyTearOff();

mixin _$EffectEvidenceSynthesisCertainty {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<CodeableConcept> get rating;
  List<Annotation> get note;
  List<EffectEvidenceSynthesisCertaintySubcomponent> get certaintySubcomponent;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisCertaintyCopyWith<EffectEvidenceSynthesisCertainty>
      get copyWith;
}

abstract class $EffectEvidenceSynthesisCertaintyCopyWith<$Res> {
  factory $EffectEvidenceSynthesisCertaintyCopyWith(
          EffectEvidenceSynthesisCertainty value,
          $Res Function(EffectEvidenceSynthesisCertainty) then) =
      _$EffectEvidenceSynthesisCertaintyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<EffectEvidenceSynthesisCertaintySubcomponent>
          certaintySubcomponent});
}

class _$EffectEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisCertaintyCopyWith<$Res> {
  _$EffectEvidenceSynthesisCertaintyCopyWithImpl(this._value, this._then);

  final EffectEvidenceSynthesisCertainty _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisCertainty) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object rating = freezed,
    Object note = freezed,
    Object certaintySubcomponent = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
      certaintySubcomponent: certaintySubcomponent == freezed
          ? _value.certaintySubcomponent
          : certaintySubcomponent
              as List<EffectEvidenceSynthesisCertaintySubcomponent>,
    ));
  }
}

abstract class _$EffectEvidenceSynthesisCertaintyCopyWith<$Res>
    implements $EffectEvidenceSynthesisCertaintyCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisCertaintyCopyWith(
          _EffectEvidenceSynthesisCertainty value,
          $Res Function(_EffectEvidenceSynthesisCertainty) then) =
      __$EffectEvidenceSynthesisCertaintyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<EffectEvidenceSynthesisCertaintySubcomponent>
          certaintySubcomponent});
}

class __$EffectEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisCertaintyCopyWith<$Res> {
  __$EffectEvidenceSynthesisCertaintyCopyWithImpl(
      _EffectEvidenceSynthesisCertainty _value,
      $Res Function(_EffectEvidenceSynthesisCertainty) _then)
      : super(_value, (v) => _then(v as _EffectEvidenceSynthesisCertainty));

  @override
  _EffectEvidenceSynthesisCertainty get _value =>
      super._value as _EffectEvidenceSynthesisCertainty;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object rating = freezed,
    Object note = freezed,
    Object certaintySubcomponent = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisCertainty(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
      certaintySubcomponent: certaintySubcomponent == freezed
          ? _value.certaintySubcomponent
          : certaintySubcomponent
              as List<EffectEvidenceSynthesisCertaintySubcomponent>,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisCertainty
    implements _EffectEvidenceSynthesisCertainty {
  const _$_EffectEvidenceSynthesisCertainty(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.rating,
      this.note,
      this.certaintySubcomponent});

  factory _$_EffectEvidenceSynthesisCertainty.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisCertaintyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<CodeableConcept> rating;
  @override
  final List<Annotation> note;
  @override
  final List<EffectEvidenceSynthesisCertaintySubcomponent>
      certaintySubcomponent;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisCertainty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, rating: $rating, note: $note, certaintySubcomponent: $certaintySubcomponent)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisCertainty &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.certaintySubcomponent, certaintySubcomponent) ||
                const DeepCollectionEquality().equals(
                    other.certaintySubcomponent, certaintySubcomponent)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(certaintySubcomponent);

  @override
  _$EffectEvidenceSynthesisCertaintyCopyWith<_EffectEvidenceSynthesisCertainty>
      get copyWith => __$EffectEvidenceSynthesisCertaintyCopyWithImpl<
          _EffectEvidenceSynthesisCertainty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisCertaintyToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisCertainty
    implements EffectEvidenceSynthesisCertainty {
  const factory _EffectEvidenceSynthesisCertainty(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<EffectEvidenceSynthesisCertaintySubcomponent>
          certaintySubcomponent}) = _$_EffectEvidenceSynthesisCertainty;

  factory _EffectEvidenceSynthesisCertainty.fromJson(
      Map<String, dynamic> json) = _$_EffectEvidenceSynthesisCertainty.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<CodeableConcept> get rating;
  @override
  List<Annotation> get note;
  @override
  List<EffectEvidenceSynthesisCertaintySubcomponent> get certaintySubcomponent;
  @override
  _$EffectEvidenceSynthesisCertaintyCopyWith<_EffectEvidenceSynthesisCertainty>
      get copyWith;
}

EffectEvidenceSynthesisCertaintySubcomponent
    _$EffectEvidenceSynthesisCertaintySubcomponentFromJson(
        Map<String, dynamic> json) {
  return _EffectEvidenceSynthesisCertaintySubcomponent.fromJson(json);
}

class _$EffectEvidenceSynthesisCertaintySubcomponentTearOff {
  const _$EffectEvidenceSynthesisCertaintySubcomponentTearOff();

  _EffectEvidenceSynthesisCertaintySubcomponent call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note}) {
    return _EffectEvidenceSynthesisCertaintySubcomponent(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      rating: rating,
      note: note,
    );
  }
}

// ignore: unused_element
const $EffectEvidenceSynthesisCertaintySubcomponent =
    _$EffectEvidenceSynthesisCertaintySubcomponentTearOff();

mixin _$EffectEvidenceSynthesisCertaintySubcomponent {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  List<CodeableConcept> get rating;
  List<Annotation> get note;

  Map<String, dynamic> toJson();
  $EffectEvidenceSynthesisCertaintySubcomponentCopyWith<
      EffectEvidenceSynthesisCertaintySubcomponent> get copyWith;
}

abstract class $EffectEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  factory $EffectEvidenceSynthesisCertaintySubcomponentCopyWith(
          EffectEvidenceSynthesisCertaintySubcomponent value,
          $Res Function(EffectEvidenceSynthesisCertaintySubcomponent) then) =
      _$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    implements $EffectEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  _$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl(
      this._value, this._then);

  final EffectEvidenceSynthesisCertaintySubcomponent _value;
  // ignore: unused_field
  final $Res Function(EffectEvidenceSynthesisCertaintySubcomponent) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object rating = freezed,
    Object note = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$EffectEvidenceSynthesisCertaintySubcomponentCopyWith<$Res>
    implements $EffectEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  factory _$EffectEvidenceSynthesisCertaintySubcomponentCopyWith(
          _EffectEvidenceSynthesisCertaintySubcomponent value,
          $Res Function(_EffectEvidenceSynthesisCertaintySubcomponent) then) =
      __$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    extends _$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    implements _$EffectEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  __$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl(
      _EffectEvidenceSynthesisCertaintySubcomponent _value,
      $Res Function(_EffectEvidenceSynthesisCertaintySubcomponent) _then)
      : super(_value,
            (v) => _then(v as _EffectEvidenceSynthesisCertaintySubcomponent));

  @override
  _EffectEvidenceSynthesisCertaintySubcomponent get _value =>
      super._value as _EffectEvidenceSynthesisCertaintySubcomponent;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object rating = freezed,
    Object note = freezed,
  }) {
    return _then(_EffectEvidenceSynthesisCertaintySubcomponent(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
    ));
  }
}

@JsonSerializable()
class _$_EffectEvidenceSynthesisCertaintySubcomponent
    implements _EffectEvidenceSynthesisCertaintySubcomponent {
  const _$_EffectEvidenceSynthesisCertaintySubcomponent(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.rating,
      this.note});

  factory _$_EffectEvidenceSynthesisCertaintySubcomponent.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EffectEvidenceSynthesisCertaintySubcomponentFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final List<CodeableConcept> rating;
  @override
  final List<Annotation> note;

  @override
  String toString() {
    return 'EffectEvidenceSynthesisCertaintySubcomponent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, rating: $rating, note: $note)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EffectEvidenceSynthesisCertaintySubcomponent &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(note);

  @override
  _$EffectEvidenceSynthesisCertaintySubcomponentCopyWith<
          _EffectEvidenceSynthesisCertaintySubcomponent>
      get copyWith =>
          __$EffectEvidenceSynthesisCertaintySubcomponentCopyWithImpl<
              _EffectEvidenceSynthesisCertaintySubcomponent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EffectEvidenceSynthesisCertaintySubcomponentToJson(this);
  }
}

abstract class _EffectEvidenceSynthesisCertaintySubcomponent
    implements EffectEvidenceSynthesisCertaintySubcomponent {
  const factory _EffectEvidenceSynthesisCertaintySubcomponent(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note}) = _$_EffectEvidenceSynthesisCertaintySubcomponent;

  factory _EffectEvidenceSynthesisCertaintySubcomponent.fromJson(
          Map<String, dynamic> json) =
      _$_EffectEvidenceSynthesisCertaintySubcomponent.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  List<CodeableConcept> get rating;
  @override
  List<Annotation> get note;
  @override
  _$EffectEvidenceSynthesisCertaintySubcomponentCopyWith<
      _EffectEvidenceSynthesisCertaintySubcomponent> get copyWith;
}

EventDefinition _$EventDefinitionFromJson(Map<String, dynamic> json) {
  return _EventDefinition.fromJson(json);
}

class _$EventDefinitionTearOff {
  const _$EventDefinitionTearOff();

  _EventDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'EventDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
          EventDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @required
      @JsonKey(required: true)
          List<TriggerDefinition> trigger}) {
    return _EventDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      subtitle: subtitle,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      trigger: trigger,
    );
  }
}

// ignore: unused_element
const $EventDefinition = _$EventDefinitionTearOff();

mixin _$EventDefinition {
  @JsonKey(required: true, defaultValue: 'EventDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get subtitle;
  @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
  EventDefinitionStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  @JsonKey(required: true)
  List<TriggerDefinition> get trigger;

  Map<String, dynamic> toJson();
  $EventDefinitionCopyWith<EventDefinition> get copyWith;
}

abstract class $EventDefinitionCopyWith<$Res> {
  factory $EventDefinitionCopyWith(
          EventDefinition value, $Res Function(EventDefinition) then) =
      _$EventDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EventDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
          EventDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(required: true)
          List<TriggerDefinition> trigger});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class _$EventDefinitionCopyWithImpl<$Res>
    implements $EventDefinitionCopyWith<$Res> {
  _$EventDefinitionCopyWithImpl(this._value, this._then);

  final EventDefinition _value;
  // ignore: unused_field
  final $Res Function(EventDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object trigger = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status:
          status == freezed ? _value.status : status as EventDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger as List<TriggerDefinition>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }
}

abstract class _$EventDefinitionCopyWith<$Res>
    implements $EventDefinitionCopyWith<$Res> {
  factory _$EventDefinitionCopyWith(
          _EventDefinition value, $Res Function(_EventDefinition) then) =
      __$EventDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EventDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
          EventDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(required: true)
          List<TriggerDefinition> trigger});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class __$EventDefinitionCopyWithImpl<$Res>
    extends _$EventDefinitionCopyWithImpl<$Res>
    implements _$EventDefinitionCopyWith<$Res> {
  __$EventDefinitionCopyWithImpl(
      _EventDefinition _value, $Res Function(_EventDefinition) _then)
      : super(_value, (v) => _then(v as _EventDefinition));

  @override
  _EventDefinition get _value => super._value as _EventDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object trigger = freezed,
  }) {
    return _then(_EventDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status:
          status == freezed ? _value.status : status as EventDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger as List<TriggerDefinition>,
    ));
  }
}

@JsonSerializable()
class _$_EventDefinition implements _EventDefinition {
  const _$_EventDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'EventDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.subtitle,
      @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      @required
      @JsonKey(required: true)
          this.trigger})
      : assert(resourceType != null),
        assert(trigger != null);

  factory _$_EventDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_EventDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'EventDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
  final EventDefinitionStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  @JsonKey(required: true)
  final List<TriggerDefinition> trigger;

  @override
  String toString() {
    return 'EventDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, subtitle: $subtitle, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, trigger: $trigger)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EventDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.trigger, trigger) || const DeepCollectionEquality().equals(other.trigger, trigger)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(trigger);

  @override
  _$EventDefinitionCopyWith<_EventDefinition> get copyWith =>
      __$EventDefinitionCopyWithImpl<_EventDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EventDefinitionToJson(this);
  }
}

abstract class _EventDefinition implements EventDefinition {
  const factory _EventDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'EventDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
          EventDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @required
      @JsonKey(required: true)
          List<TriggerDefinition> trigger}) = _$_EventDefinition;

  factory _EventDefinition.fromJson(Map<String, dynamic> json) =
      _$_EventDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'EventDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: EventDefinitionStatus.unknown)
  EventDefinitionStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  @JsonKey(required: true)
  List<TriggerDefinition> get trigger;
  @override
  _$EventDefinitionCopyWith<_EventDefinition> get copyWith;
}

Evidence _$EvidenceFromJson(Map<String, dynamic> json) {
  return _Evidence.fromJson(json);
}

class _$EvidenceTearOff {
  const _$EvidenceTearOff();

  _Evidence call(
      {@required
      @JsonKey(required: true, defaultValue: 'Evidence')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
          EvidenceStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @required
      @JsonKey(required: true)
          Reference exposureBackground,
      List<Reference> exposureVariant,
      List<Reference> outcome}) {
    return _Evidence(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      shortTitle: shortTitle,
      subtitle: subtitle,
      status: status,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      note: note,
      useContext: useContext,
      jurisdiction: jurisdiction,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      exposureBackground: exposureBackground,
      exposureVariant: exposureVariant,
      outcome: outcome,
    );
  }
}

// ignore: unused_element
const $Evidence = _$EvidenceTearOff();

mixin _$Evidence {
  @JsonKey(required: true, defaultValue: 'Evidence')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get shortTitle;
  String get subtitle;
  @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
  EvidenceStatus get status;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<Annotation> get note;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  @JsonKey(required: true)
  Reference get exposureBackground;
  List<Reference> get exposureVariant;
  List<Reference> get outcome;

  Map<String, dynamic> toJson();
  $EvidenceCopyWith<Evidence> get copyWith;
}

abstract class $EvidenceCopyWith<$Res> {
  factory $EvidenceCopyWith(Evidence value, $Res Function(Evidence) then) =
      _$EvidenceCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Evidence') String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceStatus.unknown) EvidenceStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(required: true) Reference exposureBackground,
      List<Reference> exposureVariant,
      List<Reference> outcome});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $ReferenceCopyWith<$Res> get exposureBackground;
}

class _$EvidenceCopyWithImpl<$Res> implements $EvidenceCopyWith<$Res> {
  _$EvidenceCopyWithImpl(this._value, this._then);

  final Evidence _value;
  // ignore: unused_field
  final $Res Function(Evidence) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object exposureBackground = freezed,
    Object exposureVariant = freezed,
    Object outcome = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed ? _value.status : status as EvidenceStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      exposureBackground: exposureBackground == freezed
          ? _value.exposureBackground
          : exposureBackground as Reference,
      exposureVariant: exposureVariant == freezed
          ? _value.exposureVariant
          : exposureVariant as List<Reference>,
      outcome: outcome == freezed ? _value.outcome : outcome as List<Reference>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposureBackground {
    if (_value.exposureBackground == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposureBackground, (value) {
      return _then(_value.copyWith(exposureBackground: value));
    });
  }
}

abstract class _$EvidenceCopyWith<$Res> implements $EvidenceCopyWith<$Res> {
  factory _$EvidenceCopyWith(_Evidence value, $Res Function(_Evidence) then) =
      __$EvidenceCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Evidence') String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceStatus.unknown) EvidenceStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(required: true) Reference exposureBackground,
      List<Reference> exposureVariant,
      List<Reference> outcome});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $ReferenceCopyWith<$Res> get exposureBackground;
}

class __$EvidenceCopyWithImpl<$Res> extends _$EvidenceCopyWithImpl<$Res>
    implements _$EvidenceCopyWith<$Res> {
  __$EvidenceCopyWithImpl(_Evidence _value, $Res Function(_Evidence) _then)
      : super(_value, (v) => _then(v as _Evidence));

  @override
  _Evidence get _value => super._value as _Evidence;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object exposureBackground = freezed,
    Object exposureVariant = freezed,
    Object outcome = freezed,
  }) {
    return _then(_Evidence(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed ? _value.status : status as EvidenceStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      exposureBackground: exposureBackground == freezed
          ? _value.exposureBackground
          : exposureBackground as Reference,
      exposureVariant: exposureVariant == freezed
          ? _value.exposureVariant
          : exposureVariant as List<Reference>,
      outcome: outcome == freezed ? _value.outcome : outcome as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_Evidence implements _Evidence {
  const _$_Evidence(
      {@required
      @JsonKey(required: true, defaultValue: 'Evidence')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.shortTitle,
      this.subtitle,
      @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
          this.status,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.note,
      this.useContext,
      this.jurisdiction,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      @required
      @JsonKey(required: true)
          this.exposureBackground,
      this.exposureVariant,
      this.outcome})
      : assert(resourceType != null),
        assert(exposureBackground != null);

  factory _$_Evidence.fromJson(Map<String, dynamic> json) =>
      _$_$_EvidenceFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'Evidence')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String shortTitle;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
  final EvidenceStatus status;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<Annotation> note;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  @JsonKey(required: true)
  final Reference exposureBackground;
  @override
  final List<Reference> exposureVariant;
  @override
  final List<Reference> outcome;

  @override
  String toString() {
    return 'Evidence(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, shortTitle: $shortTitle, subtitle: $subtitle, status: $status, date: $date, publisher: $publisher, contact: $contact, description: $description, note: $note, useContext: $useContext, jurisdiction: $jurisdiction, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, exposureBackground: $exposureBackground, exposureVariant: $exposureVariant, outcome: $outcome)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Evidence &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.shortTitle, shortTitle) ||
                const DeepCollectionEquality()
                    .equals(other.shortTitle, shortTitle)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality()
                    .equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) ||
                const DeepCollectionEquality()
                    .equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.exposureBackground, exposureBackground) || const DeepCollectionEquality().equals(other.exposureBackground, exposureBackground)) &&
            (identical(other.exposureVariant, exposureVariant) || const DeepCollectionEquality().equals(other.exposureVariant, exposureVariant)) &&
            (identical(other.outcome, outcome) || const DeepCollectionEquality().equals(other.outcome, outcome)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(shortTitle) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(exposureBackground) ^
      const DeepCollectionEquality().hash(exposureVariant) ^
      const DeepCollectionEquality().hash(outcome);

  @override
  _$EvidenceCopyWith<_Evidence> get copyWith =>
      __$EvidenceCopyWithImpl<_Evidence>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EvidenceToJson(this);
  }
}

abstract class _Evidence implements Evidence {
  const factory _Evidence(
      {@required
      @JsonKey(required: true, defaultValue: 'Evidence')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
          EvidenceStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @required
      @JsonKey(required: true)
          Reference exposureBackground,
      List<Reference> exposureVariant,
      List<Reference> outcome}) = _$_Evidence;

  factory _Evidence.fromJson(Map<String, dynamic> json) = _$_Evidence.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'Evidence')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get shortTitle;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: EvidenceStatus.unknown)
  EvidenceStatus get status;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<Annotation> get note;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  @JsonKey(required: true)
  Reference get exposureBackground;
  @override
  List<Reference> get exposureVariant;
  @override
  List<Reference> get outcome;
  @override
  _$EvidenceCopyWith<_Evidence> get copyWith;
}

EvidenceVariable _$EvidenceVariableFromJson(Map<String, dynamic> json) {
  return _EvidenceVariable.fromJson(json);
}

class _$EvidenceVariableTearOff {
  const _$EvidenceVariableTearOff();

  _EvidenceVariable call(
      {@required
      @JsonKey(required: true, defaultValue: 'EvidenceVariable')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
          EvidenceVariableStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
          EvidenceVariableType type,
      @required
      @JsonKey(required: true)
          List<EvidenceVariableCharacteristic> characteristic}) {
    return _EvidenceVariable(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      shortTitle: shortTitle,
      subtitle: subtitle,
      status: status,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      note: note,
      useContext: useContext,
      jurisdiction: jurisdiction,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      type: type,
      characteristic: characteristic,
    );
  }
}

// ignore: unused_element
const $EvidenceVariable = _$EvidenceVariableTearOff();

mixin _$EvidenceVariable {
  @JsonKey(required: true, defaultValue: 'EvidenceVariable')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get shortTitle;
  String get subtitle;
  @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
  EvidenceVariableStatus get status;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<Annotation> get note;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
  EvidenceVariableType get type;
  @JsonKey(required: true)
  List<EvidenceVariableCharacteristic> get characteristic;

  Map<String, dynamic> toJson();
  $EvidenceVariableCopyWith<EvidenceVariable> get copyWith;
}

abstract class $EvidenceVariableCopyWith<$Res> {
  factory $EvidenceVariableCopyWith(
          EvidenceVariable value, $Res Function(EvidenceVariable) then) =
      _$EvidenceVariableCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EvidenceVariable')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
          EvidenceVariableStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
          EvidenceVariableType type,
      @JsonKey(required: true)
          List<EvidenceVariableCharacteristic> characteristic});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class _$EvidenceVariableCopyWithImpl<$Res>
    implements $EvidenceVariableCopyWith<$Res> {
  _$EvidenceVariableCopyWithImpl(this._value, this._then);

  final EvidenceVariable _value;
  // ignore: unused_field
  final $Res Function(EvidenceVariable) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object type = freezed,
    Object characteristic = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status:
          status == freezed ? _value.status : status as EvidenceVariableStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      type: type == freezed ? _value.type : type as EvidenceVariableType,
      characteristic: characteristic == freezed
          ? _value.characteristic
          : characteristic as List<EvidenceVariableCharacteristic>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }
}

abstract class _$EvidenceVariableCopyWith<$Res>
    implements $EvidenceVariableCopyWith<$Res> {
  factory _$EvidenceVariableCopyWith(
          _EvidenceVariable value, $Res Function(_EvidenceVariable) then) =
      __$EvidenceVariableCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'EvidenceVariable')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
          EvidenceVariableStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
          EvidenceVariableType type,
      @JsonKey(required: true)
          List<EvidenceVariableCharacteristic> characteristic});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class __$EvidenceVariableCopyWithImpl<$Res>
    extends _$EvidenceVariableCopyWithImpl<$Res>
    implements _$EvidenceVariableCopyWith<$Res> {
  __$EvidenceVariableCopyWithImpl(
      _EvidenceVariable _value, $Res Function(_EvidenceVariable) _then)
      : super(_value, (v) => _then(v as _EvidenceVariable));

  @override
  _EvidenceVariable get _value => super._value as _EvidenceVariable;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object type = freezed,
    Object characteristic = freezed,
  }) {
    return _then(_EvidenceVariable(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status:
          status == freezed ? _value.status : status as EvidenceVariableStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      type: type == freezed ? _value.type : type as EvidenceVariableType,
      characteristic: characteristic == freezed
          ? _value.characteristic
          : characteristic as List<EvidenceVariableCharacteristic>,
    ));
  }
}

@JsonSerializable()
class _$_EvidenceVariable implements _EvidenceVariable {
  const _$_EvidenceVariable(
      {@required
      @JsonKey(required: true, defaultValue: 'EvidenceVariable')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.shortTitle,
      this.subtitle,
      @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
          this.status,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.note,
      this.useContext,
      this.jurisdiction,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
          this.type,
      @required
      @JsonKey(required: true)
          this.characteristic})
      : assert(resourceType != null),
        assert(characteristic != null);

  factory _$_EvidenceVariable.fromJson(Map<String, dynamic> json) =>
      _$_$_EvidenceVariableFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'EvidenceVariable')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String shortTitle;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
  final EvidenceVariableStatus status;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<Annotation> note;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
  final EvidenceVariableType type;
  @override
  @JsonKey(required: true)
  final List<EvidenceVariableCharacteristic> characteristic;

  @override
  String toString() {
    return 'EvidenceVariable(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, shortTitle: $shortTitle, subtitle: $subtitle, status: $status, date: $date, publisher: $publisher, contact: $contact, description: $description, note: $note, useContext: $useContext, jurisdiction: $jurisdiction, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, type: $type, characteristic: $characteristic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EvidenceVariable &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.shortTitle, shortTitle) ||
                const DeepCollectionEquality()
                    .equals(other.shortTitle, shortTitle)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality()
                    .equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) ||
                const DeepCollectionEquality()
                    .equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.characteristic, characteristic) || const DeepCollectionEquality().equals(other.characteristic, characteristic)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(shortTitle) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(characteristic);

  @override
  _$EvidenceVariableCopyWith<_EvidenceVariable> get copyWith =>
      __$EvidenceVariableCopyWithImpl<_EvidenceVariable>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EvidenceVariableToJson(this);
  }
}

abstract class _EvidenceVariable implements EvidenceVariable {
  const factory _EvidenceVariable(
          {@required
          @JsonKey(required: true, defaultValue: 'EvidenceVariable')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          FhirUri url,
          List<Identifier> identifier,
          String version,
          String name,
          String title,
          String shortTitle,
          String subtitle,
          @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
              EvidenceVariableStatus status,
          FhirDateTime date,
          String publisher,
          List<ContactDetail> contact,
          Markdown description,
          List<Annotation> note,
          List<UsageContext> useContext,
          List<CodeableConcept> jurisdiction,
          Markdown copyright,
          Date approvalDate,
          Date lastReviewDate,
          Period effectivePeriod,
          List<CodeableConcept> topic,
          List<ContactDetail> author,
          List<ContactDetail> editor,
          List<ContactDetail> reviewer,
          List<ContactDetail> endorser,
          List<RelatedArtifact> relatedArtifact,
          @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
              EvidenceVariableType type,
          @required
          @JsonKey(required: true)
              List<EvidenceVariableCharacteristic> characteristic}) =
      _$_EvidenceVariable;

  factory _EvidenceVariable.fromJson(Map<String, dynamic> json) =
      _$_EvidenceVariable.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'EvidenceVariable')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get shortTitle;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: EvidenceVariableStatus.unknown)
  EvidenceVariableStatus get status;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<Annotation> get note;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  @JsonKey(unknownEnumValue: EvidenceVariableType.unknown)
  EvidenceVariableType get type;
  @override
  @JsonKey(required: true)
  List<EvidenceVariableCharacteristic> get characteristic;
  @override
  _$EvidenceVariableCopyWith<_EvidenceVariable> get copyWith;
}

EvidenceVariableCharacteristic _$EvidenceVariableCharacteristicFromJson(
    Map<String, dynamic> json) {
  return _EvidenceVariableCharacteristic.fromJson(json);
}

class _$EvidenceVariableCharacteristicTearOff {
  const _$EvidenceVariableCharacteristicTearOff();

  _EvidenceVariableCharacteristic call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Reference definitionReference,
      Canonical definitionCanonical,
      CodeableConcept definitionCodeableConcept,
      Expression definitionExpression,
      DataRequirement definitionDataRequirement,
      TriggerDefinition definitionTriggerDefinition,
      List<UsageContext> usageContext,
      Boolean exclude,
      FhirDateTime participantEffectiveDateTime,
      Period participantEffectivePeriod,
      Duration participantEffectiveDuration,
      Timing participantEffectiveTiming,
      Duration timeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
          CharacteristicGroupMeasure groupMeasure}) {
    return _EvidenceVariableCharacteristic(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      definitionReference: definitionReference,
      definitionCanonical: definitionCanonical,
      definitionCodeableConcept: definitionCodeableConcept,
      definitionExpression: definitionExpression,
      definitionDataRequirement: definitionDataRequirement,
      definitionTriggerDefinition: definitionTriggerDefinition,
      usageContext: usageContext,
      exclude: exclude,
      participantEffectiveDateTime: participantEffectiveDateTime,
      participantEffectivePeriod: participantEffectivePeriod,
      participantEffectiveDuration: participantEffectiveDuration,
      participantEffectiveTiming: participantEffectiveTiming,
      timeFromStart: timeFromStart,
      groupMeasure: groupMeasure,
    );
  }
}

// ignore: unused_element
const $EvidenceVariableCharacteristic =
    _$EvidenceVariableCharacteristicTearOff();

mixin _$EvidenceVariableCharacteristic {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  Reference get definitionReference;
  Canonical get definitionCanonical;
  CodeableConcept get definitionCodeableConcept;
  Expression get definitionExpression;
  DataRequirement get definitionDataRequirement;
  TriggerDefinition get definitionTriggerDefinition;
  List<UsageContext> get usageContext;
  Boolean get exclude;
  FhirDateTime get participantEffectiveDateTime;
  Period get participantEffectivePeriod;
  Duration get participantEffectiveDuration;
  Timing get participantEffectiveTiming;
  Duration get timeFromStart;
  @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
  CharacteristicGroupMeasure get groupMeasure;

  Map<String, dynamic> toJson();
  $EvidenceVariableCharacteristicCopyWith<EvidenceVariableCharacteristic>
      get copyWith;
}

abstract class $EvidenceVariableCharacteristicCopyWith<$Res> {
  factory $EvidenceVariableCharacteristicCopyWith(
          EvidenceVariableCharacteristic value,
          $Res Function(EvidenceVariableCharacteristic) then) =
      _$EvidenceVariableCharacteristicCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Reference definitionReference,
      Canonical definitionCanonical,
      CodeableConcept definitionCodeableConcept,
      Expression definitionExpression,
      DataRequirement definitionDataRequirement,
      TriggerDefinition definitionTriggerDefinition,
      List<UsageContext> usageContext,
      Boolean exclude,
      FhirDateTime participantEffectiveDateTime,
      Period participantEffectivePeriod,
      Duration participantEffectiveDuration,
      Timing participantEffectiveTiming,
      Duration timeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
          CharacteristicGroupMeasure groupMeasure});

  $ReferenceCopyWith<$Res> get definitionReference;
  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept;
  $ExpressionCopyWith<$Res> get definitionExpression;
  $DataRequirementCopyWith<$Res> get definitionDataRequirement;
  $TriggerDefinitionCopyWith<$Res> get definitionTriggerDefinition;
  $PeriodCopyWith<$Res> get participantEffectivePeriod;
  $DurationCopyWith<$Res> get participantEffectiveDuration;
  $TimingCopyWith<$Res> get participantEffectiveTiming;
  $DurationCopyWith<$Res> get timeFromStart;
}

class _$EvidenceVariableCharacteristicCopyWithImpl<$Res>
    implements $EvidenceVariableCharacteristicCopyWith<$Res> {
  _$EvidenceVariableCharacteristicCopyWithImpl(this._value, this._then);

  final EvidenceVariableCharacteristic _value;
  // ignore: unused_field
  final $Res Function(EvidenceVariableCharacteristic) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object definitionReference = freezed,
    Object definitionCanonical = freezed,
    Object definitionCodeableConcept = freezed,
    Object definitionExpression = freezed,
    Object definitionDataRequirement = freezed,
    Object definitionTriggerDefinition = freezed,
    Object usageContext = freezed,
    Object exclude = freezed,
    Object participantEffectiveDateTime = freezed,
    Object participantEffectivePeriod = freezed,
    Object participantEffectiveDuration = freezed,
    Object participantEffectiveTiming = freezed,
    Object timeFromStart = freezed,
    Object groupMeasure = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      definitionReference: definitionReference == freezed
          ? _value.definitionReference
          : definitionReference as Reference,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionCodeableConcept: definitionCodeableConcept == freezed
          ? _value.definitionCodeableConcept
          : definitionCodeableConcept as CodeableConcept,
      definitionExpression: definitionExpression == freezed
          ? _value.definitionExpression
          : definitionExpression as Expression,
      definitionDataRequirement: definitionDataRequirement == freezed
          ? _value.definitionDataRequirement
          : definitionDataRequirement as DataRequirement,
      definitionTriggerDefinition: definitionTriggerDefinition == freezed
          ? _value.definitionTriggerDefinition
          : definitionTriggerDefinition as TriggerDefinition,
      usageContext: usageContext == freezed
          ? _value.usageContext
          : usageContext as List<UsageContext>,
      exclude: exclude == freezed ? _value.exclude : exclude as Boolean,
      participantEffectiveDateTime: participantEffectiveDateTime == freezed
          ? _value.participantEffectiveDateTime
          : participantEffectiveDateTime as FhirDateTime,
      participantEffectivePeriod: participantEffectivePeriod == freezed
          ? _value.participantEffectivePeriod
          : participantEffectivePeriod as Period,
      participantEffectiveDuration: participantEffectiveDuration == freezed
          ? _value.participantEffectiveDuration
          : participantEffectiveDuration as Duration,
      participantEffectiveTiming: participantEffectiveTiming == freezed
          ? _value.participantEffectiveTiming
          : participantEffectiveTiming as Timing,
      timeFromStart: timeFromStart == freezed
          ? _value.timeFromStart
          : timeFromStart as Duration,
      groupMeasure: groupMeasure == freezed
          ? _value.groupMeasure
          : groupMeasure as CharacteristicGroupMeasure,
    ));
  }

  @override
  $ReferenceCopyWith<$Res> get definitionReference {
    if (_value.definitionReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.definitionReference, (value) {
      return _then(_value.copyWith(definitionReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept {
    if (_value.definitionCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.definitionCodeableConcept,
        (value) {
      return _then(_value.copyWith(definitionCodeableConcept: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get definitionExpression {
    if (_value.definitionExpression == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.definitionExpression, (value) {
      return _then(_value.copyWith(definitionExpression: value));
    });
  }

  @override
  $DataRequirementCopyWith<$Res> get definitionDataRequirement {
    if (_value.definitionDataRequirement == null) {
      return null;
    }
    return $DataRequirementCopyWith<$Res>(_value.definitionDataRequirement,
        (value) {
      return _then(_value.copyWith(definitionDataRequirement: value));
    });
  }

  @override
  $TriggerDefinitionCopyWith<$Res> get definitionTriggerDefinition {
    if (_value.definitionTriggerDefinition == null) {
      return null;
    }
    return $TriggerDefinitionCopyWith<$Res>(_value.definitionTriggerDefinition,
        (value) {
      return _then(_value.copyWith(definitionTriggerDefinition: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get participantEffectivePeriod {
    if (_value.participantEffectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.participantEffectivePeriod, (value) {
      return _then(_value.copyWith(participantEffectivePeriod: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get participantEffectiveDuration {
    if (_value.participantEffectiveDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.participantEffectiveDuration,
        (value) {
      return _then(_value.copyWith(participantEffectiveDuration: value));
    });
  }

  @override
  $TimingCopyWith<$Res> get participantEffectiveTiming {
    if (_value.participantEffectiveTiming == null) {
      return null;
    }
    return $TimingCopyWith<$Res>(_value.participantEffectiveTiming, (value) {
      return _then(_value.copyWith(participantEffectiveTiming: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get timeFromStart {
    if (_value.timeFromStart == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.timeFromStart, (value) {
      return _then(_value.copyWith(timeFromStart: value));
    });
  }
}

abstract class _$EvidenceVariableCharacteristicCopyWith<$Res>
    implements $EvidenceVariableCharacteristicCopyWith<$Res> {
  factory _$EvidenceVariableCharacteristicCopyWith(
          _EvidenceVariableCharacteristic value,
          $Res Function(_EvidenceVariableCharacteristic) then) =
      __$EvidenceVariableCharacteristicCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Reference definitionReference,
      Canonical definitionCanonical,
      CodeableConcept definitionCodeableConcept,
      Expression definitionExpression,
      DataRequirement definitionDataRequirement,
      TriggerDefinition definitionTriggerDefinition,
      List<UsageContext> usageContext,
      Boolean exclude,
      FhirDateTime participantEffectiveDateTime,
      Period participantEffectivePeriod,
      Duration participantEffectiveDuration,
      Timing participantEffectiveTiming,
      Duration timeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
          CharacteristicGroupMeasure groupMeasure});

  @override
  $ReferenceCopyWith<$Res> get definitionReference;
  @override
  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept;
  @override
  $ExpressionCopyWith<$Res> get definitionExpression;
  @override
  $DataRequirementCopyWith<$Res> get definitionDataRequirement;
  @override
  $TriggerDefinitionCopyWith<$Res> get definitionTriggerDefinition;
  @override
  $PeriodCopyWith<$Res> get participantEffectivePeriod;
  @override
  $DurationCopyWith<$Res> get participantEffectiveDuration;
  @override
  $TimingCopyWith<$Res> get participantEffectiveTiming;
  @override
  $DurationCopyWith<$Res> get timeFromStart;
}

class __$EvidenceVariableCharacteristicCopyWithImpl<$Res>
    extends _$EvidenceVariableCharacteristicCopyWithImpl<$Res>
    implements _$EvidenceVariableCharacteristicCopyWith<$Res> {
  __$EvidenceVariableCharacteristicCopyWithImpl(
      _EvidenceVariableCharacteristic _value,
      $Res Function(_EvidenceVariableCharacteristic) _then)
      : super(_value, (v) => _then(v as _EvidenceVariableCharacteristic));

  @override
  _EvidenceVariableCharacteristic get _value =>
      super._value as _EvidenceVariableCharacteristic;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object definitionReference = freezed,
    Object definitionCanonical = freezed,
    Object definitionCodeableConcept = freezed,
    Object definitionExpression = freezed,
    Object definitionDataRequirement = freezed,
    Object definitionTriggerDefinition = freezed,
    Object usageContext = freezed,
    Object exclude = freezed,
    Object participantEffectiveDateTime = freezed,
    Object participantEffectivePeriod = freezed,
    Object participantEffectiveDuration = freezed,
    Object participantEffectiveTiming = freezed,
    Object timeFromStart = freezed,
    Object groupMeasure = freezed,
  }) {
    return _then(_EvidenceVariableCharacteristic(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      definitionReference: definitionReference == freezed
          ? _value.definitionReference
          : definitionReference as Reference,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionCodeableConcept: definitionCodeableConcept == freezed
          ? _value.definitionCodeableConcept
          : definitionCodeableConcept as CodeableConcept,
      definitionExpression: definitionExpression == freezed
          ? _value.definitionExpression
          : definitionExpression as Expression,
      definitionDataRequirement: definitionDataRequirement == freezed
          ? _value.definitionDataRequirement
          : definitionDataRequirement as DataRequirement,
      definitionTriggerDefinition: definitionTriggerDefinition == freezed
          ? _value.definitionTriggerDefinition
          : definitionTriggerDefinition as TriggerDefinition,
      usageContext: usageContext == freezed
          ? _value.usageContext
          : usageContext as List<UsageContext>,
      exclude: exclude == freezed ? _value.exclude : exclude as Boolean,
      participantEffectiveDateTime: participantEffectiveDateTime == freezed
          ? _value.participantEffectiveDateTime
          : participantEffectiveDateTime as FhirDateTime,
      participantEffectivePeriod: participantEffectivePeriod == freezed
          ? _value.participantEffectivePeriod
          : participantEffectivePeriod as Period,
      participantEffectiveDuration: participantEffectiveDuration == freezed
          ? _value.participantEffectiveDuration
          : participantEffectiveDuration as Duration,
      participantEffectiveTiming: participantEffectiveTiming == freezed
          ? _value.participantEffectiveTiming
          : participantEffectiveTiming as Timing,
      timeFromStart: timeFromStart == freezed
          ? _value.timeFromStart
          : timeFromStart as Duration,
      groupMeasure: groupMeasure == freezed
          ? _value.groupMeasure
          : groupMeasure as CharacteristicGroupMeasure,
    ));
  }
}

@JsonSerializable()
class _$_EvidenceVariableCharacteristic
    implements _EvidenceVariableCharacteristic {
  const _$_EvidenceVariableCharacteristic(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.description,
      this.definitionReference,
      this.definitionCanonical,
      this.definitionCodeableConcept,
      this.definitionExpression,
      this.definitionDataRequirement,
      this.definitionTriggerDefinition,
      this.usageContext,
      this.exclude,
      this.participantEffectiveDateTime,
      this.participantEffectivePeriod,
      this.participantEffectiveDuration,
      this.participantEffectiveTiming,
      this.timeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
          this.groupMeasure});

  factory _$_EvidenceVariableCharacteristic.fromJson(
          Map<String, dynamic> json) =>
      _$_$_EvidenceVariableCharacteristicFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  final Reference definitionReference;
  @override
  final Canonical definitionCanonical;
  @override
  final CodeableConcept definitionCodeableConcept;
  @override
  final Expression definitionExpression;
  @override
  final DataRequirement definitionDataRequirement;
  @override
  final TriggerDefinition definitionTriggerDefinition;
  @override
  final List<UsageContext> usageContext;
  @override
  final Boolean exclude;
  @override
  final FhirDateTime participantEffectiveDateTime;
  @override
  final Period participantEffectivePeriod;
  @override
  final Duration participantEffectiveDuration;
  @override
  final Timing participantEffectiveTiming;
  @override
  final Duration timeFromStart;
  @override
  @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
  final CharacteristicGroupMeasure groupMeasure;

  @override
  String toString() {
    return 'EvidenceVariableCharacteristic(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, definitionReference: $definitionReference, definitionCanonical: $definitionCanonical, definitionCodeableConcept: $definitionCodeableConcept, definitionExpression: $definitionExpression, definitionDataRequirement: $definitionDataRequirement, definitionTriggerDefinition: $definitionTriggerDefinition, usageContext: $usageContext, exclude: $exclude, participantEffectiveDateTime: $participantEffectiveDateTime, participantEffectivePeriod: $participantEffectivePeriod, participantEffectiveDuration: $participantEffectiveDuration, participantEffectiveTiming: $participantEffectiveTiming, timeFromStart: $timeFromStart, groupMeasure: $groupMeasure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EvidenceVariableCharacteristic &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.definitionReference, definitionReference) ||
                const DeepCollectionEquality()
                    .equals(other.definitionReference, definitionReference)) &&
            (identical(other.definitionCanonical, definitionCanonical) ||
                const DeepCollectionEquality()
                    .equals(other.definitionCanonical, definitionCanonical)) &&
            (identical(other.definitionCodeableConcept, definitionCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.definitionCodeableConcept,
                    definitionCodeableConcept)) &&
            (identical(other.definitionExpression, definitionExpression) ||
                const DeepCollectionEquality().equals(
                    other.definitionExpression, definitionExpression)) &&
            (identical(other.definitionDataRequirement, definitionDataRequirement) ||
                const DeepCollectionEquality().equals(
                    other.definitionDataRequirement,
                    definitionDataRequirement)) &&
            (identical(other.definitionTriggerDefinition, definitionTriggerDefinition) ||
                const DeepCollectionEquality().equals(
                    other.definitionTriggerDefinition,
                    definitionTriggerDefinition)) &&
            (identical(other.usageContext, usageContext) ||
                const DeepCollectionEquality()
                    .equals(other.usageContext, usageContext)) &&
            (identical(other.exclude, exclude) ||
                const DeepCollectionEquality()
                    .equals(other.exclude, exclude)) &&
            (identical(other.participantEffectiveDateTime, participantEffectiveDateTime) ||
                const DeepCollectionEquality().equals(
                    other.participantEffectiveDateTime,
                    participantEffectiveDateTime)) &&
            (identical(other.participantEffectivePeriod, participantEffectivePeriod) ||
                const DeepCollectionEquality().equals(
                    other.participantEffectivePeriod,
                    participantEffectivePeriod)) &&
            (identical(other.participantEffectiveDuration, participantEffectiveDuration) || const DeepCollectionEquality().equals(other.participantEffectiveDuration, participantEffectiveDuration)) &&
            (identical(other.participantEffectiveTiming, participantEffectiveTiming) || const DeepCollectionEquality().equals(other.participantEffectiveTiming, participantEffectiveTiming)) &&
            (identical(other.timeFromStart, timeFromStart) || const DeepCollectionEquality().equals(other.timeFromStart, timeFromStart)) &&
            (identical(other.groupMeasure, groupMeasure) || const DeepCollectionEquality().equals(other.groupMeasure, groupMeasure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(definitionReference) ^
      const DeepCollectionEquality().hash(definitionCanonical) ^
      const DeepCollectionEquality().hash(definitionCodeableConcept) ^
      const DeepCollectionEquality().hash(definitionExpression) ^
      const DeepCollectionEquality().hash(definitionDataRequirement) ^
      const DeepCollectionEquality().hash(definitionTriggerDefinition) ^
      const DeepCollectionEquality().hash(usageContext) ^
      const DeepCollectionEquality().hash(exclude) ^
      const DeepCollectionEquality().hash(participantEffectiveDateTime) ^
      const DeepCollectionEquality().hash(participantEffectivePeriod) ^
      const DeepCollectionEquality().hash(participantEffectiveDuration) ^
      const DeepCollectionEquality().hash(participantEffectiveTiming) ^
      const DeepCollectionEquality().hash(timeFromStart) ^
      const DeepCollectionEquality().hash(groupMeasure);

  @override
  _$EvidenceVariableCharacteristicCopyWith<_EvidenceVariableCharacteristic>
      get copyWith => __$EvidenceVariableCharacteristicCopyWithImpl<
          _EvidenceVariableCharacteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_EvidenceVariableCharacteristicToJson(this);
  }
}

abstract class _EvidenceVariableCharacteristic
    implements EvidenceVariableCharacteristic {
  const factory _EvidenceVariableCharacteristic(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String description,
          Reference definitionReference,
          Canonical definitionCanonical,
          CodeableConcept definitionCodeableConcept,
          Expression definitionExpression,
          DataRequirement definitionDataRequirement,
          TriggerDefinition definitionTriggerDefinition,
          List<UsageContext> usageContext,
          Boolean exclude,
          FhirDateTime participantEffectiveDateTime,
          Period participantEffectivePeriod,
          Duration participantEffectiveDuration,
          Timing participantEffectiveTiming,
          Duration timeFromStart,
          @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
              CharacteristicGroupMeasure groupMeasure}) =
      _$_EvidenceVariableCharacteristic;

  factory _EvidenceVariableCharacteristic.fromJson(Map<String, dynamic> json) =
      _$_EvidenceVariableCharacteristic.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  Reference get definitionReference;
  @override
  Canonical get definitionCanonical;
  @override
  CodeableConcept get definitionCodeableConcept;
  @override
  Expression get definitionExpression;
  @override
  DataRequirement get definitionDataRequirement;
  @override
  TriggerDefinition get definitionTriggerDefinition;
  @override
  List<UsageContext> get usageContext;
  @override
  Boolean get exclude;
  @override
  FhirDateTime get participantEffectiveDateTime;
  @override
  Period get participantEffectivePeriod;
  @override
  Duration get participantEffectiveDuration;
  @override
  Timing get participantEffectiveTiming;
  @override
  Duration get timeFromStart;
  @override
  @JsonKey(unknownEnumValue: CharacteristicGroupMeasure.unknown)
  CharacteristicGroupMeasure get groupMeasure;
  @override
  _$EvidenceVariableCharacteristicCopyWith<_EvidenceVariableCharacteristic>
      get copyWith;
}

Measure _$MeasureFromJson(Map<String, dynamic> json) {
  return _Measure.fromJson(json);
}

class _$MeasureTearOff {
  const _$MeasureTearOff();

  _Measure call(
      {@required
      @JsonKey(required: true, defaultValue: 'Measure')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: MeasureStatus.unknown)
          MeasureStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Markdown disclaimer,
      CodeableConcept scoring,
      CodeableConcept compositeScoring,
      List<CodeableConcept> type,
      String riskAdjustment,
      String rateAggregation,
      Markdown rationale,
      Markdown clinicalRecommendationStatement,
      CodeableConcept improvementNotation,
      List<Markdown> definition,
      Markdown guidance,
      List<MeasureGroup> group,
      List<MeasureSupplementalData> supplementalData}) {
    return _Measure(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      subtitle: subtitle,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      library: library,
      disclaimer: disclaimer,
      scoring: scoring,
      compositeScoring: compositeScoring,
      type: type,
      riskAdjustment: riskAdjustment,
      rateAggregation: rateAggregation,
      rationale: rationale,
      clinicalRecommendationStatement: clinicalRecommendationStatement,
      improvementNotation: improvementNotation,
      definition: definition,
      guidance: guidance,
      group: group,
      supplementalData: supplementalData,
    );
  }
}

// ignore: unused_element
const $Measure = _$MeasureTearOff();

mixin _$Measure {
  @JsonKey(required: true, defaultValue: 'Measure')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get subtitle;
  @JsonKey(unknownEnumValue: MeasureStatus.unknown)
  MeasureStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  List<Canonical> get library;
  Markdown get disclaimer;
  CodeableConcept get scoring;
  CodeableConcept get compositeScoring;
  List<CodeableConcept> get type;
  String get riskAdjustment;
  String get rateAggregation;
  Markdown get rationale;
  Markdown get clinicalRecommendationStatement;
  CodeableConcept get improvementNotation;
  List<Markdown> get definition;
  Markdown get guidance;
  List<MeasureGroup> get group;
  List<MeasureSupplementalData> get supplementalData;

  Map<String, dynamic> toJson();
  $MeasureCopyWith<Measure> get copyWith;
}

abstract class $MeasureCopyWith<$Res> {
  factory $MeasureCopyWith(Measure value, $Res Function(Measure) then) =
      _$MeasureCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Measure') String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: MeasureStatus.unknown) MeasureStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Markdown disclaimer,
      CodeableConcept scoring,
      CodeableConcept compositeScoring,
      List<CodeableConcept> type,
      String riskAdjustment,
      String rateAggregation,
      Markdown rationale,
      Markdown clinicalRecommendationStatement,
      CodeableConcept improvementNotation,
      List<Markdown> definition,
      Markdown guidance,
      List<MeasureGroup> group,
      List<MeasureSupplementalData> supplementalData});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $CodeableConceptCopyWith<$Res> get scoring;
  $CodeableConceptCopyWith<$Res> get compositeScoring;
  $CodeableConceptCopyWith<$Res> get improvementNotation;
}

class _$MeasureCopyWithImpl<$Res> implements $MeasureCopyWith<$Res> {
  _$MeasureCopyWithImpl(this._value, this._then);

  final Measure _value;
  // ignore: unused_field
  final $Res Function(Measure) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object disclaimer = freezed,
    Object scoring = freezed,
    Object compositeScoring = freezed,
    Object type = freezed,
    Object riskAdjustment = freezed,
    Object rateAggregation = freezed,
    Object rationale = freezed,
    Object clinicalRecommendationStatement = freezed,
    Object improvementNotation = freezed,
    Object definition = freezed,
    Object guidance = freezed,
    Object group = freezed,
    Object supplementalData = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed ? _value.status : status as MeasureStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      disclaimer:
          disclaimer == freezed ? _value.disclaimer : disclaimer as Markdown,
      scoring: scoring == freezed ? _value.scoring : scoring as CodeableConcept,
      compositeScoring: compositeScoring == freezed
          ? _value.compositeScoring
          : compositeScoring as CodeableConcept,
      type: type == freezed ? _value.type : type as List<CodeableConcept>,
      riskAdjustment: riskAdjustment == freezed
          ? _value.riskAdjustment
          : riskAdjustment as String,
      rateAggregation: rateAggregation == freezed
          ? _value.rateAggregation
          : rateAggregation as String,
      rationale:
          rationale == freezed ? _value.rationale : rationale as Markdown,
      clinicalRecommendationStatement:
          clinicalRecommendationStatement == freezed
              ? _value.clinicalRecommendationStatement
              : clinicalRecommendationStatement as Markdown,
      improvementNotation: improvementNotation == freezed
          ? _value.improvementNotation
          : improvementNotation as CodeableConcept,
      definition: definition == freezed
          ? _value.definition
          : definition as List<Markdown>,
      guidance: guidance == freezed ? _value.guidance : guidance as Markdown,
      group: group == freezed ? _value.group : group as List<MeasureGroup>,
      supplementalData: supplementalData == freezed
          ? _value.supplementalData
          : supplementalData as List<MeasureSupplementalData>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get scoring {
    if (_value.scoring == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.scoring, (value) {
      return _then(_value.copyWith(scoring: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get compositeScoring {
    if (_value.compositeScoring == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.compositeScoring, (value) {
      return _then(_value.copyWith(compositeScoring: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get improvementNotation {
    if (_value.improvementNotation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.improvementNotation, (value) {
      return _then(_value.copyWith(improvementNotation: value));
    });
  }
}

abstract class _$MeasureCopyWith<$Res> implements $MeasureCopyWith<$Res> {
  factory _$MeasureCopyWith(_Measure value, $Res Function(_Measure) then) =
      __$MeasureCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Measure') String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: MeasureStatus.unknown) MeasureStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Markdown disclaimer,
      CodeableConcept scoring,
      CodeableConcept compositeScoring,
      List<CodeableConcept> type,
      String riskAdjustment,
      String rateAggregation,
      Markdown rationale,
      Markdown clinicalRecommendationStatement,
      CodeableConcept improvementNotation,
      List<Markdown> definition,
      Markdown guidance,
      List<MeasureGroup> group,
      List<MeasureSupplementalData> supplementalData});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $CodeableConceptCopyWith<$Res> get scoring;
  @override
  $CodeableConceptCopyWith<$Res> get compositeScoring;
  @override
  $CodeableConceptCopyWith<$Res> get improvementNotation;
}

class __$MeasureCopyWithImpl<$Res> extends _$MeasureCopyWithImpl<$Res>
    implements _$MeasureCopyWith<$Res> {
  __$MeasureCopyWithImpl(_Measure _value, $Res Function(_Measure) _then)
      : super(_value, (v) => _then(v as _Measure));

  @override
  _Measure get _value => super._value as _Measure;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object disclaimer = freezed,
    Object scoring = freezed,
    Object compositeScoring = freezed,
    Object type = freezed,
    Object riskAdjustment = freezed,
    Object rateAggregation = freezed,
    Object rationale = freezed,
    Object clinicalRecommendationStatement = freezed,
    Object improvementNotation = freezed,
    Object definition = freezed,
    Object guidance = freezed,
    Object group = freezed,
    Object supplementalData = freezed,
  }) {
    return _then(_Measure(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed ? _value.status : status as MeasureStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      disclaimer:
          disclaimer == freezed ? _value.disclaimer : disclaimer as Markdown,
      scoring: scoring == freezed ? _value.scoring : scoring as CodeableConcept,
      compositeScoring: compositeScoring == freezed
          ? _value.compositeScoring
          : compositeScoring as CodeableConcept,
      type: type == freezed ? _value.type : type as List<CodeableConcept>,
      riskAdjustment: riskAdjustment == freezed
          ? _value.riskAdjustment
          : riskAdjustment as String,
      rateAggregation: rateAggregation == freezed
          ? _value.rateAggregation
          : rateAggregation as String,
      rationale:
          rationale == freezed ? _value.rationale : rationale as Markdown,
      clinicalRecommendationStatement:
          clinicalRecommendationStatement == freezed
              ? _value.clinicalRecommendationStatement
              : clinicalRecommendationStatement as Markdown,
      improvementNotation: improvementNotation == freezed
          ? _value.improvementNotation
          : improvementNotation as CodeableConcept,
      definition: definition == freezed
          ? _value.definition
          : definition as List<Markdown>,
      guidance: guidance == freezed ? _value.guidance : guidance as Markdown,
      group: group == freezed ? _value.group : group as List<MeasureGroup>,
      supplementalData: supplementalData == freezed
          ? _value.supplementalData
          : supplementalData as List<MeasureSupplementalData>,
    ));
  }
}

@JsonSerializable()
class _$_Measure implements _Measure {
  const _$_Measure(
      {@required
      @JsonKey(required: true, defaultValue: 'Measure')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.subtitle,
      @JsonKey(unknownEnumValue: MeasureStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.library,
      this.disclaimer,
      this.scoring,
      this.compositeScoring,
      this.type,
      this.riskAdjustment,
      this.rateAggregation,
      this.rationale,
      this.clinicalRecommendationStatement,
      this.improvementNotation,
      this.definition,
      this.guidance,
      this.group,
      this.supplementalData})
      : assert(resourceType != null);

  factory _$_Measure.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'Measure')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: MeasureStatus.unknown)
  final MeasureStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<Canonical> library;
  @override
  final Markdown disclaimer;
  @override
  final CodeableConcept scoring;
  @override
  final CodeableConcept compositeScoring;
  @override
  final List<CodeableConcept> type;
  @override
  final String riskAdjustment;
  @override
  final String rateAggregation;
  @override
  final Markdown rationale;
  @override
  final Markdown clinicalRecommendationStatement;
  @override
  final CodeableConcept improvementNotation;
  @override
  final List<Markdown> definition;
  @override
  final Markdown guidance;
  @override
  final List<MeasureGroup> group;
  @override
  final List<MeasureSupplementalData> supplementalData;

  @override
  String toString() {
    return 'Measure(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, subtitle: $subtitle, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, library: $library, disclaimer: $disclaimer, scoring: $scoring, compositeScoring: $compositeScoring, type: $type, riskAdjustment: $riskAdjustment, rateAggregation: $rateAggregation, rationale: $rationale, clinicalRecommendationStatement: $clinicalRecommendationStatement, improvementNotation: $improvementNotation, definition: $definition, guidance: $guidance, group: $group, supplementalData: $supplementalData)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Measure &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.library, library) || const DeepCollectionEquality().equals(other.library, library)) &&
            (identical(other.disclaimer, disclaimer) || const DeepCollectionEquality().equals(other.disclaimer, disclaimer)) &&
            (identical(other.scoring, scoring) || const DeepCollectionEquality().equals(other.scoring, scoring)) &&
            (identical(other.compositeScoring, compositeScoring) || const DeepCollectionEquality().equals(other.compositeScoring, compositeScoring)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.riskAdjustment, riskAdjustment) || const DeepCollectionEquality().equals(other.riskAdjustment, riskAdjustment)) &&
            (identical(other.rateAggregation, rateAggregation) || const DeepCollectionEquality().equals(other.rateAggregation, rateAggregation)) &&
            (identical(other.rationale, rationale) || const DeepCollectionEquality().equals(other.rationale, rationale)) &&
            (identical(other.clinicalRecommendationStatement, clinicalRecommendationStatement) || const DeepCollectionEquality().equals(other.clinicalRecommendationStatement, clinicalRecommendationStatement)) &&
            (identical(other.improvementNotation, improvementNotation) || const DeepCollectionEquality().equals(other.improvementNotation, improvementNotation)) &&
            (identical(other.definition, definition) || const DeepCollectionEquality().equals(other.definition, definition)) &&
            (identical(other.guidance, guidance) || const DeepCollectionEquality().equals(other.guidance, guidance)) &&
            (identical(other.group, group) || const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.supplementalData, supplementalData) || const DeepCollectionEquality().equals(other.supplementalData, supplementalData)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(library) ^
      const DeepCollectionEquality().hash(disclaimer) ^
      const DeepCollectionEquality().hash(scoring) ^
      const DeepCollectionEquality().hash(compositeScoring) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(riskAdjustment) ^
      const DeepCollectionEquality().hash(rateAggregation) ^
      const DeepCollectionEquality().hash(rationale) ^
      const DeepCollectionEquality().hash(clinicalRecommendationStatement) ^
      const DeepCollectionEquality().hash(improvementNotation) ^
      const DeepCollectionEquality().hash(definition) ^
      const DeepCollectionEquality().hash(guidance) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(supplementalData);

  @override
  _$MeasureCopyWith<_Measure> get copyWith =>
      __$MeasureCopyWithImpl<_Measure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureToJson(this);
  }
}

abstract class _Measure implements Measure {
  const factory _Measure(
      {@required
      @JsonKey(required: true, defaultValue: 'Measure')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      @JsonKey(unknownEnumValue: MeasureStatus.unknown)
          MeasureStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      Markdown disclaimer,
      CodeableConcept scoring,
      CodeableConcept compositeScoring,
      List<CodeableConcept> type,
      String riskAdjustment,
      String rateAggregation,
      Markdown rationale,
      Markdown clinicalRecommendationStatement,
      CodeableConcept improvementNotation,
      List<Markdown> definition,
      Markdown guidance,
      List<MeasureGroup> group,
      List<MeasureSupplementalData> supplementalData}) = _$_Measure;

  factory _Measure.fromJson(Map<String, dynamic> json) = _$_Measure.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'Measure')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: MeasureStatus.unknown)
  MeasureStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<Canonical> get library;
  @override
  Markdown get disclaimer;
  @override
  CodeableConcept get scoring;
  @override
  CodeableConcept get compositeScoring;
  @override
  List<CodeableConcept> get type;
  @override
  String get riskAdjustment;
  @override
  String get rateAggregation;
  @override
  Markdown get rationale;
  @override
  Markdown get clinicalRecommendationStatement;
  @override
  CodeableConcept get improvementNotation;
  @override
  List<Markdown> get definition;
  @override
  Markdown get guidance;
  @override
  List<MeasureGroup> get group;
  @override
  List<MeasureSupplementalData> get supplementalData;
  @override
  _$MeasureCopyWith<_Measure> get copyWith;
}

MeasureGroup _$MeasureGroupFromJson(Map<String, dynamic> json) {
  return _MeasureGroup.fromJson(json);
}

class _$MeasureGroupTearOff {
  const _$MeasureGroupTearOff();

  _MeasureGroup call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      List<MeasurePopulation> population,
      List<MeasureStratifier> stratifier}) {
    return _MeasureGroup(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      description: description,
      population: population,
      stratifier: stratifier,
    );
  }
}

// ignore: unused_element
const $MeasureGroup = _$MeasureGroupTearOff();

mixin _$MeasureGroup {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  String get description;
  List<MeasurePopulation> get population;
  List<MeasureStratifier> get stratifier;

  Map<String, dynamic> toJson();
  $MeasureGroupCopyWith<MeasureGroup> get copyWith;
}

abstract class $MeasureGroupCopyWith<$Res> {
  factory $MeasureGroupCopyWith(
          MeasureGroup value, $Res Function(MeasureGroup) then) =
      _$MeasureGroupCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      List<MeasurePopulation> population,
      List<MeasureStratifier> stratifier});

  $CodeableConceptCopyWith<$Res> get code;
}

class _$MeasureGroupCopyWithImpl<$Res> implements $MeasureGroupCopyWith<$Res> {
  _$MeasureGroupCopyWithImpl(this._value, this._then);

  final MeasureGroup _value;
  // ignore: unused_field
  final $Res Function(MeasureGroup) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object population = freezed,
    Object stratifier = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      population: population == freezed
          ? _value.population
          : population as List<MeasurePopulation>,
      stratifier: stratifier == freezed
          ? _value.stratifier
          : stratifier as List<MeasureStratifier>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

abstract class _$MeasureGroupCopyWith<$Res>
    implements $MeasureGroupCopyWith<$Res> {
  factory _$MeasureGroupCopyWith(
          _MeasureGroup value, $Res Function(_MeasureGroup) then) =
      __$MeasureGroupCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      List<MeasurePopulation> population,
      List<MeasureStratifier> stratifier});

  @override
  $CodeableConceptCopyWith<$Res> get code;
}

class __$MeasureGroupCopyWithImpl<$Res> extends _$MeasureGroupCopyWithImpl<$Res>
    implements _$MeasureGroupCopyWith<$Res> {
  __$MeasureGroupCopyWithImpl(
      _MeasureGroup _value, $Res Function(_MeasureGroup) _then)
      : super(_value, (v) => _then(v as _MeasureGroup));

  @override
  _MeasureGroup get _value => super._value as _MeasureGroup;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object population = freezed,
    Object stratifier = freezed,
  }) {
    return _then(_MeasureGroup(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      population: population == freezed
          ? _value.population
          : population as List<MeasurePopulation>,
      stratifier: stratifier == freezed
          ? _value.stratifier
          : stratifier as List<MeasureStratifier>,
    ));
  }
}

@JsonSerializable()
class _$_MeasureGroup implements _MeasureGroup {
  const _$_MeasureGroup(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.description,
      this.population,
      this.stratifier});

  factory _$_MeasureGroup.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureGroupFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final String description;
  @override
  final List<MeasurePopulation> population;
  @override
  final List<MeasureStratifier> stratifier;

  @override
  String toString() {
    return 'MeasureGroup(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, description: $description, population: $population, stratifier: $stratifier)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureGroup &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)) &&
            (identical(other.stratifier, stratifier) ||
                const DeepCollectionEquality()
                    .equals(other.stratifier, stratifier)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(stratifier);

  @override
  _$MeasureGroupCopyWith<_MeasureGroup> get copyWith =>
      __$MeasureGroupCopyWithImpl<_MeasureGroup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureGroupToJson(this);
  }
}

abstract class _MeasureGroup implements MeasureGroup {
  const factory _MeasureGroup(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      List<MeasurePopulation> population,
      List<MeasureStratifier> stratifier}) = _$_MeasureGroup;

  factory _MeasureGroup.fromJson(Map<String, dynamic> json) =
      _$_MeasureGroup.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  String get description;
  @override
  List<MeasurePopulation> get population;
  @override
  List<MeasureStratifier> get stratifier;
  @override
  _$MeasureGroupCopyWith<_MeasureGroup> get copyWith;
}

MeasurePopulation _$MeasurePopulationFromJson(Map<String, dynamic> json) {
  return _MeasurePopulation.fromJson(json);
}

class _$MeasurePopulationTearOff {
  const _$MeasurePopulationTearOff();

  _MeasurePopulation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @required @JsonKey(required: true) Expression criteria}) {
    return _MeasurePopulation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      description: description,
      criteria: criteria,
    );
  }
}

// ignore: unused_element
const $MeasurePopulation = _$MeasurePopulationTearOff();

mixin _$MeasurePopulation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  String get description;
  @JsonKey(required: true)
  Expression get criteria;

  Map<String, dynamic> toJson();
  $MeasurePopulationCopyWith<MeasurePopulation> get copyWith;
}

abstract class $MeasurePopulationCopyWith<$Res> {
  factory $MeasurePopulationCopyWith(
          MeasurePopulation value, $Res Function(MeasurePopulation) then) =
      _$MeasurePopulationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @JsonKey(required: true) Expression criteria});

  $CodeableConceptCopyWith<$Res> get code;
  $ExpressionCopyWith<$Res> get criteria;
}

class _$MeasurePopulationCopyWithImpl<$Res>
    implements $MeasurePopulationCopyWith<$Res> {
  _$MeasurePopulationCopyWithImpl(this._value, this._then);

  final MeasurePopulation _value;
  // ignore: unused_field
  final $Res Function(MeasurePopulation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get criteria {
    if (_value.criteria == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.criteria, (value) {
      return _then(_value.copyWith(criteria: value));
    });
  }
}

abstract class _$MeasurePopulationCopyWith<$Res>
    implements $MeasurePopulationCopyWith<$Res> {
  factory _$MeasurePopulationCopyWith(
          _MeasurePopulation value, $Res Function(_MeasurePopulation) then) =
      __$MeasurePopulationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @JsonKey(required: true) Expression criteria});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ExpressionCopyWith<$Res> get criteria;
}

class __$MeasurePopulationCopyWithImpl<$Res>
    extends _$MeasurePopulationCopyWithImpl<$Res>
    implements _$MeasurePopulationCopyWith<$Res> {
  __$MeasurePopulationCopyWithImpl(
      _MeasurePopulation _value, $Res Function(_MeasurePopulation) _then)
      : super(_value, (v) => _then(v as _MeasurePopulation));

  @override
  _MeasurePopulation get _value => super._value as _MeasurePopulation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_MeasurePopulation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }
}

@JsonSerializable()
class _$_MeasurePopulation implements _MeasurePopulation {
  const _$_MeasurePopulation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.description,
      @required @JsonKey(required: true) this.criteria})
      : assert(criteria != null);

  factory _$_MeasurePopulation.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasurePopulationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final String description;
  @override
  @JsonKey(required: true)
  final Expression criteria;

  @override
  String toString() {
    return 'MeasurePopulation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, description: $description, criteria: $criteria)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasurePopulation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.criteria, criteria) ||
                const DeepCollectionEquality()
                    .equals(other.criteria, criteria)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(criteria);

  @override
  _$MeasurePopulationCopyWith<_MeasurePopulation> get copyWith =>
      __$MeasurePopulationCopyWithImpl<_MeasurePopulation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasurePopulationToJson(this);
  }
}

abstract class _MeasurePopulation implements MeasurePopulation {
  const factory _MeasurePopulation(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept code,
          String description,
          @required @JsonKey(required: true) Expression criteria}) =
      _$_MeasurePopulation;

  factory _MeasurePopulation.fromJson(Map<String, dynamic> json) =
      _$_MeasurePopulation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  String get description;
  @override
  @JsonKey(required: true)
  Expression get criteria;
  @override
  _$MeasurePopulationCopyWith<_MeasurePopulation> get copyWith;
}

MeasureStratifier _$MeasureStratifierFromJson(Map<String, dynamic> json) {
  return _MeasureStratifier.fromJson(json);
}

class _$MeasureStratifierTearOff {
  const _$MeasureStratifierTearOff();

  _MeasureStratifier call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      Expression criteria,
      List<MeasureComponent> component}) {
    return _MeasureStratifier(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      description: description,
      criteria: criteria,
      component: component,
    );
  }
}

// ignore: unused_element
const $MeasureStratifier = _$MeasureStratifierTearOff();

mixin _$MeasureStratifier {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  String get description;
  Expression get criteria;
  List<MeasureComponent> get component;

  Map<String, dynamic> toJson();
  $MeasureStratifierCopyWith<MeasureStratifier> get copyWith;
}

abstract class $MeasureStratifierCopyWith<$Res> {
  factory $MeasureStratifierCopyWith(
          MeasureStratifier value, $Res Function(MeasureStratifier) then) =
      _$MeasureStratifierCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      Expression criteria,
      List<MeasureComponent> component});

  $CodeableConceptCopyWith<$Res> get code;
  $ExpressionCopyWith<$Res> get criteria;
}

class _$MeasureStratifierCopyWithImpl<$Res>
    implements $MeasureStratifierCopyWith<$Res> {
  _$MeasureStratifierCopyWithImpl(this._value, this._then);

  final MeasureStratifier _value;
  // ignore: unused_field
  final $Res Function(MeasureStratifier) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
    Object component = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
      component: component == freezed
          ? _value.component
          : component as List<MeasureComponent>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get criteria {
    if (_value.criteria == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.criteria, (value) {
      return _then(_value.copyWith(criteria: value));
    });
  }
}

abstract class _$MeasureStratifierCopyWith<$Res>
    implements $MeasureStratifierCopyWith<$Res> {
  factory _$MeasureStratifierCopyWith(
          _MeasureStratifier value, $Res Function(_MeasureStratifier) then) =
      __$MeasureStratifierCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      Expression criteria,
      List<MeasureComponent> component});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ExpressionCopyWith<$Res> get criteria;
}

class __$MeasureStratifierCopyWithImpl<$Res>
    extends _$MeasureStratifierCopyWithImpl<$Res>
    implements _$MeasureStratifierCopyWith<$Res> {
  __$MeasureStratifierCopyWithImpl(
      _MeasureStratifier _value, $Res Function(_MeasureStratifier) _then)
      : super(_value, (v) => _then(v as _MeasureStratifier));

  @override
  _MeasureStratifier get _value => super._value as _MeasureStratifier;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
    Object component = freezed,
  }) {
    return _then(_MeasureStratifier(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
      component: component == freezed
          ? _value.component
          : component as List<MeasureComponent>,
    ));
  }
}

@JsonSerializable()
class _$_MeasureStratifier implements _MeasureStratifier {
  const _$_MeasureStratifier(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.description,
      this.criteria,
      this.component});

  factory _$_MeasureStratifier.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureStratifierFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final String description;
  @override
  final Expression criteria;
  @override
  final List<MeasureComponent> component;

  @override
  String toString() {
    return 'MeasureStratifier(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, description: $description, criteria: $criteria, component: $component)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureStratifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.criteria, criteria) ||
                const DeepCollectionEquality()
                    .equals(other.criteria, criteria)) &&
            (identical(other.component, component) ||
                const DeepCollectionEquality()
                    .equals(other.component, component)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(criteria) ^
      const DeepCollectionEquality().hash(component);

  @override
  _$MeasureStratifierCopyWith<_MeasureStratifier> get copyWith =>
      __$MeasureStratifierCopyWithImpl<_MeasureStratifier>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureStratifierToJson(this);
  }
}

abstract class _MeasureStratifier implements MeasureStratifier {
  const factory _MeasureStratifier(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      Expression criteria,
      List<MeasureComponent> component}) = _$_MeasureStratifier;

  factory _MeasureStratifier.fromJson(Map<String, dynamic> json) =
      _$_MeasureStratifier.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  String get description;
  @override
  Expression get criteria;
  @override
  List<MeasureComponent> get component;
  @override
  _$MeasureStratifierCopyWith<_MeasureStratifier> get copyWith;
}

MeasureComponent _$MeasureComponentFromJson(Map<String, dynamic> json) {
  return _MeasureComponent.fromJson(json);
}

class _$MeasureComponentTearOff {
  const _$MeasureComponentTearOff();

  _MeasureComponent call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @required @JsonKey(required: true) Expression criteria}) {
    return _MeasureComponent(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      description: description,
      criteria: criteria,
    );
  }
}

// ignore: unused_element
const $MeasureComponent = _$MeasureComponentTearOff();

mixin _$MeasureComponent {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  String get description;
  @JsonKey(required: true)
  Expression get criteria;

  Map<String, dynamic> toJson();
  $MeasureComponentCopyWith<MeasureComponent> get copyWith;
}

abstract class $MeasureComponentCopyWith<$Res> {
  factory $MeasureComponentCopyWith(
          MeasureComponent value, $Res Function(MeasureComponent) then) =
      _$MeasureComponentCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @JsonKey(required: true) Expression criteria});

  $CodeableConceptCopyWith<$Res> get code;
  $ExpressionCopyWith<$Res> get criteria;
}

class _$MeasureComponentCopyWithImpl<$Res>
    implements $MeasureComponentCopyWith<$Res> {
  _$MeasureComponentCopyWithImpl(this._value, this._then);

  final MeasureComponent _value;
  // ignore: unused_field
  final $Res Function(MeasureComponent) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get criteria {
    if (_value.criteria == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.criteria, (value) {
      return _then(_value.copyWith(criteria: value));
    });
  }
}

abstract class _$MeasureComponentCopyWith<$Res>
    implements $MeasureComponentCopyWith<$Res> {
  factory _$MeasureComponentCopyWith(
          _MeasureComponent value, $Res Function(_MeasureComponent) then) =
      __$MeasureComponentCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      String description,
      @JsonKey(required: true) Expression criteria});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ExpressionCopyWith<$Res> get criteria;
}

class __$MeasureComponentCopyWithImpl<$Res>
    extends _$MeasureComponentCopyWithImpl<$Res>
    implements _$MeasureComponentCopyWith<$Res> {
  __$MeasureComponentCopyWithImpl(
      _MeasureComponent _value, $Res Function(_MeasureComponent) _then)
      : super(_value, (v) => _then(v as _MeasureComponent));

  @override
  _MeasureComponent get _value => super._value as _MeasureComponent;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_MeasureComponent(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }
}

@JsonSerializable()
class _$_MeasureComponent implements _MeasureComponent {
  const _$_MeasureComponent(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.description,
      @required @JsonKey(required: true) this.criteria})
      : assert(criteria != null);

  factory _$_MeasureComponent.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureComponentFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final String description;
  @override
  @JsonKey(required: true)
  final Expression criteria;

  @override
  String toString() {
    return 'MeasureComponent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, description: $description, criteria: $criteria)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureComponent &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.criteria, criteria) ||
                const DeepCollectionEquality()
                    .equals(other.criteria, criteria)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(criteria);

  @override
  _$MeasureComponentCopyWith<_MeasureComponent> get copyWith =>
      __$MeasureComponentCopyWithImpl<_MeasureComponent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureComponentToJson(this);
  }
}

abstract class _MeasureComponent implements MeasureComponent {
  const factory _MeasureComponent(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept code,
          String description,
          @required @JsonKey(required: true) Expression criteria}) =
      _$_MeasureComponent;

  factory _MeasureComponent.fromJson(Map<String, dynamic> json) =
      _$_MeasureComponent.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  String get description;
  @override
  @JsonKey(required: true)
  Expression get criteria;
  @override
  _$MeasureComponentCopyWith<_MeasureComponent> get copyWith;
}

MeasureSupplementalData _$MeasureSupplementalDataFromJson(
    Map<String, dynamic> json) {
  return _MeasureSupplementalData.fromJson(json);
}

class _$MeasureSupplementalDataTearOff {
  const _$MeasureSupplementalDataTearOff();

  _MeasureSupplementalData call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<CodeableConcept> usage,
      String description,
      @required @JsonKey(required: true) Expression criteria}) {
    return _MeasureSupplementalData(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      usage: usage,
      description: description,
      criteria: criteria,
    );
  }
}

// ignore: unused_element
const $MeasureSupplementalData = _$MeasureSupplementalDataTearOff();

mixin _$MeasureSupplementalData {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  List<CodeableConcept> get usage;
  String get description;
  @JsonKey(required: true)
  Expression get criteria;

  Map<String, dynamic> toJson();
  $MeasureSupplementalDataCopyWith<MeasureSupplementalData> get copyWith;
}

abstract class $MeasureSupplementalDataCopyWith<$Res> {
  factory $MeasureSupplementalDataCopyWith(MeasureSupplementalData value,
          $Res Function(MeasureSupplementalData) then) =
      _$MeasureSupplementalDataCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<CodeableConcept> usage,
      String description,
      @JsonKey(required: true) Expression criteria});

  $CodeableConceptCopyWith<$Res> get code;
  $ExpressionCopyWith<$Res> get criteria;
}

class _$MeasureSupplementalDataCopyWithImpl<$Res>
    implements $MeasureSupplementalDataCopyWith<$Res> {
  _$MeasureSupplementalDataCopyWithImpl(this._value, this._then);

  final MeasureSupplementalData _value;
  // ignore: unused_field
  final $Res Function(MeasureSupplementalData) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object usage = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      usage: usage == freezed ? _value.usage : usage as List<CodeableConcept>,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get criteria {
    if (_value.criteria == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.criteria, (value) {
      return _then(_value.copyWith(criteria: value));
    });
  }
}

abstract class _$MeasureSupplementalDataCopyWith<$Res>
    implements $MeasureSupplementalDataCopyWith<$Res> {
  factory _$MeasureSupplementalDataCopyWith(_MeasureSupplementalData value,
          $Res Function(_MeasureSupplementalData) then) =
      __$MeasureSupplementalDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<CodeableConcept> usage,
      String description,
      @JsonKey(required: true) Expression criteria});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ExpressionCopyWith<$Res> get criteria;
}

class __$MeasureSupplementalDataCopyWithImpl<$Res>
    extends _$MeasureSupplementalDataCopyWithImpl<$Res>
    implements _$MeasureSupplementalDataCopyWith<$Res> {
  __$MeasureSupplementalDataCopyWithImpl(_MeasureSupplementalData _value,
      $Res Function(_MeasureSupplementalData) _then)
      : super(_value, (v) => _then(v as _MeasureSupplementalData));

  @override
  _MeasureSupplementalData get _value =>
      super._value as _MeasureSupplementalData;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object usage = freezed,
    Object description = freezed,
    Object criteria = freezed,
  }) {
    return _then(_MeasureSupplementalData(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      usage: usage == freezed ? _value.usage : usage as List<CodeableConcept>,
      description:
          description == freezed ? _value.description : description as String,
      criteria: criteria == freezed ? _value.criteria : criteria as Expression,
    ));
  }
}

@JsonSerializable()
class _$_MeasureSupplementalData implements _MeasureSupplementalData {
  const _$_MeasureSupplementalData(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.usage,
      this.description,
      @required @JsonKey(required: true) this.criteria})
      : assert(criteria != null);

  factory _$_MeasureSupplementalData.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureSupplementalDataFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final List<CodeableConcept> usage;
  @override
  final String description;
  @override
  @JsonKey(required: true)
  final Expression criteria;

  @override
  String toString() {
    return 'MeasureSupplementalData(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, usage: $usage, description: $description, criteria: $criteria)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureSupplementalData &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.usage, usage) ||
                const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.criteria, criteria) ||
                const DeepCollectionEquality()
                    .equals(other.criteria, criteria)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(criteria);

  @override
  _$MeasureSupplementalDataCopyWith<_MeasureSupplementalData> get copyWith =>
      __$MeasureSupplementalDataCopyWithImpl<_MeasureSupplementalData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureSupplementalDataToJson(this);
  }
}

abstract class _MeasureSupplementalData implements MeasureSupplementalData {
  const factory _MeasureSupplementalData(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept code,
          List<CodeableConcept> usage,
          String description,
          @required @JsonKey(required: true) Expression criteria}) =
      _$_MeasureSupplementalData;

  factory _MeasureSupplementalData.fromJson(Map<String, dynamic> json) =
      _$_MeasureSupplementalData.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  List<CodeableConcept> get usage;
  @override
  String get description;
  @override
  @JsonKey(required: true)
  Expression get criteria;
  @override
  _$MeasureSupplementalDataCopyWith<_MeasureSupplementalData> get copyWith;
}

MeasureReport _$MeasureReportFromJson(Map<String, dynamic> json) {
  return _MeasureReport.fromJson(json);
}

class _$MeasureReportTearOff {
  const _$MeasureReportTearOff();

  _MeasureReport call(
      {@required
      @JsonKey(required: true, defaultValue: 'MeasureReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
          MeasureReportStatus status,
      @JsonKey(unknownEnumValue: MeasureReportType.unknown)
          MeasureReportType type,
      @required
      @JsonKey(required: true)
          Canonical measure,
      Reference subject,
      FhirDateTime date,
      Reference reporter,
      @required
      @JsonKey(required: true)
          Period period,
      CodeableConcept improvementNotation,
      List<MeasureReportGroup> group,
      List<Reference> evaluatedResource}) {
    return _MeasureReport(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      status: status,
      type: type,
      measure: measure,
      subject: subject,
      date: date,
      reporter: reporter,
      period: period,
      improvementNotation: improvementNotation,
      group: group,
      evaluatedResource: evaluatedResource,
    );
  }
}

// ignore: unused_element
const $MeasureReport = _$MeasureReportTearOff();

mixin _$MeasureReport {
  @JsonKey(required: true, defaultValue: 'MeasureReport')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
  MeasureReportStatus get status;
  @JsonKey(unknownEnumValue: MeasureReportType.unknown)
  MeasureReportType get type;
  @JsonKey(required: true)
  Canonical get measure;
  Reference get subject;
  FhirDateTime get date;
  Reference get reporter;
  @JsonKey(required: true)
  Period get period;
  CodeableConcept get improvementNotation;
  List<MeasureReportGroup> get group;
  List<Reference> get evaluatedResource;

  Map<String, dynamic> toJson();
  $MeasureReportCopyWith<MeasureReport> get copyWith;
}

abstract class $MeasureReportCopyWith<$Res> {
  factory $MeasureReportCopyWith(
          MeasureReport value, $Res Function(MeasureReport) then) =
      _$MeasureReportCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MeasureReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
          MeasureReportStatus status,
      @JsonKey(unknownEnumValue: MeasureReportType.unknown)
          MeasureReportType type,
      @JsonKey(required: true)
          Canonical measure,
      Reference subject,
      FhirDateTime date,
      Reference reporter,
      @JsonKey(required: true)
          Period period,
      CodeableConcept improvementNotation,
      List<MeasureReportGroup> group,
      List<Reference> evaluatedResource});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $ReferenceCopyWith<$Res> get subject;
  $ReferenceCopyWith<$Res> get reporter;
  $PeriodCopyWith<$Res> get period;
  $CodeableConceptCopyWith<$Res> get improvementNotation;
}

class _$MeasureReportCopyWithImpl<$Res>
    implements $MeasureReportCopyWith<$Res> {
  _$MeasureReportCopyWithImpl(this._value, this._then);

  final MeasureReport _value;
  // ignore: unused_field
  final $Res Function(MeasureReport) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object status = freezed,
    Object type = freezed,
    Object measure = freezed,
    Object subject = freezed,
    Object date = freezed,
    Object reporter = freezed,
    Object period = freezed,
    Object improvementNotation = freezed,
    Object group = freezed,
    Object evaluatedResource = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      status: status == freezed ? _value.status : status as MeasureReportStatus,
      type: type == freezed ? _value.type : type as MeasureReportType,
      measure: measure == freezed ? _value.measure : measure as Canonical,
      subject: subject == freezed ? _value.subject : subject as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      reporter: reporter == freezed ? _value.reporter : reporter as Reference,
      period: period == freezed ? _value.period : period as Period,
      improvementNotation: improvementNotation == freezed
          ? _value.improvementNotation
          : improvementNotation as CodeableConcept,
      group:
          group == freezed ? _value.group : group as List<MeasureReportGroup>,
      evaluatedResource: evaluatedResource == freezed
          ? _value.evaluatedResource
          : evaluatedResource as List<Reference>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subject {
    if (_value.subject == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subject, (value) {
      return _then(_value.copyWith(subject: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get reporter {
    if (_value.reporter == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.reporter, (value) {
      return _then(_value.copyWith(reporter: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get period {
    if (_value.period == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.period, (value) {
      return _then(_value.copyWith(period: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get improvementNotation {
    if (_value.improvementNotation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.improvementNotation, (value) {
      return _then(_value.copyWith(improvementNotation: value));
    });
  }
}

abstract class _$MeasureReportCopyWith<$Res>
    implements $MeasureReportCopyWith<$Res> {
  factory _$MeasureReportCopyWith(
          _MeasureReport value, $Res Function(_MeasureReport) then) =
      __$MeasureReportCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MeasureReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
          MeasureReportStatus status,
      @JsonKey(unknownEnumValue: MeasureReportType.unknown)
          MeasureReportType type,
      @JsonKey(required: true)
          Canonical measure,
      Reference subject,
      FhirDateTime date,
      Reference reporter,
      @JsonKey(required: true)
          Period period,
      CodeableConcept improvementNotation,
      List<MeasureReportGroup> group,
      List<Reference> evaluatedResource});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $ReferenceCopyWith<$Res> get subject;
  @override
  $ReferenceCopyWith<$Res> get reporter;
  @override
  $PeriodCopyWith<$Res> get period;
  @override
  $CodeableConceptCopyWith<$Res> get improvementNotation;
}

class __$MeasureReportCopyWithImpl<$Res>
    extends _$MeasureReportCopyWithImpl<$Res>
    implements _$MeasureReportCopyWith<$Res> {
  __$MeasureReportCopyWithImpl(
      _MeasureReport _value, $Res Function(_MeasureReport) _then)
      : super(_value, (v) => _then(v as _MeasureReport));

  @override
  _MeasureReport get _value => super._value as _MeasureReport;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object status = freezed,
    Object type = freezed,
    Object measure = freezed,
    Object subject = freezed,
    Object date = freezed,
    Object reporter = freezed,
    Object period = freezed,
    Object improvementNotation = freezed,
    Object group = freezed,
    Object evaluatedResource = freezed,
  }) {
    return _then(_MeasureReport(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      status: status == freezed ? _value.status : status as MeasureReportStatus,
      type: type == freezed ? _value.type : type as MeasureReportType,
      measure: measure == freezed ? _value.measure : measure as Canonical,
      subject: subject == freezed ? _value.subject : subject as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      reporter: reporter == freezed ? _value.reporter : reporter as Reference,
      period: period == freezed ? _value.period : period as Period,
      improvementNotation: improvementNotation == freezed
          ? _value.improvementNotation
          : improvementNotation as CodeableConcept,
      group:
          group == freezed ? _value.group : group as List<MeasureReportGroup>,
      evaluatedResource: evaluatedResource == freezed
          ? _value.evaluatedResource
          : evaluatedResource as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReport implements _MeasureReport {
  const _$_MeasureReport(
      {@required
      @JsonKey(required: true, defaultValue: 'MeasureReport')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
          this.status,
      @JsonKey(unknownEnumValue: MeasureReportType.unknown)
          this.type,
      @required
      @JsonKey(required: true)
          this.measure,
      this.subject,
      this.date,
      this.reporter,
      @required
      @JsonKey(required: true)
          this.period,
      this.improvementNotation,
      this.group,
      this.evaluatedResource})
      : assert(resourceType != null),
        assert(measure != null),
        assert(period != null);

  factory _$_MeasureReport.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MeasureReport')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
  final MeasureReportStatus status;
  @override
  @JsonKey(unknownEnumValue: MeasureReportType.unknown)
  final MeasureReportType type;
  @override
  @JsonKey(required: true)
  final Canonical measure;
  @override
  final Reference subject;
  @override
  final FhirDateTime date;
  @override
  final Reference reporter;
  @override
  @JsonKey(required: true)
  final Period period;
  @override
  final CodeableConcept improvementNotation;
  @override
  final List<MeasureReportGroup> group;
  @override
  final List<Reference> evaluatedResource;

  @override
  String toString() {
    return 'MeasureReport(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, type: $type, measure: $measure, subject: $subject, date: $date, reporter: $reporter, period: $period, improvementNotation: $improvementNotation, group: $group, evaluatedResource: $evaluatedResource)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReport &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.measure, measure) ||
                const DeepCollectionEquality()
                    .equals(other.measure, measure)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.reporter, reporter) ||
                const DeepCollectionEquality()
                    .equals(other.reporter, reporter)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)) &&
            (identical(other.improvementNotation, improvementNotation) ||
                const DeepCollectionEquality()
                    .equals(other.improvementNotation, improvementNotation)) &&
            (identical(other.group, group) ||
                const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.evaluatedResource, evaluatedResource) ||
                const DeepCollectionEquality()
                    .equals(other.evaluatedResource, evaluatedResource)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(measure) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(reporter) ^
      const DeepCollectionEquality().hash(period) ^
      const DeepCollectionEquality().hash(improvementNotation) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(evaluatedResource);

  @override
  _$MeasureReportCopyWith<_MeasureReport> get copyWith =>
      __$MeasureReportCopyWithImpl<_MeasureReport>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportToJson(this);
  }
}

abstract class _MeasureReport implements MeasureReport {
  const factory _MeasureReport(
      {@required
      @JsonKey(required: true, defaultValue: 'MeasureReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
          MeasureReportStatus status,
      @JsonKey(unknownEnumValue: MeasureReportType.unknown)
          MeasureReportType type,
      @required
      @JsonKey(required: true)
          Canonical measure,
      Reference subject,
      FhirDateTime date,
      Reference reporter,
      @required
      @JsonKey(required: true)
          Period period,
      CodeableConcept improvementNotation,
      List<MeasureReportGroup> group,
      List<Reference> evaluatedResource}) = _$_MeasureReport;

  factory _MeasureReport.fromJson(Map<String, dynamic> json) =
      _$_MeasureReport.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MeasureReport')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  @JsonKey(unknownEnumValue: MeasureReportStatus.unknown)
  MeasureReportStatus get status;
  @override
  @JsonKey(unknownEnumValue: MeasureReportType.unknown)
  MeasureReportType get type;
  @override
  @JsonKey(required: true)
  Canonical get measure;
  @override
  Reference get subject;
  @override
  FhirDateTime get date;
  @override
  Reference get reporter;
  @override
  @JsonKey(required: true)
  Period get period;
  @override
  CodeableConcept get improvementNotation;
  @override
  List<MeasureReportGroup> get group;
  @override
  List<Reference> get evaluatedResource;
  @override
  _$MeasureReportCopyWith<_MeasureReport> get copyWith;
}

MeasureReportGroup _$MeasureReportGroupFromJson(Map<String, dynamic> json) {
  return _MeasureReportGroup.fromJson(json);
}

class _$MeasureReportGroupTearOff {
  const _$MeasureReportGroupTearOff();

  _MeasureReportGroup call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<MeasureReportPopulation> population,
      Quantity measureScore,
      List<MeasureReportStratifier> stratifier}) {
    return _MeasureReportGroup(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      population: population,
      measureScore: measureScore,
      stratifier: stratifier,
    );
  }
}

// ignore: unused_element
const $MeasureReportGroup = _$MeasureReportGroupTearOff();

mixin _$MeasureReportGroup {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  List<MeasureReportPopulation> get population;
  Quantity get measureScore;
  List<MeasureReportStratifier> get stratifier;

  Map<String, dynamic> toJson();
  $MeasureReportGroupCopyWith<MeasureReportGroup> get copyWith;
}

abstract class $MeasureReportGroupCopyWith<$Res> {
  factory $MeasureReportGroupCopyWith(
          MeasureReportGroup value, $Res Function(MeasureReportGroup) then) =
      _$MeasureReportGroupCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<MeasureReportPopulation> population,
      Quantity measureScore,
      List<MeasureReportStratifier> stratifier});

  $CodeableConceptCopyWith<$Res> get code;
  $QuantityCopyWith<$Res> get measureScore;
}

class _$MeasureReportGroupCopyWithImpl<$Res>
    implements $MeasureReportGroupCopyWith<$Res> {
  _$MeasureReportGroupCopyWithImpl(this._value, this._then);

  final MeasureReportGroup _value;
  // ignore: unused_field
  final $Res Function(MeasureReportGroup) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object population = freezed,
    Object measureScore = freezed,
    Object stratifier = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      population: population == freezed
          ? _value.population
          : population as List<MeasureReportPopulation>,
      measureScore: measureScore == freezed
          ? _value.measureScore
          : measureScore as Quantity,
      stratifier: stratifier == freezed
          ? _value.stratifier
          : stratifier as List<MeasureReportStratifier>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get measureScore {
    if (_value.measureScore == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.measureScore, (value) {
      return _then(_value.copyWith(measureScore: value));
    });
  }
}

abstract class _$MeasureReportGroupCopyWith<$Res>
    implements $MeasureReportGroupCopyWith<$Res> {
  factory _$MeasureReportGroupCopyWith(
          _MeasureReportGroup value, $Res Function(_MeasureReportGroup) then) =
      __$MeasureReportGroupCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<MeasureReportPopulation> population,
      Quantity measureScore,
      List<MeasureReportStratifier> stratifier});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $QuantityCopyWith<$Res> get measureScore;
}

class __$MeasureReportGroupCopyWithImpl<$Res>
    extends _$MeasureReportGroupCopyWithImpl<$Res>
    implements _$MeasureReportGroupCopyWith<$Res> {
  __$MeasureReportGroupCopyWithImpl(
      _MeasureReportGroup _value, $Res Function(_MeasureReportGroup) _then)
      : super(_value, (v) => _then(v as _MeasureReportGroup));

  @override
  _MeasureReportGroup get _value => super._value as _MeasureReportGroup;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object population = freezed,
    Object measureScore = freezed,
    Object stratifier = freezed,
  }) {
    return _then(_MeasureReportGroup(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      population: population == freezed
          ? _value.population
          : population as List<MeasureReportPopulation>,
      measureScore: measureScore == freezed
          ? _value.measureScore
          : measureScore as Quantity,
      stratifier: stratifier == freezed
          ? _value.stratifier
          : stratifier as List<MeasureReportStratifier>,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportGroup implements _MeasureReportGroup {
  const _$_MeasureReportGroup(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.population,
      this.measureScore,
      this.stratifier});

  factory _$_MeasureReportGroup.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportGroupFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final List<MeasureReportPopulation> population;
  @override
  final Quantity measureScore;
  @override
  final List<MeasureReportStratifier> stratifier;

  @override
  String toString() {
    return 'MeasureReportGroup(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, population: $population, measureScore: $measureScore, stratifier: $stratifier)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportGroup &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)) &&
            (identical(other.measureScore, measureScore) ||
                const DeepCollectionEquality()
                    .equals(other.measureScore, measureScore)) &&
            (identical(other.stratifier, stratifier) ||
                const DeepCollectionEquality()
                    .equals(other.stratifier, stratifier)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(measureScore) ^
      const DeepCollectionEquality().hash(stratifier);

  @override
  _$MeasureReportGroupCopyWith<_MeasureReportGroup> get copyWith =>
      __$MeasureReportGroupCopyWithImpl<_MeasureReportGroup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportGroupToJson(this);
  }
}

abstract class _MeasureReportGroup implements MeasureReportGroup {
  const factory _MeasureReportGroup(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      List<MeasureReportPopulation> population,
      Quantity measureScore,
      List<MeasureReportStratifier> stratifier}) = _$_MeasureReportGroup;

  factory _MeasureReportGroup.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportGroup.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  List<MeasureReportPopulation> get population;
  @override
  Quantity get measureScore;
  @override
  List<MeasureReportStratifier> get stratifier;
  @override
  _$MeasureReportGroupCopyWith<_MeasureReportGroup> get copyWith;
}

MeasureReportPopulation _$MeasureReportPopulationFromJson(
    Map<String, dynamic> json) {
  return _MeasureReportPopulation.fromJson(json);
}

class _$MeasureReportPopulationTearOff {
  const _$MeasureReportPopulationTearOff();

  _MeasureReportPopulation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults}) {
    return _MeasureReportPopulation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      count: count,
      subjectResults: subjectResults,
    );
  }
}

// ignore: unused_element
const $MeasureReportPopulation = _$MeasureReportPopulationTearOff();

mixin _$MeasureReportPopulation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  Integer get count;
  Reference get subjectResults;

  Map<String, dynamic> toJson();
  $MeasureReportPopulationCopyWith<MeasureReportPopulation> get copyWith;
}

abstract class $MeasureReportPopulationCopyWith<$Res> {
  factory $MeasureReportPopulationCopyWith(MeasureReportPopulation value,
          $Res Function(MeasureReportPopulation) then) =
      _$MeasureReportPopulationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults});

  $CodeableConceptCopyWith<$Res> get code;
  $ReferenceCopyWith<$Res> get subjectResults;
}

class _$MeasureReportPopulationCopyWithImpl<$Res>
    implements $MeasureReportPopulationCopyWith<$Res> {
  _$MeasureReportPopulationCopyWithImpl(this._value, this._then);

  final MeasureReportPopulation _value;
  // ignore: unused_field
  final $Res Function(MeasureReportPopulation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object count = freezed,
    Object subjectResults = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      count: count == freezed ? _value.count : count as Integer,
      subjectResults: subjectResults == freezed
          ? _value.subjectResults
          : subjectResults as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectResults {
    if (_value.subjectResults == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectResults, (value) {
      return _then(_value.copyWith(subjectResults: value));
    });
  }
}

abstract class _$MeasureReportPopulationCopyWith<$Res>
    implements $MeasureReportPopulationCopyWith<$Res> {
  factory _$MeasureReportPopulationCopyWith(_MeasureReportPopulation value,
          $Res Function(_MeasureReportPopulation) then) =
      __$MeasureReportPopulationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ReferenceCopyWith<$Res> get subjectResults;
}

class __$MeasureReportPopulationCopyWithImpl<$Res>
    extends _$MeasureReportPopulationCopyWithImpl<$Res>
    implements _$MeasureReportPopulationCopyWith<$Res> {
  __$MeasureReportPopulationCopyWithImpl(_MeasureReportPopulation _value,
      $Res Function(_MeasureReportPopulation) _then)
      : super(_value, (v) => _then(v as _MeasureReportPopulation));

  @override
  _MeasureReportPopulation get _value =>
      super._value as _MeasureReportPopulation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object count = freezed,
    Object subjectResults = freezed,
  }) {
    return _then(_MeasureReportPopulation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      count: count == freezed ? _value.count : count as Integer,
      subjectResults: subjectResults == freezed
          ? _value.subjectResults
          : subjectResults as Reference,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportPopulation implements _MeasureReportPopulation {
  const _$_MeasureReportPopulation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.count,
      this.subjectResults});

  factory _$_MeasureReportPopulation.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportPopulationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final Integer count;
  @override
  final Reference subjectResults;

  @override
  String toString() {
    return 'MeasureReportPopulation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, count: $count, subjectResults: $subjectResults)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportPopulation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.subjectResults, subjectResults) ||
                const DeepCollectionEquality()
                    .equals(other.subjectResults, subjectResults)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(subjectResults);

  @override
  _$MeasureReportPopulationCopyWith<_MeasureReportPopulation> get copyWith =>
      __$MeasureReportPopulationCopyWithImpl<_MeasureReportPopulation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportPopulationToJson(this);
  }
}

abstract class _MeasureReportPopulation implements MeasureReportPopulation {
  const factory _MeasureReportPopulation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults}) = _$_MeasureReportPopulation;

  factory _MeasureReportPopulation.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportPopulation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  Integer get count;
  @override
  Reference get subjectResults;
  @override
  _$MeasureReportPopulationCopyWith<_MeasureReportPopulation> get copyWith;
}

MeasureReportStratifier _$MeasureReportStratifierFromJson(
    Map<String, dynamic> json) {
  return _MeasureReportStratifier.fromJson(json);
}

class _$MeasureReportStratifierTearOff {
  const _$MeasureReportStratifierTearOff();

  _MeasureReportStratifier call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> code,
      List<MeasureReportStratum> stratum}) {
    return _MeasureReportStratifier(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      stratum: stratum,
    );
  }
}

// ignore: unused_element
const $MeasureReportStratifier = _$MeasureReportStratifierTearOff();

mixin _$MeasureReportStratifier {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<CodeableConcept> get code;
  List<MeasureReportStratum> get stratum;

  Map<String, dynamic> toJson();
  $MeasureReportStratifierCopyWith<MeasureReportStratifier> get copyWith;
}

abstract class $MeasureReportStratifierCopyWith<$Res> {
  factory $MeasureReportStratifierCopyWith(MeasureReportStratifier value,
          $Res Function(MeasureReportStratifier) then) =
      _$MeasureReportStratifierCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> code,
      List<MeasureReportStratum> stratum});
}

class _$MeasureReportStratifierCopyWithImpl<$Res>
    implements $MeasureReportStratifierCopyWith<$Res> {
  _$MeasureReportStratifierCopyWithImpl(this._value, this._then);

  final MeasureReportStratifier _value;
  // ignore: unused_field
  final $Res Function(MeasureReportStratifier) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object stratum = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as List<CodeableConcept>,
      stratum: stratum == freezed
          ? _value.stratum
          : stratum as List<MeasureReportStratum>,
    ));
  }
}

abstract class _$MeasureReportStratifierCopyWith<$Res>
    implements $MeasureReportStratifierCopyWith<$Res> {
  factory _$MeasureReportStratifierCopyWith(_MeasureReportStratifier value,
          $Res Function(_MeasureReportStratifier) then) =
      __$MeasureReportStratifierCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> code,
      List<MeasureReportStratum> stratum});
}

class __$MeasureReportStratifierCopyWithImpl<$Res>
    extends _$MeasureReportStratifierCopyWithImpl<$Res>
    implements _$MeasureReportStratifierCopyWith<$Res> {
  __$MeasureReportStratifierCopyWithImpl(_MeasureReportStratifier _value,
      $Res Function(_MeasureReportStratifier) _then)
      : super(_value, (v) => _then(v as _MeasureReportStratifier));

  @override
  _MeasureReportStratifier get _value =>
      super._value as _MeasureReportStratifier;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object stratum = freezed,
  }) {
    return _then(_MeasureReportStratifier(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as List<CodeableConcept>,
      stratum: stratum == freezed
          ? _value.stratum
          : stratum as List<MeasureReportStratum>,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportStratifier implements _MeasureReportStratifier {
  const _$_MeasureReportStratifier(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.stratum});

  factory _$_MeasureReportStratifier.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportStratifierFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<CodeableConcept> code;
  @override
  final List<MeasureReportStratum> stratum;

  @override
  String toString() {
    return 'MeasureReportStratifier(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, stratum: $stratum)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportStratifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.stratum, stratum) ||
                const DeepCollectionEquality().equals(other.stratum, stratum)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(stratum);

  @override
  _$MeasureReportStratifierCopyWith<_MeasureReportStratifier> get copyWith =>
      __$MeasureReportStratifierCopyWithImpl<_MeasureReportStratifier>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportStratifierToJson(this);
  }
}

abstract class _MeasureReportStratifier implements MeasureReportStratifier {
  const factory _MeasureReportStratifier(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> code,
      List<MeasureReportStratum> stratum}) = _$_MeasureReportStratifier;

  factory _MeasureReportStratifier.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportStratifier.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<CodeableConcept> get code;
  @override
  List<MeasureReportStratum> get stratum;
  @override
  _$MeasureReportStratifierCopyWith<_MeasureReportStratifier> get copyWith;
}

MeasureReportStratum _$MeasureReportStratumFromJson(Map<String, dynamic> json) {
  return _MeasureReportStratum.fromJson(json);
}

class _$MeasureReportStratumTearOff {
  const _$MeasureReportStratumTearOff();

  _MeasureReportStratum call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept value,
      List<MeasureReportComponent> component,
      List<MeasureReportPopulation1> population,
      Quantity measureScore}) {
    return _MeasureReportStratum(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      value: value,
      component: component,
      population: population,
      measureScore: measureScore,
    );
  }
}

// ignore: unused_element
const $MeasureReportStratum = _$MeasureReportStratumTearOff();

mixin _$MeasureReportStratum {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get value;
  List<MeasureReportComponent> get component;
  List<MeasureReportPopulation1> get population;
  Quantity get measureScore;

  Map<String, dynamic> toJson();
  $MeasureReportStratumCopyWith<MeasureReportStratum> get copyWith;
}

abstract class $MeasureReportStratumCopyWith<$Res> {
  factory $MeasureReportStratumCopyWith(MeasureReportStratum value,
          $Res Function(MeasureReportStratum) then) =
      _$MeasureReportStratumCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept value,
      List<MeasureReportComponent> component,
      List<MeasureReportPopulation1> population,
      Quantity measureScore});

  $CodeableConceptCopyWith<$Res> get value;
  $QuantityCopyWith<$Res> get measureScore;
}

class _$MeasureReportStratumCopyWithImpl<$Res>
    implements $MeasureReportStratumCopyWith<$Res> {
  _$MeasureReportStratumCopyWithImpl(this._value, this._then);

  final MeasureReportStratum _value;
  // ignore: unused_field
  final $Res Function(MeasureReportStratum) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object value = freezed,
    Object component = freezed,
    Object population = freezed,
    Object measureScore = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      value: value == freezed ? _value.value : value as CodeableConcept,
      component: component == freezed
          ? _value.component
          : component as List<MeasureReportComponent>,
      population: population == freezed
          ? _value.population
          : population as List<MeasureReportPopulation1>,
      measureScore: measureScore == freezed
          ? _value.measureScore
          : measureScore as Quantity,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get value {
    if (_value.value == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get measureScore {
    if (_value.measureScore == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.measureScore, (value) {
      return _then(_value.copyWith(measureScore: value));
    });
  }
}

abstract class _$MeasureReportStratumCopyWith<$Res>
    implements $MeasureReportStratumCopyWith<$Res> {
  factory _$MeasureReportStratumCopyWith(_MeasureReportStratum value,
          $Res Function(_MeasureReportStratum) then) =
      __$MeasureReportStratumCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept value,
      List<MeasureReportComponent> component,
      List<MeasureReportPopulation1> population,
      Quantity measureScore});

  @override
  $CodeableConceptCopyWith<$Res> get value;
  @override
  $QuantityCopyWith<$Res> get measureScore;
}

class __$MeasureReportStratumCopyWithImpl<$Res>
    extends _$MeasureReportStratumCopyWithImpl<$Res>
    implements _$MeasureReportStratumCopyWith<$Res> {
  __$MeasureReportStratumCopyWithImpl(
      _MeasureReportStratum _value, $Res Function(_MeasureReportStratum) _then)
      : super(_value, (v) => _then(v as _MeasureReportStratum));

  @override
  _MeasureReportStratum get _value => super._value as _MeasureReportStratum;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object value = freezed,
    Object component = freezed,
    Object population = freezed,
    Object measureScore = freezed,
  }) {
    return _then(_MeasureReportStratum(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      value: value == freezed ? _value.value : value as CodeableConcept,
      component: component == freezed
          ? _value.component
          : component as List<MeasureReportComponent>,
      population: population == freezed
          ? _value.population
          : population as List<MeasureReportPopulation1>,
      measureScore: measureScore == freezed
          ? _value.measureScore
          : measureScore as Quantity,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportStratum implements _MeasureReportStratum {
  const _$_MeasureReportStratum(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.value,
      this.component,
      this.population,
      this.measureScore});

  factory _$_MeasureReportStratum.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportStratumFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept value;
  @override
  final List<MeasureReportComponent> component;
  @override
  final List<MeasureReportPopulation1> population;
  @override
  final Quantity measureScore;

  @override
  String toString() {
    return 'MeasureReportStratum(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, value: $value, component: $component, population: $population, measureScore: $measureScore)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportStratum &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.component, component) ||
                const DeepCollectionEquality()
                    .equals(other.component, component)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)) &&
            (identical(other.measureScore, measureScore) ||
                const DeepCollectionEquality()
                    .equals(other.measureScore, measureScore)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(component) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(measureScore);

  @override
  _$MeasureReportStratumCopyWith<_MeasureReportStratum> get copyWith =>
      __$MeasureReportStratumCopyWithImpl<_MeasureReportStratum>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportStratumToJson(this);
  }
}

abstract class _MeasureReportStratum implements MeasureReportStratum {
  const factory _MeasureReportStratum(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept value,
      List<MeasureReportComponent> component,
      List<MeasureReportPopulation1> population,
      Quantity measureScore}) = _$_MeasureReportStratum;

  factory _MeasureReportStratum.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportStratum.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get value;
  @override
  List<MeasureReportComponent> get component;
  @override
  List<MeasureReportPopulation1> get population;
  @override
  Quantity get measureScore;
  @override
  _$MeasureReportStratumCopyWith<_MeasureReportStratum> get copyWith;
}

MeasureReportComponent _$MeasureReportComponentFromJson(
    Map<String, dynamic> json) {
  return _MeasureReportComponent.fromJson(json);
}

class _$MeasureReportComponentTearOff {
  const _$MeasureReportComponentTearOff();

  _MeasureReportComponent call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      @required @JsonKey(required: true) CodeableConcept value}) {
    return _MeasureReportComponent(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      value: value,
    );
  }
}

// ignore: unused_element
const $MeasureReportComponent = _$MeasureReportComponentTearOff();

mixin _$MeasureReportComponent {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  @JsonKey(required: true)
  CodeableConcept get value;

  Map<String, dynamic> toJson();
  $MeasureReportComponentCopyWith<MeasureReportComponent> get copyWith;
}

abstract class $MeasureReportComponentCopyWith<$Res> {
  factory $MeasureReportComponentCopyWith(MeasureReportComponent value,
          $Res Function(MeasureReportComponent) then) =
      _$MeasureReportComponentCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      @JsonKey(required: true) CodeableConcept value});

  $CodeableConceptCopyWith<$Res> get code;
  $CodeableConceptCopyWith<$Res> get value;
}

class _$MeasureReportComponentCopyWithImpl<$Res>
    implements $MeasureReportComponentCopyWith<$Res> {
  _$MeasureReportComponentCopyWithImpl(this._value, this._then);

  final MeasureReportComponent _value;
  // ignore: unused_field
  final $Res Function(MeasureReportComponent) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object value = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      value: value == freezed ? _value.value : value as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get value {
    if (_value.value == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

abstract class _$MeasureReportComponentCopyWith<$Res>
    implements $MeasureReportComponentCopyWith<$Res> {
  factory _$MeasureReportComponentCopyWith(_MeasureReportComponent value,
          $Res Function(_MeasureReportComponent) then) =
      __$MeasureReportComponentCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      @JsonKey(required: true) CodeableConcept value});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $CodeableConceptCopyWith<$Res> get value;
}

class __$MeasureReportComponentCopyWithImpl<$Res>
    extends _$MeasureReportComponentCopyWithImpl<$Res>
    implements _$MeasureReportComponentCopyWith<$Res> {
  __$MeasureReportComponentCopyWithImpl(_MeasureReportComponent _value,
      $Res Function(_MeasureReportComponent) _then)
      : super(_value, (v) => _then(v as _MeasureReportComponent));

  @override
  _MeasureReportComponent get _value => super._value as _MeasureReportComponent;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object value = freezed,
  }) {
    return _then(_MeasureReportComponent(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      value: value == freezed ? _value.value : value as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportComponent implements _MeasureReportComponent {
  const _$_MeasureReportComponent(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      @required @JsonKey(required: true) this.value})
      : assert(code != null),
        assert(value != null);

  factory _$_MeasureReportComponent.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportComponentFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  @JsonKey(required: true)
  final CodeableConcept value;

  @override
  String toString() {
    return 'MeasureReportComponent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportComponent &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(value);

  @override
  _$MeasureReportComponentCopyWith<_MeasureReportComponent> get copyWith =>
      __$MeasureReportComponentCopyWithImpl<_MeasureReportComponent>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportComponentToJson(this);
  }
}

abstract class _MeasureReportComponent implements MeasureReportComponent {
  const factory _MeasureReportComponent(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept code,
          @required @JsonKey(required: true) CodeableConcept value}) =
      _$_MeasureReportComponent;

  factory _MeasureReportComponent.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportComponent.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  @JsonKey(required: true)
  CodeableConcept get value;
  @override
  _$MeasureReportComponentCopyWith<_MeasureReportComponent> get copyWith;
}

MeasureReportPopulation1 _$MeasureReportPopulation1FromJson(
    Map<String, dynamic> json) {
  return _MeasureReportPopulation1.fromJson(json);
}

class _$MeasureReportPopulation1TearOff {
  const _$MeasureReportPopulation1TearOff();

  _MeasureReportPopulation1 call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults}) {
    return _MeasureReportPopulation1(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      count: count,
      subjectResults: subjectResults,
    );
  }
}

// ignore: unused_element
const $MeasureReportPopulation1 = _$MeasureReportPopulation1TearOff();

mixin _$MeasureReportPopulation1 {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  Integer get count;
  Reference get subjectResults;

  Map<String, dynamic> toJson();
  $MeasureReportPopulation1CopyWith<MeasureReportPopulation1> get copyWith;
}

abstract class $MeasureReportPopulation1CopyWith<$Res> {
  factory $MeasureReportPopulation1CopyWith(MeasureReportPopulation1 value,
          $Res Function(MeasureReportPopulation1) then) =
      _$MeasureReportPopulation1CopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults});

  $CodeableConceptCopyWith<$Res> get code;
  $ReferenceCopyWith<$Res> get subjectResults;
}

class _$MeasureReportPopulation1CopyWithImpl<$Res>
    implements $MeasureReportPopulation1CopyWith<$Res> {
  _$MeasureReportPopulation1CopyWithImpl(this._value, this._then);

  final MeasureReportPopulation1 _value;
  // ignore: unused_field
  final $Res Function(MeasureReportPopulation1) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object count = freezed,
    Object subjectResults = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      count: count == freezed ? _value.count : count as Integer,
      subjectResults: subjectResults == freezed
          ? _value.subjectResults
          : subjectResults as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectResults {
    if (_value.subjectResults == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectResults, (value) {
      return _then(_value.copyWith(subjectResults: value));
    });
  }
}

abstract class _$MeasureReportPopulation1CopyWith<$Res>
    implements $MeasureReportPopulation1CopyWith<$Res> {
  factory _$MeasureReportPopulation1CopyWith(_MeasureReportPopulation1 value,
          $Res Function(_MeasureReportPopulation1) then) =
      __$MeasureReportPopulation1CopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ReferenceCopyWith<$Res> get subjectResults;
}

class __$MeasureReportPopulation1CopyWithImpl<$Res>
    extends _$MeasureReportPopulation1CopyWithImpl<$Res>
    implements _$MeasureReportPopulation1CopyWith<$Res> {
  __$MeasureReportPopulation1CopyWithImpl(_MeasureReportPopulation1 _value,
      $Res Function(_MeasureReportPopulation1) _then)
      : super(_value, (v) => _then(v as _MeasureReportPopulation1));

  @override
  _MeasureReportPopulation1 get _value =>
      super._value as _MeasureReportPopulation1;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object count = freezed,
    Object subjectResults = freezed,
  }) {
    return _then(_MeasureReportPopulation1(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      count: count == freezed ? _value.count : count as Integer,
      subjectResults: subjectResults == freezed
          ? _value.subjectResults
          : subjectResults as Reference,
    ));
  }
}

@JsonSerializable()
class _$_MeasureReportPopulation1 implements _MeasureReportPopulation1 {
  const _$_MeasureReportPopulation1(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.count,
      this.subjectResults});

  factory _$_MeasureReportPopulation1.fromJson(Map<String, dynamic> json) =>
      _$_$_MeasureReportPopulation1FromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final Integer count;
  @override
  final Reference subjectResults;

  @override
  String toString() {
    return 'MeasureReportPopulation1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, count: $count, subjectResults: $subjectResults)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MeasureReportPopulation1 &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.subjectResults, subjectResults) ||
                const DeepCollectionEquality()
                    .equals(other.subjectResults, subjectResults)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(subjectResults);

  @override
  _$MeasureReportPopulation1CopyWith<_MeasureReportPopulation1> get copyWith =>
      __$MeasureReportPopulation1CopyWithImpl<_MeasureReportPopulation1>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MeasureReportPopulation1ToJson(this);
  }
}

abstract class _MeasureReportPopulation1 implements MeasureReportPopulation1 {
  const factory _MeasureReportPopulation1(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      Integer count,
      Reference subjectResults}) = _$_MeasureReportPopulation1;

  factory _MeasureReportPopulation1.fromJson(Map<String, dynamic> json) =
      _$_MeasureReportPopulation1.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  Integer get count;
  @override
  Reference get subjectResults;
  @override
  _$MeasureReportPopulation1CopyWith<_MeasureReportPopulation1> get copyWith;
}

MedicinalProduct _$MedicinalProductFromJson(Map<String, dynamic> json) {
  return _MedicinalProduct.fromJson(json);
}

class _$MedicinalProductTearOff {
  const _$MedicinalProductTearOff();

  _MedicinalProduct call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProduct')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      Coding domain,
      CodeableConcept combinedPharmaceuticalDoseForm,
      CodeableConcept legalStatusOfSupply,
      CodeableConcept additionalMonitoringIndicator,
      List<String> specialMeasures,
      CodeableConcept paediatricUseIndicator,
      List<CodeableConcept> productClassification,
      List<MarketingStatus> marketingStatus,
      List<Reference> pharmaceuticalProduct,
      List<Reference> packagedMedicinalProduct,
      List<Reference> attachedDocument,
      List<Reference> masterFile,
      List<Reference> contact,
      List<Reference> clinicalTrial,
      @required
      @JsonKey(required: true)
          List<MedicinalProductName> name,
      List<Identifier> crossReference,
      List<MedicinalProductManufacturingBusinessOperation>
          manufacturingBusinessOperation,
      List<MedicinalProductSpecialDesignation> specialDesignation}) {
    return _MedicinalProduct(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      type: type,
      domain: domain,
      combinedPharmaceuticalDoseForm: combinedPharmaceuticalDoseForm,
      legalStatusOfSupply: legalStatusOfSupply,
      additionalMonitoringIndicator: additionalMonitoringIndicator,
      specialMeasures: specialMeasures,
      paediatricUseIndicator: paediatricUseIndicator,
      productClassification: productClassification,
      marketingStatus: marketingStatus,
      pharmaceuticalProduct: pharmaceuticalProduct,
      packagedMedicinalProduct: packagedMedicinalProduct,
      attachedDocument: attachedDocument,
      masterFile: masterFile,
      contact: contact,
      clinicalTrial: clinicalTrial,
      name: name,
      crossReference: crossReference,
      manufacturingBusinessOperation: manufacturingBusinessOperation,
      specialDesignation: specialDesignation,
    );
  }
}

// ignore: unused_element
const $MedicinalProduct = _$MedicinalProductTearOff();

mixin _$MedicinalProduct {
  @JsonKey(required: true, defaultValue: 'MedicinalProduct')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  CodeableConcept get type;
  Coding get domain;
  CodeableConcept get combinedPharmaceuticalDoseForm;
  CodeableConcept get legalStatusOfSupply;
  CodeableConcept get additionalMonitoringIndicator;
  List<String> get specialMeasures;
  CodeableConcept get paediatricUseIndicator;
  List<CodeableConcept> get productClassification;
  List<MarketingStatus> get marketingStatus;
  List<Reference> get pharmaceuticalProduct;
  List<Reference> get packagedMedicinalProduct;
  List<Reference> get attachedDocument;
  List<Reference> get masterFile;
  List<Reference> get contact;
  List<Reference> get clinicalTrial;
  @JsonKey(required: true)
  List<MedicinalProductName> get name;
  List<Identifier> get crossReference;
  List<MedicinalProductManufacturingBusinessOperation>
      get manufacturingBusinessOperation;
  List<MedicinalProductSpecialDesignation> get specialDesignation;

  Map<String, dynamic> toJson();
  $MedicinalProductCopyWith<MedicinalProduct> get copyWith;
}

abstract class $MedicinalProductCopyWith<$Res> {
  factory $MedicinalProductCopyWith(
          MedicinalProduct value, $Res Function(MedicinalProduct) then) =
      _$MedicinalProductCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProduct')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      Coding domain,
      CodeableConcept combinedPharmaceuticalDoseForm,
      CodeableConcept legalStatusOfSupply,
      CodeableConcept additionalMonitoringIndicator,
      List<String> specialMeasures,
      CodeableConcept paediatricUseIndicator,
      List<CodeableConcept> productClassification,
      List<MarketingStatus> marketingStatus,
      List<Reference> pharmaceuticalProduct,
      List<Reference> packagedMedicinalProduct,
      List<Reference> attachedDocument,
      List<Reference> masterFile,
      List<Reference> contact,
      List<Reference> clinicalTrial,
      @JsonKey(required: true)
          List<MedicinalProductName> name,
      List<Identifier> crossReference,
      List<MedicinalProductManufacturingBusinessOperation>
          manufacturingBusinessOperation,
      List<MedicinalProductSpecialDesignation> specialDesignation});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get type;
  $CodingCopyWith<$Res> get domain;
  $CodeableConceptCopyWith<$Res> get combinedPharmaceuticalDoseForm;
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  $CodeableConceptCopyWith<$Res> get additionalMonitoringIndicator;
  $CodeableConceptCopyWith<$Res> get paediatricUseIndicator;
}

class _$MedicinalProductCopyWithImpl<$Res>
    implements $MedicinalProductCopyWith<$Res> {
  _$MedicinalProductCopyWithImpl(this._value, this._then);

  final MedicinalProduct _value;
  // ignore: unused_field
  final $Res Function(MedicinalProduct) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object domain = freezed,
    Object combinedPharmaceuticalDoseForm = freezed,
    Object legalStatusOfSupply = freezed,
    Object additionalMonitoringIndicator = freezed,
    Object specialMeasures = freezed,
    Object paediatricUseIndicator = freezed,
    Object productClassification = freezed,
    Object marketingStatus = freezed,
    Object pharmaceuticalProduct = freezed,
    Object packagedMedicinalProduct = freezed,
    Object attachedDocument = freezed,
    Object masterFile = freezed,
    Object contact = freezed,
    Object clinicalTrial = freezed,
    Object name = freezed,
    Object crossReference = freezed,
    Object manufacturingBusinessOperation = freezed,
    Object specialDesignation = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      domain: domain == freezed ? _value.domain : domain as Coding,
      combinedPharmaceuticalDoseForm: combinedPharmaceuticalDoseForm == freezed
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm as CodeableConcept,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      additionalMonitoringIndicator: additionalMonitoringIndicator == freezed
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator as CodeableConcept,
      specialMeasures: specialMeasures == freezed
          ? _value.specialMeasures
          : specialMeasures as List<String>,
      paediatricUseIndicator: paediatricUseIndicator == freezed
          ? _value.paediatricUseIndicator
          : paediatricUseIndicator as CodeableConcept,
      productClassification: productClassification == freezed
          ? _value.productClassification
          : productClassification as List<CodeableConcept>,
      marketingStatus: marketingStatus == freezed
          ? _value.marketingStatus
          : marketingStatus as List<MarketingStatus>,
      pharmaceuticalProduct: pharmaceuticalProduct == freezed
          ? _value.pharmaceuticalProduct
          : pharmaceuticalProduct as List<Reference>,
      packagedMedicinalProduct: packagedMedicinalProduct == freezed
          ? _value.packagedMedicinalProduct
          : packagedMedicinalProduct as List<Reference>,
      attachedDocument: attachedDocument == freezed
          ? _value.attachedDocument
          : attachedDocument as List<Reference>,
      masterFile: masterFile == freezed
          ? _value.masterFile
          : masterFile as List<Reference>,
      contact: contact == freezed ? _value.contact : contact as List<Reference>,
      clinicalTrial: clinicalTrial == freezed
          ? _value.clinicalTrial
          : clinicalTrial as List<Reference>,
      name: name == freezed ? _value.name : name as List<MedicinalProductName>,
      crossReference: crossReference == freezed
          ? _value.crossReference
          : crossReference as List<Identifier>,
      manufacturingBusinessOperation: manufacturingBusinessOperation == freezed
          ? _value.manufacturingBusinessOperation
          : manufacturingBusinessOperation
              as List<MedicinalProductManufacturingBusinessOperation>,
      specialDesignation: specialDesignation == freezed
          ? _value.specialDesignation
          : specialDesignation as List<MedicinalProductSpecialDesignation>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodingCopyWith<$Res> get domain {
    if (_value.domain == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.domain, (value) {
      return _then(_value.copyWith(domain: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get combinedPharmaceuticalDoseForm {
    if (_value.combinedPharmaceuticalDoseForm == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.combinedPharmaceuticalDoseForm,
        (value) {
      return _then(_value.copyWith(combinedPharmaceuticalDoseForm: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply {
    if (_value.legalStatusOfSupply == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.legalStatusOfSupply, (value) {
      return _then(_value.copyWith(legalStatusOfSupply: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get additionalMonitoringIndicator {
    if (_value.additionalMonitoringIndicator == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.additionalMonitoringIndicator,
        (value) {
      return _then(_value.copyWith(additionalMonitoringIndicator: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get paediatricUseIndicator {
    if (_value.paediatricUseIndicator == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.paediatricUseIndicator,
        (value) {
      return _then(_value.copyWith(paediatricUseIndicator: value));
    });
  }
}

abstract class _$MedicinalProductCopyWith<$Res>
    implements $MedicinalProductCopyWith<$Res> {
  factory _$MedicinalProductCopyWith(
          _MedicinalProduct value, $Res Function(_MedicinalProduct) then) =
      __$MedicinalProductCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProduct')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      Coding domain,
      CodeableConcept combinedPharmaceuticalDoseForm,
      CodeableConcept legalStatusOfSupply,
      CodeableConcept additionalMonitoringIndicator,
      List<String> specialMeasures,
      CodeableConcept paediatricUseIndicator,
      List<CodeableConcept> productClassification,
      List<MarketingStatus> marketingStatus,
      List<Reference> pharmaceuticalProduct,
      List<Reference> packagedMedicinalProduct,
      List<Reference> attachedDocument,
      List<Reference> masterFile,
      List<Reference> contact,
      List<Reference> clinicalTrial,
      @JsonKey(required: true)
          List<MedicinalProductName> name,
      List<Identifier> crossReference,
      List<MedicinalProductManufacturingBusinessOperation>
          manufacturingBusinessOperation,
      List<MedicinalProductSpecialDesignation> specialDesignation});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodingCopyWith<$Res> get domain;
  @override
  $CodeableConceptCopyWith<$Res> get combinedPharmaceuticalDoseForm;
  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  @override
  $CodeableConceptCopyWith<$Res> get additionalMonitoringIndicator;
  @override
  $CodeableConceptCopyWith<$Res> get paediatricUseIndicator;
}

class __$MedicinalProductCopyWithImpl<$Res>
    extends _$MedicinalProductCopyWithImpl<$Res>
    implements _$MedicinalProductCopyWith<$Res> {
  __$MedicinalProductCopyWithImpl(
      _MedicinalProduct _value, $Res Function(_MedicinalProduct) _then)
      : super(_value, (v) => _then(v as _MedicinalProduct));

  @override
  _MedicinalProduct get _value => super._value as _MedicinalProduct;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object domain = freezed,
    Object combinedPharmaceuticalDoseForm = freezed,
    Object legalStatusOfSupply = freezed,
    Object additionalMonitoringIndicator = freezed,
    Object specialMeasures = freezed,
    Object paediatricUseIndicator = freezed,
    Object productClassification = freezed,
    Object marketingStatus = freezed,
    Object pharmaceuticalProduct = freezed,
    Object packagedMedicinalProduct = freezed,
    Object attachedDocument = freezed,
    Object masterFile = freezed,
    Object contact = freezed,
    Object clinicalTrial = freezed,
    Object name = freezed,
    Object crossReference = freezed,
    Object manufacturingBusinessOperation = freezed,
    Object specialDesignation = freezed,
  }) {
    return _then(_MedicinalProduct(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      domain: domain == freezed ? _value.domain : domain as Coding,
      combinedPharmaceuticalDoseForm: combinedPharmaceuticalDoseForm == freezed
          ? _value.combinedPharmaceuticalDoseForm
          : combinedPharmaceuticalDoseForm as CodeableConcept,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      additionalMonitoringIndicator: additionalMonitoringIndicator == freezed
          ? _value.additionalMonitoringIndicator
          : additionalMonitoringIndicator as CodeableConcept,
      specialMeasures: specialMeasures == freezed
          ? _value.specialMeasures
          : specialMeasures as List<String>,
      paediatricUseIndicator: paediatricUseIndicator == freezed
          ? _value.paediatricUseIndicator
          : paediatricUseIndicator as CodeableConcept,
      productClassification: productClassification == freezed
          ? _value.productClassification
          : productClassification as List<CodeableConcept>,
      marketingStatus: marketingStatus == freezed
          ? _value.marketingStatus
          : marketingStatus as List<MarketingStatus>,
      pharmaceuticalProduct: pharmaceuticalProduct == freezed
          ? _value.pharmaceuticalProduct
          : pharmaceuticalProduct as List<Reference>,
      packagedMedicinalProduct: packagedMedicinalProduct == freezed
          ? _value.packagedMedicinalProduct
          : packagedMedicinalProduct as List<Reference>,
      attachedDocument: attachedDocument == freezed
          ? _value.attachedDocument
          : attachedDocument as List<Reference>,
      masterFile: masterFile == freezed
          ? _value.masterFile
          : masterFile as List<Reference>,
      contact: contact == freezed ? _value.contact : contact as List<Reference>,
      clinicalTrial: clinicalTrial == freezed
          ? _value.clinicalTrial
          : clinicalTrial as List<Reference>,
      name: name == freezed ? _value.name : name as List<MedicinalProductName>,
      crossReference: crossReference == freezed
          ? _value.crossReference
          : crossReference as List<Identifier>,
      manufacturingBusinessOperation: manufacturingBusinessOperation == freezed
          ? _value.manufacturingBusinessOperation
          : manufacturingBusinessOperation
              as List<MedicinalProductManufacturingBusinessOperation>,
      specialDesignation: specialDesignation == freezed
          ? _value.specialDesignation
          : specialDesignation as List<MedicinalProductSpecialDesignation>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProduct implements _MedicinalProduct {
  const _$_MedicinalProduct(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProduct')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.type,
      this.domain,
      this.combinedPharmaceuticalDoseForm,
      this.legalStatusOfSupply,
      this.additionalMonitoringIndicator,
      this.specialMeasures,
      this.paediatricUseIndicator,
      this.productClassification,
      this.marketingStatus,
      this.pharmaceuticalProduct,
      this.packagedMedicinalProduct,
      this.attachedDocument,
      this.masterFile,
      this.contact,
      this.clinicalTrial,
      @required
      @JsonKey(required: true)
          this.name,
      this.crossReference,
      this.manufacturingBusinessOperation,
      this.specialDesignation})
      : assert(resourceType != null),
        assert(name != null);

  factory _$_MedicinalProduct.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProduct')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final CodeableConcept type;
  @override
  final Coding domain;
  @override
  final CodeableConcept combinedPharmaceuticalDoseForm;
  @override
  final CodeableConcept legalStatusOfSupply;
  @override
  final CodeableConcept additionalMonitoringIndicator;
  @override
  final List<String> specialMeasures;
  @override
  final CodeableConcept paediatricUseIndicator;
  @override
  final List<CodeableConcept> productClassification;
  @override
  final List<MarketingStatus> marketingStatus;
  @override
  final List<Reference> pharmaceuticalProduct;
  @override
  final List<Reference> packagedMedicinalProduct;
  @override
  final List<Reference> attachedDocument;
  @override
  final List<Reference> masterFile;
  @override
  final List<Reference> contact;
  @override
  final List<Reference> clinicalTrial;
  @override
  @JsonKey(required: true)
  final List<MedicinalProductName> name;
  @override
  final List<Identifier> crossReference;
  @override
  final List<MedicinalProductManufacturingBusinessOperation>
      manufacturingBusinessOperation;
  @override
  final List<MedicinalProductSpecialDesignation> specialDesignation;

  @override
  String toString() {
    return 'MedicinalProduct(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, domain: $domain, combinedPharmaceuticalDoseForm: $combinedPharmaceuticalDoseForm, legalStatusOfSupply: $legalStatusOfSupply, additionalMonitoringIndicator: $additionalMonitoringIndicator, specialMeasures: $specialMeasures, paediatricUseIndicator: $paediatricUseIndicator, productClassification: $productClassification, marketingStatus: $marketingStatus, pharmaceuticalProduct: $pharmaceuticalProduct, packagedMedicinalProduct: $packagedMedicinalProduct, attachedDocument: $attachedDocument, masterFile: $masterFile, contact: $contact, clinicalTrial: $clinicalTrial, name: $name, crossReference: $crossReference, manufacturingBusinessOperation: $manufacturingBusinessOperation, specialDesignation: $specialDesignation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProduct &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.domain, domain) ||
                const DeepCollectionEquality().equals(other.domain, domain)) &&
            (identical(other.combinedPharmaceuticalDoseForm, combinedPharmaceuticalDoseForm) ||
                const DeepCollectionEquality().equals(
                    other.combinedPharmaceuticalDoseForm,
                    combinedPharmaceuticalDoseForm)) &&
            (identical(other.legalStatusOfSupply, legalStatusOfSupply) ||
                const DeepCollectionEquality()
                    .equals(other.legalStatusOfSupply, legalStatusOfSupply)) &&
            (identical(other.additionalMonitoringIndicator, additionalMonitoringIndicator) ||
                const DeepCollectionEquality().equals(
                    other.additionalMonitoringIndicator,
                    additionalMonitoringIndicator)) &&
            (identical(other.specialMeasures, specialMeasures) ||
                const DeepCollectionEquality()
                    .equals(other.specialMeasures, specialMeasures)) &&
            (identical(other.paediatricUseIndicator, paediatricUseIndicator) ||
                const DeepCollectionEquality().equals(
                    other.paediatricUseIndicator, paediatricUseIndicator)) &&
            (identical(other.productClassification, productClassification) ||
                const DeepCollectionEquality().equals(
                    other.productClassification, productClassification)) &&
            (identical(other.marketingStatus, marketingStatus) ||
                const DeepCollectionEquality()
                    .equals(other.marketingStatus, marketingStatus)) &&
            (identical(other.pharmaceuticalProduct, pharmaceuticalProduct) ||
                const DeepCollectionEquality()
                    .equals(other.pharmaceuticalProduct, pharmaceuticalProduct)) &&
            (identical(other.packagedMedicinalProduct, packagedMedicinalProduct) || const DeepCollectionEquality().equals(other.packagedMedicinalProduct, packagedMedicinalProduct)) &&
            (identical(other.attachedDocument, attachedDocument) || const DeepCollectionEquality().equals(other.attachedDocument, attachedDocument)) &&
            (identical(other.masterFile, masterFile) || const DeepCollectionEquality().equals(other.masterFile, masterFile)) &&
            (identical(other.contact, contact) || const DeepCollectionEquality().equals(other.contact, contact)) &&
            (identical(other.clinicalTrial, clinicalTrial) || const DeepCollectionEquality().equals(other.clinicalTrial, clinicalTrial)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.crossReference, crossReference) || const DeepCollectionEquality().equals(other.crossReference, crossReference)) &&
            (identical(other.manufacturingBusinessOperation, manufacturingBusinessOperation) || const DeepCollectionEquality().equals(other.manufacturingBusinessOperation, manufacturingBusinessOperation)) &&
            (identical(other.specialDesignation, specialDesignation) || const DeepCollectionEquality().equals(other.specialDesignation, specialDesignation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(domain) ^
      const DeepCollectionEquality().hash(combinedPharmaceuticalDoseForm) ^
      const DeepCollectionEquality().hash(legalStatusOfSupply) ^
      const DeepCollectionEquality().hash(additionalMonitoringIndicator) ^
      const DeepCollectionEquality().hash(specialMeasures) ^
      const DeepCollectionEquality().hash(paediatricUseIndicator) ^
      const DeepCollectionEquality().hash(productClassification) ^
      const DeepCollectionEquality().hash(marketingStatus) ^
      const DeepCollectionEquality().hash(pharmaceuticalProduct) ^
      const DeepCollectionEquality().hash(packagedMedicinalProduct) ^
      const DeepCollectionEquality().hash(attachedDocument) ^
      const DeepCollectionEquality().hash(masterFile) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(clinicalTrial) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(crossReference) ^
      const DeepCollectionEquality().hash(manufacturingBusinessOperation) ^
      const DeepCollectionEquality().hash(specialDesignation);

  @override
  _$MedicinalProductCopyWith<_MedicinalProduct> get copyWith =>
      __$MedicinalProductCopyWithImpl<_MedicinalProduct>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductToJson(this);
  }
}

abstract class _MedicinalProduct implements MedicinalProduct {
  const factory _MedicinalProduct(
          {@required
          @JsonKey(required: true, defaultValue: 'MedicinalProduct')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          List<Identifier> identifier,
          CodeableConcept type,
          Coding domain,
          CodeableConcept combinedPharmaceuticalDoseForm,
          CodeableConcept legalStatusOfSupply,
          CodeableConcept additionalMonitoringIndicator,
          List<String> specialMeasures,
          CodeableConcept paediatricUseIndicator,
          List<CodeableConcept> productClassification,
          List<MarketingStatus> marketingStatus,
          List<Reference> pharmaceuticalProduct,
          List<Reference> packagedMedicinalProduct,
          List<Reference> attachedDocument,
          List<Reference> masterFile,
          List<Reference> contact,
          List<Reference> clinicalTrial,
          @required
          @JsonKey(required: true)
              List<MedicinalProductName> name,
          List<Identifier> crossReference,
          List<MedicinalProductManufacturingBusinessOperation>
              manufacturingBusinessOperation,
          List<MedicinalProductSpecialDesignation> specialDesignation}) =
      _$_MedicinalProduct;

  factory _MedicinalProduct.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProduct.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProduct')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  CodeableConcept get type;
  @override
  Coding get domain;
  @override
  CodeableConcept get combinedPharmaceuticalDoseForm;
  @override
  CodeableConcept get legalStatusOfSupply;
  @override
  CodeableConcept get additionalMonitoringIndicator;
  @override
  List<String> get specialMeasures;
  @override
  CodeableConcept get paediatricUseIndicator;
  @override
  List<CodeableConcept> get productClassification;
  @override
  List<MarketingStatus> get marketingStatus;
  @override
  List<Reference> get pharmaceuticalProduct;
  @override
  List<Reference> get packagedMedicinalProduct;
  @override
  List<Reference> get attachedDocument;
  @override
  List<Reference> get masterFile;
  @override
  List<Reference> get contact;
  @override
  List<Reference> get clinicalTrial;
  @override
  @JsonKey(required: true)
  List<MedicinalProductName> get name;
  @override
  List<Identifier> get crossReference;
  @override
  List<MedicinalProductManufacturingBusinessOperation>
      get manufacturingBusinessOperation;
  @override
  List<MedicinalProductSpecialDesignation> get specialDesignation;
  @override
  _$MedicinalProductCopyWith<_MedicinalProduct> get copyWith;
}

MedicinalProductName _$MedicinalProductNameFromJson(Map<String, dynamic> json) {
  return _MedicinalProductName.fromJson(json);
}

class _$MedicinalProductNameTearOff {
  const _$MedicinalProductNameTearOff();

  _MedicinalProductName call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String productName,
      List<MedicinalProductNamePart> namePart,
      List<MedicinalProductCountryLanguage> countryLanguage}) {
    return _MedicinalProductName(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      productName: productName,
      namePart: namePart,
      countryLanguage: countryLanguage,
    );
  }
}

// ignore: unused_element
const $MedicinalProductName = _$MedicinalProductNameTearOff();

mixin _$MedicinalProductName {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get productName;
  List<MedicinalProductNamePart> get namePart;
  List<MedicinalProductCountryLanguage> get countryLanguage;

  Map<String, dynamic> toJson();
  $MedicinalProductNameCopyWith<MedicinalProductName> get copyWith;
}

abstract class $MedicinalProductNameCopyWith<$Res> {
  factory $MedicinalProductNameCopyWith(MedicinalProductName value,
          $Res Function(MedicinalProductName) then) =
      _$MedicinalProductNameCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String productName,
      List<MedicinalProductNamePart> namePart,
      List<MedicinalProductCountryLanguage> countryLanguage});
}

class _$MedicinalProductNameCopyWithImpl<$Res>
    implements $MedicinalProductNameCopyWith<$Res> {
  _$MedicinalProductNameCopyWithImpl(this._value, this._then);

  final MedicinalProductName _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductName) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object productName = freezed,
    Object namePart = freezed,
    Object countryLanguage = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      productName:
          productName == freezed ? _value.productName : productName as String,
      namePart: namePart == freezed
          ? _value.namePart
          : namePart as List<MedicinalProductNamePart>,
      countryLanguage: countryLanguage == freezed
          ? _value.countryLanguage
          : countryLanguage as List<MedicinalProductCountryLanguage>,
    ));
  }
}

abstract class _$MedicinalProductNameCopyWith<$Res>
    implements $MedicinalProductNameCopyWith<$Res> {
  factory _$MedicinalProductNameCopyWith(_MedicinalProductName value,
          $Res Function(_MedicinalProductName) then) =
      __$MedicinalProductNameCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String productName,
      List<MedicinalProductNamePart> namePart,
      List<MedicinalProductCountryLanguage> countryLanguage});
}

class __$MedicinalProductNameCopyWithImpl<$Res>
    extends _$MedicinalProductNameCopyWithImpl<$Res>
    implements _$MedicinalProductNameCopyWith<$Res> {
  __$MedicinalProductNameCopyWithImpl(
      _MedicinalProductName _value, $Res Function(_MedicinalProductName) _then)
      : super(_value, (v) => _then(v as _MedicinalProductName));

  @override
  _MedicinalProductName get _value => super._value as _MedicinalProductName;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object productName = freezed,
    Object namePart = freezed,
    Object countryLanguage = freezed,
  }) {
    return _then(_MedicinalProductName(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      productName:
          productName == freezed ? _value.productName : productName as String,
      namePart: namePart == freezed
          ? _value.namePart
          : namePart as List<MedicinalProductNamePart>,
      countryLanguage: countryLanguage == freezed
          ? _value.countryLanguage
          : countryLanguage as List<MedicinalProductCountryLanguage>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductName implements _MedicinalProductName {
  const _$_MedicinalProductName(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.productName,
      this.namePart,
      this.countryLanguage});

  factory _$_MedicinalProductName.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductNameFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String productName;
  @override
  final List<MedicinalProductNamePart> namePart;
  @override
  final List<MedicinalProductCountryLanguage> countryLanguage;

  @override
  String toString() {
    return 'MedicinalProductName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, productName: $productName, namePart: $namePart, countryLanguage: $countryLanguage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductName &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.productName, productName) ||
                const DeepCollectionEquality()
                    .equals(other.productName, productName)) &&
            (identical(other.namePart, namePart) ||
                const DeepCollectionEquality()
                    .equals(other.namePart, namePart)) &&
            (identical(other.countryLanguage, countryLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.countryLanguage, countryLanguage)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(productName) ^
      const DeepCollectionEquality().hash(namePart) ^
      const DeepCollectionEquality().hash(countryLanguage);

  @override
  _$MedicinalProductNameCopyWith<_MedicinalProductName> get copyWith =>
      __$MedicinalProductNameCopyWithImpl<_MedicinalProductName>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductNameToJson(this);
  }
}

abstract class _MedicinalProductName implements MedicinalProductName {
  const factory _MedicinalProductName(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String productName,
          List<MedicinalProductNamePart> namePart,
          List<MedicinalProductCountryLanguage> countryLanguage}) =
      _$_MedicinalProductName;

  factory _MedicinalProductName.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductName.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get productName;
  @override
  List<MedicinalProductNamePart> get namePart;
  @override
  List<MedicinalProductCountryLanguage> get countryLanguage;
  @override
  _$MedicinalProductNameCopyWith<_MedicinalProductName> get copyWith;
}

MedicinalProductNamePart _$MedicinalProductNamePartFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductNamePart.fromJson(json);
}

class _$MedicinalProductNamePartTearOff {
  const _$MedicinalProductNamePartTearOff();

  _MedicinalProductNamePart call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String part,
      @required @JsonKey(required: true) Coding type}) {
    return _MedicinalProductNamePart(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      part: part,
      type: type,
    );
  }
}

// ignore: unused_element
const $MedicinalProductNamePart = _$MedicinalProductNamePartTearOff();

mixin _$MedicinalProductNamePart {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get part;
  @JsonKey(required: true)
  Coding get type;

  Map<String, dynamic> toJson();
  $MedicinalProductNamePartCopyWith<MedicinalProductNamePart> get copyWith;
}

abstract class $MedicinalProductNamePartCopyWith<$Res> {
  factory $MedicinalProductNamePartCopyWith(MedicinalProductNamePart value,
          $Res Function(MedicinalProductNamePart) then) =
      _$MedicinalProductNamePartCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String part,
      @JsonKey(required: true) Coding type});

  $CodingCopyWith<$Res> get type;
}

class _$MedicinalProductNamePartCopyWithImpl<$Res>
    implements $MedicinalProductNamePartCopyWith<$Res> {
  _$MedicinalProductNamePartCopyWithImpl(this._value, this._then);

  final MedicinalProductNamePart _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductNamePart) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object part = freezed,
    Object type = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      part: part == freezed ? _value.part : part as String,
      type: type == freezed ? _value.type : type as Coding,
    ));
  }

  @override
  $CodingCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$MedicinalProductNamePartCopyWith<$Res>
    implements $MedicinalProductNamePartCopyWith<$Res> {
  factory _$MedicinalProductNamePartCopyWith(_MedicinalProductNamePart value,
          $Res Function(_MedicinalProductNamePart) then) =
      __$MedicinalProductNamePartCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String part,
      @JsonKey(required: true) Coding type});

  @override
  $CodingCopyWith<$Res> get type;
}

class __$MedicinalProductNamePartCopyWithImpl<$Res>
    extends _$MedicinalProductNamePartCopyWithImpl<$Res>
    implements _$MedicinalProductNamePartCopyWith<$Res> {
  __$MedicinalProductNamePartCopyWithImpl(_MedicinalProductNamePart _value,
      $Res Function(_MedicinalProductNamePart) _then)
      : super(_value, (v) => _then(v as _MedicinalProductNamePart));

  @override
  _MedicinalProductNamePart get _value =>
      super._value as _MedicinalProductNamePart;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object part = freezed,
    Object type = freezed,
  }) {
    return _then(_MedicinalProductNamePart(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      part: part == freezed ? _value.part : part as String,
      type: type == freezed ? _value.type : type as Coding,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductNamePart implements _MedicinalProductNamePart {
  const _$_MedicinalProductNamePart(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.part,
      @required @JsonKey(required: true) this.type})
      : assert(type != null);

  factory _$_MedicinalProductNamePart.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductNamePartFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String part;
  @override
  @JsonKey(required: true)
  final Coding type;

  @override
  String toString() {
    return 'MedicinalProductNamePart(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, part: $part, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductNamePart &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.part, part) ||
                const DeepCollectionEquality().equals(other.part, part)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(part) ^
      const DeepCollectionEquality().hash(type);

  @override
  _$MedicinalProductNamePartCopyWith<_MedicinalProductNamePart> get copyWith =>
      __$MedicinalProductNamePartCopyWithImpl<_MedicinalProductNamePart>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductNamePartToJson(this);
  }
}

abstract class _MedicinalProductNamePart implements MedicinalProductNamePart {
  const factory _MedicinalProductNamePart(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String part,
          @required @JsonKey(required: true) Coding type}) =
      _$_MedicinalProductNamePart;

  factory _MedicinalProductNamePart.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductNamePart.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get part;
  @override
  @JsonKey(required: true)
  Coding get type;
  @override
  _$MedicinalProductNamePartCopyWith<_MedicinalProductNamePart> get copyWith;
}

MedicinalProductCountryLanguage _$MedicinalProductCountryLanguageFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductCountryLanguage.fromJson(json);
}

class _$MedicinalProductCountryLanguageTearOff {
  const _$MedicinalProductCountryLanguageTearOff();

  _MedicinalProductCountryLanguage call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept country,
      CodeableConcept jurisdiction,
      @required @JsonKey(required: true) CodeableConcept language}) {
    return _MedicinalProductCountryLanguage(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      country: country,
      jurisdiction: jurisdiction,
      language: language,
    );
  }
}

// ignore: unused_element
const $MedicinalProductCountryLanguage =
    _$MedicinalProductCountryLanguageTearOff();

mixin _$MedicinalProductCountryLanguage {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get country;
  CodeableConcept get jurisdiction;
  @JsonKey(required: true)
  CodeableConcept get language;

  Map<String, dynamic> toJson();
  $MedicinalProductCountryLanguageCopyWith<MedicinalProductCountryLanguage>
      get copyWith;
}

abstract class $MedicinalProductCountryLanguageCopyWith<$Res> {
  factory $MedicinalProductCountryLanguageCopyWith(
          MedicinalProductCountryLanguage value,
          $Res Function(MedicinalProductCountryLanguage) then) =
      _$MedicinalProductCountryLanguageCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept country,
      CodeableConcept jurisdiction,
      @JsonKey(required: true) CodeableConcept language});

  $CodeableConceptCopyWith<$Res> get country;
  $CodeableConceptCopyWith<$Res> get jurisdiction;
  $CodeableConceptCopyWith<$Res> get language;
}

class _$MedicinalProductCountryLanguageCopyWithImpl<$Res>
    implements $MedicinalProductCountryLanguageCopyWith<$Res> {
  _$MedicinalProductCountryLanguageCopyWithImpl(this._value, this._then);

  final MedicinalProductCountryLanguage _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductCountryLanguage) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object language = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      country: country == freezed ? _value.country : country as CodeableConcept,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as CodeableConcept,
      language:
          language == freezed ? _value.language : language as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get country {
    if (_value.country == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.country, (value) {
      return _then(_value.copyWith(country: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get jurisdiction {
    if (_value.jurisdiction == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.jurisdiction, (value) {
      return _then(_value.copyWith(jurisdiction: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get language {
    if (_value.language == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.language, (value) {
      return _then(_value.copyWith(language: value));
    });
  }
}

abstract class _$MedicinalProductCountryLanguageCopyWith<$Res>
    implements $MedicinalProductCountryLanguageCopyWith<$Res> {
  factory _$MedicinalProductCountryLanguageCopyWith(
          _MedicinalProductCountryLanguage value,
          $Res Function(_MedicinalProductCountryLanguage) then) =
      __$MedicinalProductCountryLanguageCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept country,
      CodeableConcept jurisdiction,
      @JsonKey(required: true) CodeableConcept language});

  @override
  $CodeableConceptCopyWith<$Res> get country;
  @override
  $CodeableConceptCopyWith<$Res> get jurisdiction;
  @override
  $CodeableConceptCopyWith<$Res> get language;
}

class __$MedicinalProductCountryLanguageCopyWithImpl<$Res>
    extends _$MedicinalProductCountryLanguageCopyWithImpl<$Res>
    implements _$MedicinalProductCountryLanguageCopyWith<$Res> {
  __$MedicinalProductCountryLanguageCopyWithImpl(
      _MedicinalProductCountryLanguage _value,
      $Res Function(_MedicinalProductCountryLanguage) _then)
      : super(_value, (v) => _then(v as _MedicinalProductCountryLanguage));

  @override
  _MedicinalProductCountryLanguage get _value =>
      super._value as _MedicinalProductCountryLanguage;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object language = freezed,
  }) {
    return _then(_MedicinalProductCountryLanguage(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      country: country == freezed ? _value.country : country as CodeableConcept,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as CodeableConcept,
      language:
          language == freezed ? _value.language : language as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductCountryLanguage
    implements _MedicinalProductCountryLanguage {
  const _$_MedicinalProductCountryLanguage(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.country,
      this.jurisdiction,
      @required @JsonKey(required: true) this.language})
      : assert(country != null),
        assert(language != null);

  factory _$_MedicinalProductCountryLanguage.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductCountryLanguageFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept country;
  @override
  final CodeableConcept jurisdiction;
  @override
  @JsonKey(required: true)
  final CodeableConcept language;

  @override
  String toString() {
    return 'MedicinalProductCountryLanguage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, country: $country, jurisdiction: $jurisdiction, language: $language)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductCountryLanguage &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(language);

  @override
  _$MedicinalProductCountryLanguageCopyWith<_MedicinalProductCountryLanguage>
      get copyWith => __$MedicinalProductCountryLanguageCopyWithImpl<
          _MedicinalProductCountryLanguage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductCountryLanguageToJson(this);
  }
}

abstract class _MedicinalProductCountryLanguage
    implements MedicinalProductCountryLanguage {
  const factory _MedicinalProductCountryLanguage(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept country,
          CodeableConcept jurisdiction,
          @required @JsonKey(required: true) CodeableConcept language}) =
      _$_MedicinalProductCountryLanguage;

  factory _MedicinalProductCountryLanguage.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductCountryLanguage.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get country;
  @override
  CodeableConcept get jurisdiction;
  @override
  @JsonKey(required: true)
  CodeableConcept get language;
  @override
  _$MedicinalProductCountryLanguageCopyWith<_MedicinalProductCountryLanguage>
      get copyWith;
}

MedicinalProductManufacturingBusinessOperation
    _$MedicinalProductManufacturingBusinessOperationFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductManufacturingBusinessOperation.fromJson(json);
}

class _$MedicinalProductManufacturingBusinessOperationTearOff {
  const _$MedicinalProductManufacturingBusinessOperationTearOff();

  _MedicinalProductManufacturingBusinessOperation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept operationType,
      Identifier authorisationReferenceNumber,
      FhirDateTime effectiveDate,
      CodeableConcept confidentialityIndicator,
      List<Reference> manufacturer,
      Reference regulator}) {
    return _MedicinalProductManufacturingBusinessOperation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operationType: operationType,
      authorisationReferenceNumber: authorisationReferenceNumber,
      effectiveDate: effectiveDate,
      confidentialityIndicator: confidentialityIndicator,
      manufacturer: manufacturer,
      regulator: regulator,
    );
  }
}

// ignore: unused_element
const $MedicinalProductManufacturingBusinessOperation =
    _$MedicinalProductManufacturingBusinessOperationTearOff();

mixin _$MedicinalProductManufacturingBusinessOperation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get operationType;
  Identifier get authorisationReferenceNumber;
  FhirDateTime get effectiveDate;
  CodeableConcept get confidentialityIndicator;
  List<Reference> get manufacturer;
  Reference get regulator;

  Map<String, dynamic> toJson();
  $MedicinalProductManufacturingBusinessOperationCopyWith<
      MedicinalProductManufacturingBusinessOperation> get copyWith;
}

abstract class $MedicinalProductManufacturingBusinessOperationCopyWith<$Res> {
  factory $MedicinalProductManufacturingBusinessOperationCopyWith(
          MedicinalProductManufacturingBusinessOperation value,
          $Res Function(MedicinalProductManufacturingBusinessOperation) then) =
      _$MedicinalProductManufacturingBusinessOperationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept operationType,
      Identifier authorisationReferenceNumber,
      FhirDateTime effectiveDate,
      CodeableConcept confidentialityIndicator,
      List<Reference> manufacturer,
      Reference regulator});

  $CodeableConceptCopyWith<$Res> get operationType;
  $IdentifierCopyWith<$Res> get authorisationReferenceNumber;
  $CodeableConceptCopyWith<$Res> get confidentialityIndicator;
  $ReferenceCopyWith<$Res> get regulator;
}

class _$MedicinalProductManufacturingBusinessOperationCopyWithImpl<$Res>
    implements $MedicinalProductManufacturingBusinessOperationCopyWith<$Res> {
  _$MedicinalProductManufacturingBusinessOperationCopyWithImpl(
      this._value, this._then);

  final MedicinalProductManufacturingBusinessOperation _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductManufacturingBusinessOperation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operationType = freezed,
    Object authorisationReferenceNumber = freezed,
    Object effectiveDate = freezed,
    Object confidentialityIndicator = freezed,
    Object manufacturer = freezed,
    Object regulator = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operationType: operationType == freezed
          ? _value.operationType
          : operationType as CodeableConcept,
      authorisationReferenceNumber: authorisationReferenceNumber == freezed
          ? _value.authorisationReferenceNumber
          : authorisationReferenceNumber as Identifier,
      effectiveDate: effectiveDate == freezed
          ? _value.effectiveDate
          : effectiveDate as FhirDateTime,
      confidentialityIndicator: confidentialityIndicator == freezed
          ? _value.confidentialityIndicator
          : confidentialityIndicator as CodeableConcept,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      regulator:
          regulator == freezed ? _value.regulator : regulator as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get operationType {
    if (_value.operationType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.operationType, (value) {
      return _then(_value.copyWith(operationType: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get authorisationReferenceNumber {
    if (_value.authorisationReferenceNumber == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.authorisationReferenceNumber,
        (value) {
      return _then(_value.copyWith(authorisationReferenceNumber: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get confidentialityIndicator {
    if (_value.confidentialityIndicator == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.confidentialityIndicator,
        (value) {
      return _then(_value.copyWith(confidentialityIndicator: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get regulator {
    if (_value.regulator == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.regulator, (value) {
      return _then(_value.copyWith(regulator: value));
    });
  }
}

abstract class _$MedicinalProductManufacturingBusinessOperationCopyWith<$Res>
    implements $MedicinalProductManufacturingBusinessOperationCopyWith<$Res> {
  factory _$MedicinalProductManufacturingBusinessOperationCopyWith(
          _MedicinalProductManufacturingBusinessOperation value,
          $Res Function(_MedicinalProductManufacturingBusinessOperation) then) =
      __$MedicinalProductManufacturingBusinessOperationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept operationType,
      Identifier authorisationReferenceNumber,
      FhirDateTime effectiveDate,
      CodeableConcept confidentialityIndicator,
      List<Reference> manufacturer,
      Reference regulator});

  @override
  $CodeableConceptCopyWith<$Res> get operationType;
  @override
  $IdentifierCopyWith<$Res> get authorisationReferenceNumber;
  @override
  $CodeableConceptCopyWith<$Res> get confidentialityIndicator;
  @override
  $ReferenceCopyWith<$Res> get regulator;
}

class __$MedicinalProductManufacturingBusinessOperationCopyWithImpl<$Res>
    extends _$MedicinalProductManufacturingBusinessOperationCopyWithImpl<$Res>
    implements _$MedicinalProductManufacturingBusinessOperationCopyWith<$Res> {
  __$MedicinalProductManufacturingBusinessOperationCopyWithImpl(
      _MedicinalProductManufacturingBusinessOperation _value,
      $Res Function(_MedicinalProductManufacturingBusinessOperation) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductManufacturingBusinessOperation));

  @override
  _MedicinalProductManufacturingBusinessOperation get _value =>
      super._value as _MedicinalProductManufacturingBusinessOperation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operationType = freezed,
    Object authorisationReferenceNumber = freezed,
    Object effectiveDate = freezed,
    Object confidentialityIndicator = freezed,
    Object manufacturer = freezed,
    Object regulator = freezed,
  }) {
    return _then(_MedicinalProductManufacturingBusinessOperation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operationType: operationType == freezed
          ? _value.operationType
          : operationType as CodeableConcept,
      authorisationReferenceNumber: authorisationReferenceNumber == freezed
          ? _value.authorisationReferenceNumber
          : authorisationReferenceNumber as Identifier,
      effectiveDate: effectiveDate == freezed
          ? _value.effectiveDate
          : effectiveDate as FhirDateTime,
      confidentialityIndicator: confidentialityIndicator == freezed
          ? _value.confidentialityIndicator
          : confidentialityIndicator as CodeableConcept,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      regulator:
          regulator == freezed ? _value.regulator : regulator as Reference,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductManufacturingBusinessOperation
    implements _MedicinalProductManufacturingBusinessOperation {
  const _$_MedicinalProductManufacturingBusinessOperation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.operationType,
      this.authorisationReferenceNumber,
      this.effectiveDate,
      this.confidentialityIndicator,
      this.manufacturer,
      this.regulator});

  factory _$_MedicinalProductManufacturingBusinessOperation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductManufacturingBusinessOperationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept operationType;
  @override
  final Identifier authorisationReferenceNumber;
  @override
  final FhirDateTime effectiveDate;
  @override
  final CodeableConcept confidentialityIndicator;
  @override
  final List<Reference> manufacturer;
  @override
  final Reference regulator;

  @override
  String toString() {
    return 'MedicinalProductManufacturingBusinessOperation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operationType: $operationType, authorisationReferenceNumber: $authorisationReferenceNumber, effectiveDate: $effectiveDate, confidentialityIndicator: $confidentialityIndicator, manufacturer: $manufacturer, regulator: $regulator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductManufacturingBusinessOperation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operationType, operationType) ||
                const DeepCollectionEquality()
                    .equals(other.operationType, operationType)) &&
            (identical(other.authorisationReferenceNumber,
                    authorisationReferenceNumber) ||
                const DeepCollectionEquality().equals(
                    other.authorisationReferenceNumber,
                    authorisationReferenceNumber)) &&
            (identical(other.effectiveDate, effectiveDate) ||
                const DeepCollectionEquality()
                    .equals(other.effectiveDate, effectiveDate)) &&
            (identical(
                    other.confidentialityIndicator, confidentialityIndicator) ||
                const DeepCollectionEquality().equals(
                    other.confidentialityIndicator,
                    confidentialityIndicator)) &&
            (identical(other.manufacturer, manufacturer) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturer, manufacturer)) &&
            (identical(other.regulator, regulator) ||
                const DeepCollectionEquality()
                    .equals(other.regulator, regulator)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operationType) ^
      const DeepCollectionEquality().hash(authorisationReferenceNumber) ^
      const DeepCollectionEquality().hash(effectiveDate) ^
      const DeepCollectionEquality().hash(confidentialityIndicator) ^
      const DeepCollectionEquality().hash(manufacturer) ^
      const DeepCollectionEquality().hash(regulator);

  @override
  _$MedicinalProductManufacturingBusinessOperationCopyWith<
          _MedicinalProductManufacturingBusinessOperation>
      get copyWith =>
          __$MedicinalProductManufacturingBusinessOperationCopyWithImpl<
                  _MedicinalProductManufacturingBusinessOperation>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductManufacturingBusinessOperationToJson(this);
  }
}

abstract class _MedicinalProductManufacturingBusinessOperation
    implements MedicinalProductManufacturingBusinessOperation {
  const factory _MedicinalProductManufacturingBusinessOperation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept operationType,
      Identifier authorisationReferenceNumber,
      FhirDateTime effectiveDate,
      CodeableConcept confidentialityIndicator,
      List<Reference> manufacturer,
      Reference regulator}) = _$_MedicinalProductManufacturingBusinessOperation;

  factory _MedicinalProductManufacturingBusinessOperation.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductManufacturingBusinessOperation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get operationType;
  @override
  Identifier get authorisationReferenceNumber;
  @override
  FhirDateTime get effectiveDate;
  @override
  CodeableConcept get confidentialityIndicator;
  @override
  List<Reference> get manufacturer;
  @override
  Reference get regulator;
  @override
  _$MedicinalProductManufacturingBusinessOperationCopyWith<
      _MedicinalProductManufacturingBusinessOperation> get copyWith;
}

MedicinalProductSpecialDesignation _$MedicinalProductSpecialDesignationFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductSpecialDesignation.fromJson(json);
}

class _$MedicinalProductSpecialDesignationTearOff {
  const _$MedicinalProductSpecialDesignationTearOff();

  _MedicinalProductSpecialDesignation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      CodeableConcept intendedUse,
      CodeableConcept indicationCodeableConcept,
      Reference indicationReference,
      CodeableConcept status,
      FhirDateTime date,
      CodeableConcept species}) {
    return _MedicinalProductSpecialDesignation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      type: type,
      intendedUse: intendedUse,
      indicationCodeableConcept: indicationCodeableConcept,
      indicationReference: indicationReference,
      status: status,
      date: date,
      species: species,
    );
  }
}

// ignore: unused_element
const $MedicinalProductSpecialDesignation =
    _$MedicinalProductSpecialDesignationTearOff();

mixin _$MedicinalProductSpecialDesignation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  CodeableConcept get type;
  CodeableConcept get intendedUse;
  CodeableConcept get indicationCodeableConcept;
  Reference get indicationReference;
  CodeableConcept get status;
  FhirDateTime get date;
  CodeableConcept get species;

  Map<String, dynamic> toJson();
  $MedicinalProductSpecialDesignationCopyWith<
      MedicinalProductSpecialDesignation> get copyWith;
}

abstract class $MedicinalProductSpecialDesignationCopyWith<$Res> {
  factory $MedicinalProductSpecialDesignationCopyWith(
          MedicinalProductSpecialDesignation value,
          $Res Function(MedicinalProductSpecialDesignation) then) =
      _$MedicinalProductSpecialDesignationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      CodeableConcept intendedUse,
      CodeableConcept indicationCodeableConcept,
      Reference indicationReference,
      CodeableConcept status,
      FhirDateTime date,
      CodeableConcept species});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get intendedUse;
  $CodeableConceptCopyWith<$Res> get indicationCodeableConcept;
  $ReferenceCopyWith<$Res> get indicationReference;
  $CodeableConceptCopyWith<$Res> get status;
  $CodeableConceptCopyWith<$Res> get species;
}

class _$MedicinalProductSpecialDesignationCopyWithImpl<$Res>
    implements $MedicinalProductSpecialDesignationCopyWith<$Res> {
  _$MedicinalProductSpecialDesignationCopyWithImpl(this._value, this._then);

  final MedicinalProductSpecialDesignation _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductSpecialDesignation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object intendedUse = freezed,
    Object indicationCodeableConcept = freezed,
    Object indicationReference = freezed,
    Object status = freezed,
    Object date = freezed,
    Object species = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      intendedUse: intendedUse == freezed
          ? _value.intendedUse
          : intendedUse as CodeableConcept,
      indicationCodeableConcept: indicationCodeableConcept == freezed
          ? _value.indicationCodeableConcept
          : indicationCodeableConcept as CodeableConcept,
      indicationReference: indicationReference == freezed
          ? _value.indicationReference
          : indicationReference as Reference,
      status: status == freezed ? _value.status : status as CodeableConcept,
      date: date == freezed ? _value.date : date as FhirDateTime,
      species: species == freezed ? _value.species : species as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get intendedUse {
    if (_value.intendedUse == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.intendedUse, (value) {
      return _then(_value.copyWith(intendedUse: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get indicationCodeableConcept {
    if (_value.indicationCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.indicationCodeableConcept,
        (value) {
      return _then(_value.copyWith(indicationCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get indicationReference {
    if (_value.indicationReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.indicationReference, (value) {
      return _then(_value.copyWith(indicationReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get species {
    if (_value.species == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.species, (value) {
      return _then(_value.copyWith(species: value));
    });
  }
}

abstract class _$MedicinalProductSpecialDesignationCopyWith<$Res>
    implements $MedicinalProductSpecialDesignationCopyWith<$Res> {
  factory _$MedicinalProductSpecialDesignationCopyWith(
          _MedicinalProductSpecialDesignation value,
          $Res Function(_MedicinalProductSpecialDesignation) then) =
      __$MedicinalProductSpecialDesignationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      CodeableConcept intendedUse,
      CodeableConcept indicationCodeableConcept,
      Reference indicationReference,
      CodeableConcept status,
      FhirDateTime date,
      CodeableConcept species});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get intendedUse;
  @override
  $CodeableConceptCopyWith<$Res> get indicationCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get indicationReference;
  @override
  $CodeableConceptCopyWith<$Res> get status;
  @override
  $CodeableConceptCopyWith<$Res> get species;
}

class __$MedicinalProductSpecialDesignationCopyWithImpl<$Res>
    extends _$MedicinalProductSpecialDesignationCopyWithImpl<$Res>
    implements _$MedicinalProductSpecialDesignationCopyWith<$Res> {
  __$MedicinalProductSpecialDesignationCopyWithImpl(
      _MedicinalProductSpecialDesignation _value,
      $Res Function(_MedicinalProductSpecialDesignation) _then)
      : super(_value, (v) => _then(v as _MedicinalProductSpecialDesignation));

  @override
  _MedicinalProductSpecialDesignation get _value =>
      super._value as _MedicinalProductSpecialDesignation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object intendedUse = freezed,
    Object indicationCodeableConcept = freezed,
    Object indicationReference = freezed,
    Object status = freezed,
    Object date = freezed,
    Object species = freezed,
  }) {
    return _then(_MedicinalProductSpecialDesignation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      intendedUse: intendedUse == freezed
          ? _value.intendedUse
          : intendedUse as CodeableConcept,
      indicationCodeableConcept: indicationCodeableConcept == freezed
          ? _value.indicationCodeableConcept
          : indicationCodeableConcept as CodeableConcept,
      indicationReference: indicationReference == freezed
          ? _value.indicationReference
          : indicationReference as Reference,
      status: status == freezed ? _value.status : status as CodeableConcept,
      date: date == freezed ? _value.date : date as FhirDateTime,
      species: species == freezed ? _value.species : species as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductSpecialDesignation
    implements _MedicinalProductSpecialDesignation {
  const _$_MedicinalProductSpecialDesignation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      this.type,
      this.intendedUse,
      this.indicationCodeableConcept,
      this.indicationReference,
      this.status,
      this.date,
      this.species});

  factory _$_MedicinalProductSpecialDesignation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductSpecialDesignationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept intendedUse;
  @override
  final CodeableConcept indicationCodeableConcept;
  @override
  final Reference indicationReference;
  @override
  final CodeableConcept status;
  @override
  final FhirDateTime date;
  @override
  final CodeableConcept species;

  @override
  String toString() {
    return 'MedicinalProductSpecialDesignation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, intendedUse: $intendedUse, indicationCodeableConcept: $indicationCodeableConcept, indicationReference: $indicationReference, status: $status, date: $date, species: $species)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductSpecialDesignation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.intendedUse, intendedUse) ||
                const DeepCollectionEquality()
                    .equals(other.intendedUse, intendedUse)) &&
            (identical(other.indicationCodeableConcept,
                    indicationCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.indicationCodeableConcept,
                    indicationCodeableConcept)) &&
            (identical(other.indicationReference, indicationReference) ||
                const DeepCollectionEquality()
                    .equals(other.indicationReference, indicationReference)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.species, species) ||
                const DeepCollectionEquality().equals(other.species, species)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(intendedUse) ^
      const DeepCollectionEquality().hash(indicationCodeableConcept) ^
      const DeepCollectionEquality().hash(indicationReference) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(species);

  @override
  _$MedicinalProductSpecialDesignationCopyWith<
          _MedicinalProductSpecialDesignation>
      get copyWith => __$MedicinalProductSpecialDesignationCopyWithImpl<
          _MedicinalProductSpecialDesignation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductSpecialDesignationToJson(this);
  }
}

abstract class _MedicinalProductSpecialDesignation
    implements MedicinalProductSpecialDesignation {
  const factory _MedicinalProductSpecialDesignation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept type,
      CodeableConcept intendedUse,
      CodeableConcept indicationCodeableConcept,
      Reference indicationReference,
      CodeableConcept status,
      FhirDateTime date,
      CodeableConcept species}) = _$_MedicinalProductSpecialDesignation;

  factory _MedicinalProductSpecialDesignation.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductSpecialDesignation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get intendedUse;
  @override
  CodeableConcept get indicationCodeableConcept;
  @override
  Reference get indicationReference;
  @override
  CodeableConcept get status;
  @override
  FhirDateTime get date;
  @override
  CodeableConcept get species;
  @override
  _$MedicinalProductSpecialDesignationCopyWith<
      _MedicinalProductSpecialDesignation> get copyWith;
}

MedicinalProductAuthorization _$MedicinalProductAuthorizationFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductAuthorization.fromJson(json);
}

class _$MedicinalProductAuthorizationTearOff {
  const _$MedicinalProductAuthorizationTearOff();

  _MedicinalProductAuthorization call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      Reference subject,
      List<CodeableConcept> country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept status,
      FhirDateTime statusDate,
      FhirDateTime restoreDate,
      Period validityPeriod,
      Period dataExclusivityPeriod,
      FhirDateTime dateOfFirstAuthorization,
      FhirDateTime internationalBirthDate,
      CodeableConcept legalBasis,
      List<MedicinalProductAuthorizationJurisdictionalAuthorization>
          jurisdictionalAuthorization,
      Reference holder,
      Reference regulator,
      MedicinalProductAuthorizationProcedure procedure}) {
    return _MedicinalProductAuthorization(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      subject: subject,
      country: country,
      jurisdiction: jurisdiction,
      status: status,
      statusDate: statusDate,
      restoreDate: restoreDate,
      validityPeriod: validityPeriod,
      dataExclusivityPeriod: dataExclusivityPeriod,
      dateOfFirstAuthorization: dateOfFirstAuthorization,
      internationalBirthDate: internationalBirthDate,
      legalBasis: legalBasis,
      jurisdictionalAuthorization: jurisdictionalAuthorization,
      holder: holder,
      regulator: regulator,
      procedure: procedure,
    );
  }
}

// ignore: unused_element
const $MedicinalProductAuthorization = _$MedicinalProductAuthorizationTearOff();

mixin _$MedicinalProductAuthorization {
  @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  Reference get subject;
  List<CodeableConcept> get country;
  List<CodeableConcept> get jurisdiction;
  CodeableConcept get status;
  FhirDateTime get statusDate;
  FhirDateTime get restoreDate;
  Period get validityPeriod;
  Period get dataExclusivityPeriod;
  FhirDateTime get dateOfFirstAuthorization;
  FhirDateTime get internationalBirthDate;
  CodeableConcept get legalBasis;
  List<MedicinalProductAuthorizationJurisdictionalAuthorization>
      get jurisdictionalAuthorization;
  Reference get holder;
  Reference get regulator;
  MedicinalProductAuthorizationProcedure get procedure;

  Map<String, dynamic> toJson();
  $MedicinalProductAuthorizationCopyWith<MedicinalProductAuthorization>
      get copyWith;
}

abstract class $MedicinalProductAuthorizationCopyWith<$Res> {
  factory $MedicinalProductAuthorizationCopyWith(
          MedicinalProductAuthorization value,
          $Res Function(MedicinalProductAuthorization) then) =
      _$MedicinalProductAuthorizationCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      Reference subject,
      List<CodeableConcept> country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept status,
      FhirDateTime statusDate,
      FhirDateTime restoreDate,
      Period validityPeriod,
      Period dataExclusivityPeriod,
      FhirDateTime dateOfFirstAuthorization,
      FhirDateTime internationalBirthDate,
      CodeableConcept legalBasis,
      List<MedicinalProductAuthorizationJurisdictionalAuthorization>
          jurisdictionalAuthorization,
      Reference holder,
      Reference regulator,
      MedicinalProductAuthorizationProcedure procedure});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $ReferenceCopyWith<$Res> get subject;
  $CodeableConceptCopyWith<$Res> get status;
  $PeriodCopyWith<$Res> get validityPeriod;
  $PeriodCopyWith<$Res> get dataExclusivityPeriod;
  $CodeableConceptCopyWith<$Res> get legalBasis;
  $ReferenceCopyWith<$Res> get holder;
  $ReferenceCopyWith<$Res> get regulator;
  $MedicinalProductAuthorizationProcedureCopyWith<$Res> get procedure;
}

class _$MedicinalProductAuthorizationCopyWithImpl<$Res>
    implements $MedicinalProductAuthorizationCopyWith<$Res> {
  _$MedicinalProductAuthorizationCopyWithImpl(this._value, this._then);

  final MedicinalProductAuthorization _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductAuthorization) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object subject = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object status = freezed,
    Object statusDate = freezed,
    Object restoreDate = freezed,
    Object validityPeriod = freezed,
    Object dataExclusivityPeriod = freezed,
    Object dateOfFirstAuthorization = freezed,
    Object internationalBirthDate = freezed,
    Object legalBasis = freezed,
    Object jurisdictionalAuthorization = freezed,
    Object holder = freezed,
    Object regulator = freezed,
    Object procedure = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      subject: subject == freezed ? _value.subject : subject as Reference,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      status: status == freezed ? _value.status : status as CodeableConcept,
      statusDate: statusDate == freezed
          ? _value.statusDate
          : statusDate as FhirDateTime,
      restoreDate: restoreDate == freezed
          ? _value.restoreDate
          : restoreDate as FhirDateTime,
      validityPeriod: validityPeriod == freezed
          ? _value.validityPeriod
          : validityPeriod as Period,
      dataExclusivityPeriod: dataExclusivityPeriod == freezed
          ? _value.dataExclusivityPeriod
          : dataExclusivityPeriod as Period,
      dateOfFirstAuthorization: dateOfFirstAuthorization == freezed
          ? _value.dateOfFirstAuthorization
          : dateOfFirstAuthorization as FhirDateTime,
      internationalBirthDate: internationalBirthDate == freezed
          ? _value.internationalBirthDate
          : internationalBirthDate as FhirDateTime,
      legalBasis: legalBasis == freezed
          ? _value.legalBasis
          : legalBasis as CodeableConcept,
      jurisdictionalAuthorization: jurisdictionalAuthorization == freezed
          ? _value.jurisdictionalAuthorization
          : jurisdictionalAuthorization
              as List<MedicinalProductAuthorizationJurisdictionalAuthorization>,
      holder: holder == freezed ? _value.holder : holder as Reference,
      regulator:
          regulator == freezed ? _value.regulator : regulator as Reference,
      procedure: procedure == freezed
          ? _value.procedure
          : procedure as MedicinalProductAuthorizationProcedure,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subject {
    if (_value.subject == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subject, (value) {
      return _then(_value.copyWith(subject: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get validityPeriod {
    if (_value.validityPeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.validityPeriod, (value) {
      return _then(_value.copyWith(validityPeriod: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get dataExclusivityPeriod {
    if (_value.dataExclusivityPeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.dataExclusivityPeriod, (value) {
      return _then(_value.copyWith(dataExclusivityPeriod: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get legalBasis {
    if (_value.legalBasis == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.legalBasis, (value) {
      return _then(_value.copyWith(legalBasis: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get holder {
    if (_value.holder == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.holder, (value) {
      return _then(_value.copyWith(holder: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get regulator {
    if (_value.regulator == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.regulator, (value) {
      return _then(_value.copyWith(regulator: value));
    });
  }

  @override
  $MedicinalProductAuthorizationProcedureCopyWith<$Res> get procedure {
    if (_value.procedure == null) {
      return null;
    }
    return $MedicinalProductAuthorizationProcedureCopyWith<$Res>(
        _value.procedure, (value) {
      return _then(_value.copyWith(procedure: value));
    });
  }
}

abstract class _$MedicinalProductAuthorizationCopyWith<$Res>
    implements $MedicinalProductAuthorizationCopyWith<$Res> {
  factory _$MedicinalProductAuthorizationCopyWith(
          _MedicinalProductAuthorization value,
          $Res Function(_MedicinalProductAuthorization) then) =
      __$MedicinalProductAuthorizationCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      Reference subject,
      List<CodeableConcept> country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept status,
      FhirDateTime statusDate,
      FhirDateTime restoreDate,
      Period validityPeriod,
      Period dataExclusivityPeriod,
      FhirDateTime dateOfFirstAuthorization,
      FhirDateTime internationalBirthDate,
      CodeableConcept legalBasis,
      List<MedicinalProductAuthorizationJurisdictionalAuthorization>
          jurisdictionalAuthorization,
      Reference holder,
      Reference regulator,
      MedicinalProductAuthorizationProcedure procedure});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $ReferenceCopyWith<$Res> get subject;
  @override
  $CodeableConceptCopyWith<$Res> get status;
  @override
  $PeriodCopyWith<$Res> get validityPeriod;
  @override
  $PeriodCopyWith<$Res> get dataExclusivityPeriod;
  @override
  $CodeableConceptCopyWith<$Res> get legalBasis;
  @override
  $ReferenceCopyWith<$Res> get holder;
  @override
  $ReferenceCopyWith<$Res> get regulator;
  @override
  $MedicinalProductAuthorizationProcedureCopyWith<$Res> get procedure;
}

class __$MedicinalProductAuthorizationCopyWithImpl<$Res>
    extends _$MedicinalProductAuthorizationCopyWithImpl<$Res>
    implements _$MedicinalProductAuthorizationCopyWith<$Res> {
  __$MedicinalProductAuthorizationCopyWithImpl(
      _MedicinalProductAuthorization _value,
      $Res Function(_MedicinalProductAuthorization) _then)
      : super(_value, (v) => _then(v as _MedicinalProductAuthorization));

  @override
  _MedicinalProductAuthorization get _value =>
      super._value as _MedicinalProductAuthorization;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object subject = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object status = freezed,
    Object statusDate = freezed,
    Object restoreDate = freezed,
    Object validityPeriod = freezed,
    Object dataExclusivityPeriod = freezed,
    Object dateOfFirstAuthorization = freezed,
    Object internationalBirthDate = freezed,
    Object legalBasis = freezed,
    Object jurisdictionalAuthorization = freezed,
    Object holder = freezed,
    Object regulator = freezed,
    Object procedure = freezed,
  }) {
    return _then(_MedicinalProductAuthorization(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      subject: subject == freezed ? _value.subject : subject as Reference,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      status: status == freezed ? _value.status : status as CodeableConcept,
      statusDate: statusDate == freezed
          ? _value.statusDate
          : statusDate as FhirDateTime,
      restoreDate: restoreDate == freezed
          ? _value.restoreDate
          : restoreDate as FhirDateTime,
      validityPeriod: validityPeriod == freezed
          ? _value.validityPeriod
          : validityPeriod as Period,
      dataExclusivityPeriod: dataExclusivityPeriod == freezed
          ? _value.dataExclusivityPeriod
          : dataExclusivityPeriod as Period,
      dateOfFirstAuthorization: dateOfFirstAuthorization == freezed
          ? _value.dateOfFirstAuthorization
          : dateOfFirstAuthorization as FhirDateTime,
      internationalBirthDate: internationalBirthDate == freezed
          ? _value.internationalBirthDate
          : internationalBirthDate as FhirDateTime,
      legalBasis: legalBasis == freezed
          ? _value.legalBasis
          : legalBasis as CodeableConcept,
      jurisdictionalAuthorization: jurisdictionalAuthorization == freezed
          ? _value.jurisdictionalAuthorization
          : jurisdictionalAuthorization
              as List<MedicinalProductAuthorizationJurisdictionalAuthorization>,
      holder: holder == freezed ? _value.holder : holder as Reference,
      regulator:
          regulator == freezed ? _value.regulator : regulator as Reference,
      procedure: procedure == freezed
          ? _value.procedure
          : procedure as MedicinalProductAuthorizationProcedure,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductAuthorization
    implements _MedicinalProductAuthorization {
  const _$_MedicinalProductAuthorization(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.subject,
      this.country,
      this.jurisdiction,
      this.status,
      this.statusDate,
      this.restoreDate,
      this.validityPeriod,
      this.dataExclusivityPeriod,
      this.dateOfFirstAuthorization,
      this.internationalBirthDate,
      this.legalBasis,
      this.jurisdictionalAuthorization,
      this.holder,
      this.regulator,
      this.procedure})
      : assert(resourceType != null);

  factory _$_MedicinalProductAuthorization.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductAuthorizationFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final Reference subject;
  @override
  final List<CodeableConcept> country;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final CodeableConcept status;
  @override
  final FhirDateTime statusDate;
  @override
  final FhirDateTime restoreDate;
  @override
  final Period validityPeriod;
  @override
  final Period dataExclusivityPeriod;
  @override
  final FhirDateTime dateOfFirstAuthorization;
  @override
  final FhirDateTime internationalBirthDate;
  @override
  final CodeableConcept legalBasis;
  @override
  final List<MedicinalProductAuthorizationJurisdictionalAuthorization>
      jurisdictionalAuthorization;
  @override
  final Reference holder;
  @override
  final Reference regulator;
  @override
  final MedicinalProductAuthorizationProcedure procedure;

  @override
  String toString() {
    return 'MedicinalProductAuthorization(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, subject: $subject, country: $country, jurisdiction: $jurisdiction, status: $status, statusDate: $statusDate, restoreDate: $restoreDate, validityPeriod: $validityPeriod, dataExclusivityPeriod: $dataExclusivityPeriod, dateOfFirstAuthorization: $dateOfFirstAuthorization, internationalBirthDate: $internationalBirthDate, legalBasis: $legalBasis, jurisdictionalAuthorization: $jurisdictionalAuthorization, holder: $holder, regulator: $regulator, procedure: $procedure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductAuthorization &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.statusDate, statusDate) ||
                const DeepCollectionEquality()
                    .equals(other.statusDate, statusDate)) &&
            (identical(other.restoreDate, restoreDate) ||
                const DeepCollectionEquality()
                    .equals(other.restoreDate, restoreDate)) &&
            (identical(other.validityPeriod, validityPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.validityPeriod, validityPeriod)) &&
            (identical(other.dataExclusivityPeriod, dataExclusivityPeriod) ||
                const DeepCollectionEquality().equals(
                    other.dataExclusivityPeriod, dataExclusivityPeriod)) &&
            (identical(other.dateOfFirstAuthorization, dateOfFirstAuthorization) ||
                const DeepCollectionEquality().equals(
                    other.dateOfFirstAuthorization,
                    dateOfFirstAuthorization)) &&
            (identical(other.internationalBirthDate, internationalBirthDate) ||
                const DeepCollectionEquality().equals(
                    other.internationalBirthDate, internationalBirthDate)) &&
            (identical(other.legalBasis, legalBasis) ||
                const DeepCollectionEquality()
                    .equals(other.legalBasis, legalBasis)) &&
            (identical(other.jurisdictionalAuthorization, jurisdictionalAuthorization) ||
                const DeepCollectionEquality().equals(
                    other.jurisdictionalAuthorization, jurisdictionalAuthorization)) &&
            (identical(other.holder, holder) || const DeepCollectionEquality().equals(other.holder, holder)) &&
            (identical(other.regulator, regulator) || const DeepCollectionEquality().equals(other.regulator, regulator)) &&
            (identical(other.procedure, procedure) || const DeepCollectionEquality().equals(other.procedure, procedure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(statusDate) ^
      const DeepCollectionEquality().hash(restoreDate) ^
      const DeepCollectionEquality().hash(validityPeriod) ^
      const DeepCollectionEquality().hash(dataExclusivityPeriod) ^
      const DeepCollectionEquality().hash(dateOfFirstAuthorization) ^
      const DeepCollectionEquality().hash(internationalBirthDate) ^
      const DeepCollectionEquality().hash(legalBasis) ^
      const DeepCollectionEquality().hash(jurisdictionalAuthorization) ^
      const DeepCollectionEquality().hash(holder) ^
      const DeepCollectionEquality().hash(regulator) ^
      const DeepCollectionEquality().hash(procedure);

  @override
  _$MedicinalProductAuthorizationCopyWith<_MedicinalProductAuthorization>
      get copyWith => __$MedicinalProductAuthorizationCopyWithImpl<
          _MedicinalProductAuthorization>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductAuthorizationToJson(this);
  }
}

abstract class _MedicinalProductAuthorization
    implements MedicinalProductAuthorization {
  const factory _MedicinalProductAuthorization(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      Reference subject,
      List<CodeableConcept> country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept status,
      FhirDateTime statusDate,
      FhirDateTime restoreDate,
      Period validityPeriod,
      Period dataExclusivityPeriod,
      FhirDateTime dateOfFirstAuthorization,
      FhirDateTime internationalBirthDate,
      CodeableConcept legalBasis,
      List<MedicinalProductAuthorizationJurisdictionalAuthorization>
          jurisdictionalAuthorization,
      Reference holder,
      Reference regulator,
      MedicinalProductAuthorizationProcedure
          procedure}) = _$_MedicinalProductAuthorization;

  factory _MedicinalProductAuthorization.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductAuthorization.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductAuthorization')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  Reference get subject;
  @override
  List<CodeableConcept> get country;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  CodeableConcept get status;
  @override
  FhirDateTime get statusDate;
  @override
  FhirDateTime get restoreDate;
  @override
  Period get validityPeriod;
  @override
  Period get dataExclusivityPeriod;
  @override
  FhirDateTime get dateOfFirstAuthorization;
  @override
  FhirDateTime get internationalBirthDate;
  @override
  CodeableConcept get legalBasis;
  @override
  List<MedicinalProductAuthorizationJurisdictionalAuthorization>
      get jurisdictionalAuthorization;
  @override
  Reference get holder;
  @override
  Reference get regulator;
  @override
  MedicinalProductAuthorizationProcedure get procedure;
  @override
  _$MedicinalProductAuthorizationCopyWith<_MedicinalProductAuthorization>
      get copyWith;
}

MedicinalProductAuthorizationJurisdictionalAuthorization
    _$MedicinalProductAuthorizationJurisdictionalAuthorizationFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductAuthorizationJurisdictionalAuthorization.fromJson(
      json);
}

class _$MedicinalProductAuthorizationJurisdictionalAuthorizationTearOff {
  const _$MedicinalProductAuthorizationJurisdictionalAuthorizationTearOff();

  _MedicinalProductAuthorizationJurisdictionalAuthorization call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept legalStatusOfSupply,
      Period validityPeriod}) {
    return _MedicinalProductAuthorizationJurisdictionalAuthorization(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      country: country,
      jurisdiction: jurisdiction,
      legalStatusOfSupply: legalStatusOfSupply,
      validityPeriod: validityPeriod,
    );
  }
}

// ignore: unused_element
const $MedicinalProductAuthorizationJurisdictionalAuthorization =
    _$MedicinalProductAuthorizationJurisdictionalAuthorizationTearOff();

mixin _$MedicinalProductAuthorizationJurisdictionalAuthorization {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  CodeableConcept get country;
  List<CodeableConcept> get jurisdiction;
  CodeableConcept get legalStatusOfSupply;
  Period get validityPeriod;

  Map<String, dynamic> toJson();
  $MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
      MedicinalProductAuthorizationJurisdictionalAuthorization> get copyWith;
}

abstract class $MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
    $Res> {
  factory $MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith(
          MedicinalProductAuthorizationJurisdictionalAuthorization value,
          $Res Function(
                  MedicinalProductAuthorizationJurisdictionalAuthorization)
              then) =
      _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
          $Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept legalStatusOfSupply,
      Period validityPeriod});

  $CodeableConceptCopyWith<$Res> get country;
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  $PeriodCopyWith<$Res> get validityPeriod;
}

class _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
        $Res>
    implements
        $MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
            $Res> {
  _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl(
      this._value, this._then);

  final MedicinalProductAuthorizationJurisdictionalAuthorization _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductAuthorizationJurisdictionalAuthorization)
      _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object legalStatusOfSupply = freezed,
    Object validityPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      country: country == freezed ? _value.country : country as CodeableConcept,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      validityPeriod: validityPeriod == freezed
          ? _value.validityPeriod
          : validityPeriod as Period,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get country {
    if (_value.country == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.country, (value) {
      return _then(_value.copyWith(country: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply {
    if (_value.legalStatusOfSupply == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.legalStatusOfSupply, (value) {
      return _then(_value.copyWith(legalStatusOfSupply: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get validityPeriod {
    if (_value.validityPeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.validityPeriod, (value) {
      return _then(_value.copyWith(validityPeriod: value));
    });
  }
}

abstract class _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
        $Res>
    implements
        $MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
            $Res> {
  factory _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith(
          _MedicinalProductAuthorizationJurisdictionalAuthorization value,
          $Res Function(
                  _MedicinalProductAuthorizationJurisdictionalAuthorization)
              then) =
      __$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
          $Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      CodeableConcept country,
      List<CodeableConcept> jurisdiction,
      CodeableConcept legalStatusOfSupply,
      Period validityPeriod});

  @override
  $CodeableConceptCopyWith<$Res> get country;
  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  @override
  $PeriodCopyWith<$Res> get validityPeriod;
}

class __$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
        $Res>
    extends _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
        $Res>
    implements
        _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
            $Res> {
  __$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl(
      _MedicinalProductAuthorizationJurisdictionalAuthorization _value,
      $Res Function(_MedicinalProductAuthorizationJurisdictionalAuthorization)
          _then)
      : super(
            _value,
            (v) => _then(v
                as _MedicinalProductAuthorizationJurisdictionalAuthorization));

  @override
  _MedicinalProductAuthorizationJurisdictionalAuthorization get _value =>
      super._value as _MedicinalProductAuthorizationJurisdictionalAuthorization;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object country = freezed,
    Object jurisdiction = freezed,
    Object legalStatusOfSupply = freezed,
    Object validityPeriod = freezed,
  }) {
    return _then(_MedicinalProductAuthorizationJurisdictionalAuthorization(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      country: country == freezed ? _value.country : country as CodeableConcept,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      validityPeriod: validityPeriod == freezed
          ? _value.validityPeriod
          : validityPeriod as Period,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductAuthorizationJurisdictionalAuthorization
    implements _MedicinalProductAuthorizationJurisdictionalAuthorization {
  const _$_MedicinalProductAuthorizationJurisdictionalAuthorization(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      this.country,
      this.jurisdiction,
      this.legalStatusOfSupply,
      this.validityPeriod});

  factory _$_MedicinalProductAuthorizationJurisdictionalAuthorization.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductAuthorizationJurisdictionalAuthorizationFromJson(
          json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final CodeableConcept country;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final CodeableConcept legalStatusOfSupply;
  @override
  final Period validityPeriod;

  @override
  String toString() {
    return 'MedicinalProductAuthorizationJurisdictionalAuthorization(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, country: $country, jurisdiction: $jurisdiction, legalStatusOfSupply: $legalStatusOfSupply, validityPeriod: $validityPeriod)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductAuthorizationJurisdictionalAuthorization &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.legalStatusOfSupply, legalStatusOfSupply) ||
                const DeepCollectionEquality()
                    .equals(other.legalStatusOfSupply, legalStatusOfSupply)) &&
            (identical(other.validityPeriod, validityPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.validityPeriod, validityPeriod)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(legalStatusOfSupply) ^
      const DeepCollectionEquality().hash(validityPeriod);

  @override
  _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
          _MedicinalProductAuthorizationJurisdictionalAuthorization>
      get copyWith =>
          __$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWithImpl<
                  _MedicinalProductAuthorizationJurisdictionalAuthorization>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductAuthorizationJurisdictionalAuthorizationToJson(
        this);
  }
}

abstract class _MedicinalProductAuthorizationJurisdictionalAuthorization
    implements MedicinalProductAuthorizationJurisdictionalAuthorization {
  const factory _MedicinalProductAuthorizationJurisdictionalAuthorization(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          List<Identifier> identifier,
          CodeableConcept country,
          List<CodeableConcept> jurisdiction,
          CodeableConcept legalStatusOfSupply,
          Period validityPeriod}) =
      _$_MedicinalProductAuthorizationJurisdictionalAuthorization;

  factory _MedicinalProductAuthorizationJurisdictionalAuthorization.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductAuthorizationJurisdictionalAuthorization.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  CodeableConcept get country;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  CodeableConcept get legalStatusOfSupply;
  @override
  Period get validityPeriod;
  @override
  _$MedicinalProductAuthorizationJurisdictionalAuthorizationCopyWith<
      _MedicinalProductAuthorizationJurisdictionalAuthorization> get copyWith;
}

MedicinalProductAuthorizationProcedure
    _$MedicinalProductAuthorizationProcedureFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductAuthorizationProcedure.fromJson(json);
}

class _$MedicinalProductAuthorizationProcedureTearOff {
  const _$MedicinalProductAuthorizationProcedureTearOff();

  _MedicinalProductAuthorizationProcedure call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @required @JsonKey(required: true) CodeableConcept type,
      Period datePeriod,
      FhirDateTime dateDateTime,
      List<MedicinalProductAuthorizationProcedure> application}) {
    return _MedicinalProductAuthorizationProcedure(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      type: type,
      datePeriod: datePeriod,
      dateDateTime: dateDateTime,
      application: application,
    );
  }
}

// ignore: unused_element
const $MedicinalProductAuthorizationProcedure =
    _$MedicinalProductAuthorizationProcedureTearOff();

mixin _$MedicinalProductAuthorizationProcedure {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  @JsonKey(required: true)
  CodeableConcept get type;
  Period get datePeriod;
  FhirDateTime get dateDateTime;
  List<MedicinalProductAuthorizationProcedure> get application;

  Map<String, dynamic> toJson();
  $MedicinalProductAuthorizationProcedureCopyWith<
      MedicinalProductAuthorizationProcedure> get copyWith;
}

abstract class $MedicinalProductAuthorizationProcedureCopyWith<$Res> {
  factory $MedicinalProductAuthorizationProcedureCopyWith(
          MedicinalProductAuthorizationProcedure value,
          $Res Function(MedicinalProductAuthorizationProcedure) then) =
      _$MedicinalProductAuthorizationProcedureCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @JsonKey(required: true) CodeableConcept type,
      Period datePeriod,
      FhirDateTime dateDateTime,
      List<MedicinalProductAuthorizationProcedure> application});

  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get type;
  $PeriodCopyWith<$Res> get datePeriod;
}

class _$MedicinalProductAuthorizationProcedureCopyWithImpl<$Res>
    implements $MedicinalProductAuthorizationProcedureCopyWith<$Res> {
  _$MedicinalProductAuthorizationProcedureCopyWithImpl(this._value, this._then);

  final MedicinalProductAuthorizationProcedure _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductAuthorizationProcedure) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object datePeriod = freezed,
    Object dateDateTime = freezed,
    Object application = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      datePeriod:
          datePeriod == freezed ? _value.datePeriod : datePeriod as Period,
      dateDateTime: dateDateTime == freezed
          ? _value.dateDateTime
          : dateDateTime as FhirDateTime,
      application: application == freezed
          ? _value.application
          : application as List<MedicinalProductAuthorizationProcedure>,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get datePeriod {
    if (_value.datePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.datePeriod, (value) {
      return _then(_value.copyWith(datePeriod: value));
    });
  }
}

abstract class _$MedicinalProductAuthorizationProcedureCopyWith<$Res>
    implements $MedicinalProductAuthorizationProcedureCopyWith<$Res> {
  factory _$MedicinalProductAuthorizationProcedureCopyWith(
          _MedicinalProductAuthorizationProcedure value,
          $Res Function(_MedicinalProductAuthorizationProcedure) then) =
      __$MedicinalProductAuthorizationProcedureCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @JsonKey(required: true) CodeableConcept type,
      Period datePeriod,
      FhirDateTime dateDateTime,
      List<MedicinalProductAuthorizationProcedure> application});

  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $PeriodCopyWith<$Res> get datePeriod;
}

class __$MedicinalProductAuthorizationProcedureCopyWithImpl<$Res>
    extends _$MedicinalProductAuthorizationProcedureCopyWithImpl<$Res>
    implements _$MedicinalProductAuthorizationProcedureCopyWith<$Res> {
  __$MedicinalProductAuthorizationProcedureCopyWithImpl(
      _MedicinalProductAuthorizationProcedure _value,
      $Res Function(_MedicinalProductAuthorizationProcedure) _then)
      : super(
            _value, (v) => _then(v as _MedicinalProductAuthorizationProcedure));

  @override
  _MedicinalProductAuthorizationProcedure get _value =>
      super._value as _MedicinalProductAuthorizationProcedure;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object datePeriod = freezed,
    Object dateDateTime = freezed,
    Object application = freezed,
  }) {
    return _then(_MedicinalProductAuthorizationProcedure(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      datePeriod:
          datePeriod == freezed ? _value.datePeriod : datePeriod as Period,
      dateDateTime: dateDateTime == freezed
          ? _value.dateDateTime
          : dateDateTime as FhirDateTime,
      application: application == freezed
          ? _value.application
          : application as List<MedicinalProductAuthorizationProcedure>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductAuthorizationProcedure
    implements _MedicinalProductAuthorizationProcedure {
  const _$_MedicinalProductAuthorizationProcedure(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      @required @JsonKey(required: true) this.type,
      this.datePeriod,
      this.dateDateTime,
      this.application})
      : assert(type != null);

  factory _$_MedicinalProductAuthorizationProcedure.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductAuthorizationProcedureFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  @JsonKey(required: true)
  final CodeableConcept type;
  @override
  final Period datePeriod;
  @override
  final FhirDateTime dateDateTime;
  @override
  final List<MedicinalProductAuthorizationProcedure> application;

  @override
  String toString() {
    return 'MedicinalProductAuthorizationProcedure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, datePeriod: $datePeriod, dateDateTime: $dateDateTime, application: $application)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductAuthorizationProcedure &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.datePeriod, datePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.datePeriod, datePeriod)) &&
            (identical(other.dateDateTime, dateDateTime) ||
                const DeepCollectionEquality()
                    .equals(other.dateDateTime, dateDateTime)) &&
            (identical(other.application, application) ||
                const DeepCollectionEquality()
                    .equals(other.application, application)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(datePeriod) ^
      const DeepCollectionEquality().hash(dateDateTime) ^
      const DeepCollectionEquality().hash(application);

  @override
  _$MedicinalProductAuthorizationProcedureCopyWith<
          _MedicinalProductAuthorizationProcedure>
      get copyWith => __$MedicinalProductAuthorizationProcedureCopyWithImpl<
          _MedicinalProductAuthorizationProcedure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductAuthorizationProcedureToJson(this);
  }
}

abstract class _MedicinalProductAuthorizationProcedure
    implements MedicinalProductAuthorizationProcedure {
  const factory _MedicinalProductAuthorizationProcedure(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Identifier identifier,
          @required @JsonKey(required: true) CodeableConcept type,
          Period datePeriod,
          FhirDateTime dateDateTime,
          List<MedicinalProductAuthorizationProcedure> application}) =
      _$_MedicinalProductAuthorizationProcedure;

  factory _MedicinalProductAuthorizationProcedure.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductAuthorizationProcedure.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  @JsonKey(required: true)
  CodeableConcept get type;
  @override
  Period get datePeriod;
  @override
  FhirDateTime get dateDateTime;
  @override
  List<MedicinalProductAuthorizationProcedure> get application;
  @override
  _$MedicinalProductAuthorizationProcedureCopyWith<
      _MedicinalProductAuthorizationProcedure> get copyWith;
}

MedicinalProductContraindication _$MedicinalProductContraindicationFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductContraindication.fromJson(json);
}

class _$MedicinalProductContraindicationTearOff {
  const _$MedicinalProductContraindicationTearOff();

  _MedicinalProductContraindication call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept disease,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      List<Reference> therapeuticIndication,
      List<MedicinalProductContraindicationOtherTherapy> otherTherapy,
      List<Population> population}) {
    return _MedicinalProductContraindication(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subject: subject,
      disease: disease,
      diseaseStatus: diseaseStatus,
      comorbidity: comorbidity,
      therapeuticIndication: therapeuticIndication,
      otherTherapy: otherTherapy,
      population: population,
    );
  }
}

// ignore: unused_element
const $MedicinalProductContraindication =
    _$MedicinalProductContraindicationTearOff();

mixin _$MedicinalProductContraindication {
  @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Reference> get subject;
  CodeableConcept get disease;
  CodeableConcept get diseaseStatus;
  List<CodeableConcept> get comorbidity;
  List<Reference> get therapeuticIndication;
  List<MedicinalProductContraindicationOtherTherapy> get otherTherapy;
  List<Population> get population;

  Map<String, dynamic> toJson();
  $MedicinalProductContraindicationCopyWith<MedicinalProductContraindication>
      get copyWith;
}

abstract class $MedicinalProductContraindicationCopyWith<$Res> {
  factory $MedicinalProductContraindicationCopyWith(
          MedicinalProductContraindication value,
          $Res Function(MedicinalProductContraindication) then) =
      _$MedicinalProductContraindicationCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept disease,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      List<Reference> therapeuticIndication,
      List<MedicinalProductContraindicationOtherTherapy> otherTherapy,
      List<Population> population});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get disease;
  $CodeableConceptCopyWith<$Res> get diseaseStatus;
}

class _$MedicinalProductContraindicationCopyWithImpl<$Res>
    implements $MedicinalProductContraindicationCopyWith<$Res> {
  _$MedicinalProductContraindicationCopyWithImpl(this._value, this._then);

  final MedicinalProductContraindication _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductContraindication) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object disease = freezed,
    Object diseaseStatus = freezed,
    Object comorbidity = freezed,
    Object therapeuticIndication = freezed,
    Object otherTherapy = freezed,
    Object population = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      disease: disease == freezed ? _value.disease : disease as CodeableConcept,
      diseaseStatus: diseaseStatus == freezed
          ? _value.diseaseStatus
          : diseaseStatus as CodeableConcept,
      comorbidity: comorbidity == freezed
          ? _value.comorbidity
          : comorbidity as List<CodeableConcept>,
      therapeuticIndication: therapeuticIndication == freezed
          ? _value.therapeuticIndication
          : therapeuticIndication as List<Reference>,
      otherTherapy: otherTherapy == freezed
          ? _value.otherTherapy
          : otherTherapy as List<MedicinalProductContraindicationOtherTherapy>,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get disease {
    if (_value.disease == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.disease, (value) {
      return _then(_value.copyWith(disease: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.diseaseStatus, (value) {
      return _then(_value.copyWith(diseaseStatus: value));
    });
  }
}

abstract class _$MedicinalProductContraindicationCopyWith<$Res>
    implements $MedicinalProductContraindicationCopyWith<$Res> {
  factory _$MedicinalProductContraindicationCopyWith(
          _MedicinalProductContraindication value,
          $Res Function(_MedicinalProductContraindication) then) =
      __$MedicinalProductContraindicationCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept disease,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      List<Reference> therapeuticIndication,
      List<MedicinalProductContraindicationOtherTherapy> otherTherapy,
      List<Population> population});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get disease;
  @override
  $CodeableConceptCopyWith<$Res> get diseaseStatus;
}

class __$MedicinalProductContraindicationCopyWithImpl<$Res>
    extends _$MedicinalProductContraindicationCopyWithImpl<$Res>
    implements _$MedicinalProductContraindicationCopyWith<$Res> {
  __$MedicinalProductContraindicationCopyWithImpl(
      _MedicinalProductContraindication _value,
      $Res Function(_MedicinalProductContraindication) _then)
      : super(_value, (v) => _then(v as _MedicinalProductContraindication));

  @override
  _MedicinalProductContraindication get _value =>
      super._value as _MedicinalProductContraindication;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object disease = freezed,
    Object diseaseStatus = freezed,
    Object comorbidity = freezed,
    Object therapeuticIndication = freezed,
    Object otherTherapy = freezed,
    Object population = freezed,
  }) {
    return _then(_MedicinalProductContraindication(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      disease: disease == freezed ? _value.disease : disease as CodeableConcept,
      diseaseStatus: diseaseStatus == freezed
          ? _value.diseaseStatus
          : diseaseStatus as CodeableConcept,
      comorbidity: comorbidity == freezed
          ? _value.comorbidity
          : comorbidity as List<CodeableConcept>,
      therapeuticIndication: therapeuticIndication == freezed
          ? _value.therapeuticIndication
          : therapeuticIndication as List<Reference>,
      otherTherapy: otherTherapy == freezed
          ? _value.otherTherapy
          : otherTherapy as List<MedicinalProductContraindicationOtherTherapy>,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductContraindication
    implements _MedicinalProductContraindication {
  const _$_MedicinalProductContraindication(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.subject,
      this.disease,
      this.diseaseStatus,
      this.comorbidity,
      this.therapeuticIndication,
      this.otherTherapy,
      this.population})
      : assert(resourceType != null);

  factory _$_MedicinalProductContraindication.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductContraindicationFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Reference> subject;
  @override
  final CodeableConcept disease;
  @override
  final CodeableConcept diseaseStatus;
  @override
  final List<CodeableConcept> comorbidity;
  @override
  final List<Reference> therapeuticIndication;
  @override
  final List<MedicinalProductContraindicationOtherTherapy> otherTherapy;
  @override
  final List<Population> population;

  @override
  String toString() {
    return 'MedicinalProductContraindication(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, subject: $subject, disease: $disease, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, therapeuticIndication: $therapeuticIndication, otherTherapy: $otherTherapy, population: $population)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductContraindication &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.disease, disease) ||
                const DeepCollectionEquality()
                    .equals(other.disease, disease)) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                const DeepCollectionEquality()
                    .equals(other.diseaseStatus, diseaseStatus)) &&
            (identical(other.comorbidity, comorbidity) ||
                const DeepCollectionEquality()
                    .equals(other.comorbidity, comorbidity)) &&
            (identical(other.therapeuticIndication, therapeuticIndication) ||
                const DeepCollectionEquality().equals(
                    other.therapeuticIndication, therapeuticIndication)) &&
            (identical(other.otherTherapy, otherTherapy) ||
                const DeepCollectionEquality()
                    .equals(other.otherTherapy, otherTherapy)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(disease) ^
      const DeepCollectionEquality().hash(diseaseStatus) ^
      const DeepCollectionEquality().hash(comorbidity) ^
      const DeepCollectionEquality().hash(therapeuticIndication) ^
      const DeepCollectionEquality().hash(otherTherapy) ^
      const DeepCollectionEquality().hash(population);

  @override
  _$MedicinalProductContraindicationCopyWith<_MedicinalProductContraindication>
      get copyWith => __$MedicinalProductContraindicationCopyWithImpl<
          _MedicinalProductContraindication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductContraindicationToJson(this);
  }
}

abstract class _MedicinalProductContraindication
    implements MedicinalProductContraindication {
  const factory _MedicinalProductContraindication(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept disease,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      List<Reference> therapeuticIndication,
      List<MedicinalProductContraindicationOtherTherapy> otherTherapy,
      List<Population> population}) = _$_MedicinalProductContraindication;

  factory _MedicinalProductContraindication.fromJson(
      Map<String, dynamic> json) = _$_MedicinalProductContraindication.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductContraindication')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Reference> get subject;
  @override
  CodeableConcept get disease;
  @override
  CodeableConcept get diseaseStatus;
  @override
  List<CodeableConcept> get comorbidity;
  @override
  List<Reference> get therapeuticIndication;
  @override
  List<MedicinalProductContraindicationOtherTherapy> get otherTherapy;
  @override
  List<Population> get population;
  @override
  _$MedicinalProductContraindicationCopyWith<_MedicinalProductContraindication>
      get copyWith;
}

MedicinalProductContraindicationOtherTherapy
    _$MedicinalProductContraindicationOtherTherapyFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductContraindicationOtherTherapy.fromJson(json);
}

class _$MedicinalProductContraindicationOtherTherapyTearOff {
  const _$MedicinalProductContraindicationOtherTherapyTearOff();

  _MedicinalProductContraindicationOtherTherapy call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required
      @JsonKey(required: true)
          CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference}) {
    return _MedicinalProductContraindicationOtherTherapy(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      therapyRelationshipType: therapyRelationshipType,
      medicationCodeableConcept: medicationCodeableConcept,
      medicationReference: medicationReference,
    );
  }
}

// ignore: unused_element
const $MedicinalProductContraindicationOtherTherapy =
    _$MedicinalProductContraindicationOtherTherapyTearOff();

mixin _$MedicinalProductContraindicationOtherTherapy {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get therapyRelationshipType;
  CodeableConcept get medicationCodeableConcept;
  Reference get medicationReference;

  Map<String, dynamic> toJson();
  $MedicinalProductContraindicationOtherTherapyCopyWith<
      MedicinalProductContraindicationOtherTherapy> get copyWith;
}

abstract class $MedicinalProductContraindicationOtherTherapyCopyWith<$Res> {
  factory $MedicinalProductContraindicationOtherTherapyCopyWith(
          MedicinalProductContraindicationOtherTherapy value,
          $Res Function(MedicinalProductContraindicationOtherTherapy) then) =
      _$MedicinalProductContraindicationOtherTherapyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference});

  $CodeableConceptCopyWith<$Res> get therapyRelationshipType;
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept;
  $ReferenceCopyWith<$Res> get medicationReference;
}

class _$MedicinalProductContraindicationOtherTherapyCopyWithImpl<$Res>
    implements $MedicinalProductContraindicationOtherTherapyCopyWith<$Res> {
  _$MedicinalProductContraindicationOtherTherapyCopyWithImpl(
      this._value, this._then);

  final MedicinalProductContraindicationOtherTherapy _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductContraindicationOtherTherapy) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object therapyRelationshipType = freezed,
    Object medicationCodeableConcept = freezed,
    Object medicationReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      therapyRelationshipType: therapyRelationshipType == freezed
          ? _value.therapyRelationshipType
          : therapyRelationshipType as CodeableConcept,
      medicationCodeableConcept: medicationCodeableConcept == freezed
          ? _value.medicationCodeableConcept
          : medicationCodeableConcept as CodeableConcept,
      medicationReference: medicationReference == freezed
          ? _value.medicationReference
          : medicationReference as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get therapyRelationshipType {
    if (_value.therapyRelationshipType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.therapyRelationshipType,
        (value) {
      return _then(_value.copyWith(therapyRelationshipType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept {
    if (_value.medicationCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.medicationCodeableConcept,
        (value) {
      return _then(_value.copyWith(medicationCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get medicationReference {
    if (_value.medicationReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.medicationReference, (value) {
      return _then(_value.copyWith(medicationReference: value));
    });
  }
}

abstract class _$MedicinalProductContraindicationOtherTherapyCopyWith<$Res>
    implements $MedicinalProductContraindicationOtherTherapyCopyWith<$Res> {
  factory _$MedicinalProductContraindicationOtherTherapyCopyWith(
          _MedicinalProductContraindicationOtherTherapy value,
          $Res Function(_MedicinalProductContraindicationOtherTherapy) then) =
      __$MedicinalProductContraindicationOtherTherapyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference});

  @override
  $CodeableConceptCopyWith<$Res> get therapyRelationshipType;
  @override
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get medicationReference;
}

class __$MedicinalProductContraindicationOtherTherapyCopyWithImpl<$Res>
    extends _$MedicinalProductContraindicationOtherTherapyCopyWithImpl<$Res>
    implements _$MedicinalProductContraindicationOtherTherapyCopyWith<$Res> {
  __$MedicinalProductContraindicationOtherTherapyCopyWithImpl(
      _MedicinalProductContraindicationOtherTherapy _value,
      $Res Function(_MedicinalProductContraindicationOtherTherapy) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductContraindicationOtherTherapy));

  @override
  _MedicinalProductContraindicationOtherTherapy get _value =>
      super._value as _MedicinalProductContraindicationOtherTherapy;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object therapyRelationshipType = freezed,
    Object medicationCodeableConcept = freezed,
    Object medicationReference = freezed,
  }) {
    return _then(_MedicinalProductContraindicationOtherTherapy(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      therapyRelationshipType: therapyRelationshipType == freezed
          ? _value.therapyRelationshipType
          : therapyRelationshipType as CodeableConcept,
      medicationCodeableConcept: medicationCodeableConcept == freezed
          ? _value.medicationCodeableConcept
          : medicationCodeableConcept as CodeableConcept,
      medicationReference: medicationReference == freezed
          ? _value.medicationReference
          : medicationReference as Reference,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductContraindicationOtherTherapy
    implements _MedicinalProductContraindicationOtherTherapy {
  const _$_MedicinalProductContraindicationOtherTherapy(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.therapyRelationshipType,
      this.medicationCodeableConcept,
      this.medicationReference})
      : assert(therapyRelationshipType != null);

  factory _$_MedicinalProductContraindicationOtherTherapy.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductContraindicationOtherTherapyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept therapyRelationshipType;
  @override
  final CodeableConcept medicationCodeableConcept;
  @override
  final Reference medicationReference;

  @override
  String toString() {
    return 'MedicinalProductContraindicationOtherTherapy(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, therapyRelationshipType: $therapyRelationshipType, medicationCodeableConcept: $medicationCodeableConcept, medicationReference: $medicationReference)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductContraindicationOtherTherapy &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(
                    other.therapyRelationshipType, therapyRelationshipType) ||
                const DeepCollectionEquality().equals(
                    other.therapyRelationshipType, therapyRelationshipType)) &&
            (identical(other.medicationCodeableConcept,
                    medicationCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.medicationCodeableConcept,
                    medicationCodeableConcept)) &&
            (identical(other.medicationReference, medicationReference) ||
                const DeepCollectionEquality()
                    .equals(other.medicationReference, medicationReference)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(therapyRelationshipType) ^
      const DeepCollectionEquality().hash(medicationCodeableConcept) ^
      const DeepCollectionEquality().hash(medicationReference);

  @override
  _$MedicinalProductContraindicationOtherTherapyCopyWith<
          _MedicinalProductContraindicationOtherTherapy>
      get copyWith =>
          __$MedicinalProductContraindicationOtherTherapyCopyWithImpl<
              _MedicinalProductContraindicationOtherTherapy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductContraindicationOtherTherapyToJson(this);
  }
}

abstract class _MedicinalProductContraindicationOtherTherapy
    implements MedicinalProductContraindicationOtherTherapy {
  const factory _MedicinalProductContraindicationOtherTherapy(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required
          @JsonKey(required: true)
              CodeableConcept therapyRelationshipType,
          CodeableConcept medicationCodeableConcept,
          Reference medicationReference}) =
      _$_MedicinalProductContraindicationOtherTherapy;

  factory _MedicinalProductContraindicationOtherTherapy.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductContraindicationOtherTherapy.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get therapyRelationshipType;
  @override
  CodeableConcept get medicationCodeableConcept;
  @override
  Reference get medicationReference;
  @override
  _$MedicinalProductContraindicationOtherTherapyCopyWith<
      _MedicinalProductContraindicationOtherTherapy> get copyWith;
}

MedicinalProductIndication _$MedicinalProductIndicationFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductIndication.fromJson(json);
}

class _$MedicinalProductIndicationTearOff {
  const _$MedicinalProductIndicationTearOff();

  _MedicinalProductIndication call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept diseaseSymptomProcedure,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      CodeableConcept intendedEffect,
      Quantity duration,
      List<MedicinalProductIndicationOtherTherapy> otherTherapy,
      List<Reference> undesirableEffect,
      List<Population> population}) {
    return _MedicinalProductIndication(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subject: subject,
      diseaseSymptomProcedure: diseaseSymptomProcedure,
      diseaseStatus: diseaseStatus,
      comorbidity: comorbidity,
      intendedEffect: intendedEffect,
      duration: duration,
      otherTherapy: otherTherapy,
      undesirableEffect: undesirableEffect,
      population: population,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIndication = _$MedicinalProductIndicationTearOff();

mixin _$MedicinalProductIndication {
  @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Reference> get subject;
  CodeableConcept get diseaseSymptomProcedure;
  CodeableConcept get diseaseStatus;
  List<CodeableConcept> get comorbidity;
  CodeableConcept get intendedEffect;
  Quantity get duration;
  List<MedicinalProductIndicationOtherTherapy> get otherTherapy;
  List<Reference> get undesirableEffect;
  List<Population> get population;

  Map<String, dynamic> toJson();
  $MedicinalProductIndicationCopyWith<MedicinalProductIndication> get copyWith;
}

abstract class $MedicinalProductIndicationCopyWith<$Res> {
  factory $MedicinalProductIndicationCopyWith(MedicinalProductIndication value,
          $Res Function(MedicinalProductIndication) then) =
      _$MedicinalProductIndicationCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept diseaseSymptomProcedure,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      CodeableConcept intendedEffect,
      Quantity duration,
      List<MedicinalProductIndicationOtherTherapy> otherTherapy,
      List<Reference> undesirableEffect,
      List<Population> population});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get diseaseSymptomProcedure;
  $CodeableConceptCopyWith<$Res> get diseaseStatus;
  $CodeableConceptCopyWith<$Res> get intendedEffect;
  $QuantityCopyWith<$Res> get duration;
}

class _$MedicinalProductIndicationCopyWithImpl<$Res>
    implements $MedicinalProductIndicationCopyWith<$Res> {
  _$MedicinalProductIndicationCopyWithImpl(this._value, this._then);

  final MedicinalProductIndication _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIndication) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object diseaseSymptomProcedure = freezed,
    Object diseaseStatus = freezed,
    Object comorbidity = freezed,
    Object intendedEffect = freezed,
    Object duration = freezed,
    Object otherTherapy = freezed,
    Object undesirableEffect = freezed,
    Object population = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      diseaseSymptomProcedure: diseaseSymptomProcedure == freezed
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure as CodeableConcept,
      diseaseStatus: diseaseStatus == freezed
          ? _value.diseaseStatus
          : diseaseStatus as CodeableConcept,
      comorbidity: comorbidity == freezed
          ? _value.comorbidity
          : comorbidity as List<CodeableConcept>,
      intendedEffect: intendedEffect == freezed
          ? _value.intendedEffect
          : intendedEffect as CodeableConcept,
      duration: duration == freezed ? _value.duration : duration as Quantity,
      otherTherapy: otherTherapy == freezed
          ? _value.otherTherapy
          : otherTherapy as List<MedicinalProductIndicationOtherTherapy>,
      undesirableEffect: undesirableEffect == freezed
          ? _value.undesirableEffect
          : undesirableEffect as List<Reference>,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get diseaseSymptomProcedure {
    if (_value.diseaseSymptomProcedure == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.diseaseSymptomProcedure,
        (value) {
      return _then(_value.copyWith(diseaseSymptomProcedure: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get diseaseStatus {
    if (_value.diseaseStatus == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.diseaseStatus, (value) {
      return _then(_value.copyWith(diseaseStatus: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get intendedEffect {
    if (_value.intendedEffect == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.intendedEffect, (value) {
      return _then(_value.copyWith(intendedEffect: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get duration {
    if (_value.duration == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.duration, (value) {
      return _then(_value.copyWith(duration: value));
    });
  }
}

abstract class _$MedicinalProductIndicationCopyWith<$Res>
    implements $MedicinalProductIndicationCopyWith<$Res> {
  factory _$MedicinalProductIndicationCopyWith(
          _MedicinalProductIndication value,
          $Res Function(_MedicinalProductIndication) then) =
      __$MedicinalProductIndicationCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept diseaseSymptomProcedure,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      CodeableConcept intendedEffect,
      Quantity duration,
      List<MedicinalProductIndicationOtherTherapy> otherTherapy,
      List<Reference> undesirableEffect,
      List<Population> population});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get diseaseSymptomProcedure;
  @override
  $CodeableConceptCopyWith<$Res> get diseaseStatus;
  @override
  $CodeableConceptCopyWith<$Res> get intendedEffect;
  @override
  $QuantityCopyWith<$Res> get duration;
}

class __$MedicinalProductIndicationCopyWithImpl<$Res>
    extends _$MedicinalProductIndicationCopyWithImpl<$Res>
    implements _$MedicinalProductIndicationCopyWith<$Res> {
  __$MedicinalProductIndicationCopyWithImpl(_MedicinalProductIndication _value,
      $Res Function(_MedicinalProductIndication) _then)
      : super(_value, (v) => _then(v as _MedicinalProductIndication));

  @override
  _MedicinalProductIndication get _value =>
      super._value as _MedicinalProductIndication;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object diseaseSymptomProcedure = freezed,
    Object diseaseStatus = freezed,
    Object comorbidity = freezed,
    Object intendedEffect = freezed,
    Object duration = freezed,
    Object otherTherapy = freezed,
    Object undesirableEffect = freezed,
    Object population = freezed,
  }) {
    return _then(_MedicinalProductIndication(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      diseaseSymptomProcedure: diseaseSymptomProcedure == freezed
          ? _value.diseaseSymptomProcedure
          : diseaseSymptomProcedure as CodeableConcept,
      diseaseStatus: diseaseStatus == freezed
          ? _value.diseaseStatus
          : diseaseStatus as CodeableConcept,
      comorbidity: comorbidity == freezed
          ? _value.comorbidity
          : comorbidity as List<CodeableConcept>,
      intendedEffect: intendedEffect == freezed
          ? _value.intendedEffect
          : intendedEffect as CodeableConcept,
      duration: duration == freezed ? _value.duration : duration as Quantity,
      otherTherapy: otherTherapy == freezed
          ? _value.otherTherapy
          : otherTherapy as List<MedicinalProductIndicationOtherTherapy>,
      undesirableEffect: undesirableEffect == freezed
          ? _value.undesirableEffect
          : undesirableEffect as List<Reference>,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIndication implements _MedicinalProductIndication {
  const _$_MedicinalProductIndication(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.subject,
      this.diseaseSymptomProcedure,
      this.diseaseStatus,
      this.comorbidity,
      this.intendedEffect,
      this.duration,
      this.otherTherapy,
      this.undesirableEffect,
      this.population})
      : assert(resourceType != null);

  factory _$_MedicinalProductIndication.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductIndicationFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Reference> subject;
  @override
  final CodeableConcept diseaseSymptomProcedure;
  @override
  final CodeableConcept diseaseStatus;
  @override
  final List<CodeableConcept> comorbidity;
  @override
  final CodeableConcept intendedEffect;
  @override
  final Quantity duration;
  @override
  final List<MedicinalProductIndicationOtherTherapy> otherTherapy;
  @override
  final List<Reference> undesirableEffect;
  @override
  final List<Population> population;

  @override
  String toString() {
    return 'MedicinalProductIndication(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, subject: $subject, diseaseSymptomProcedure: $diseaseSymptomProcedure, diseaseStatus: $diseaseStatus, comorbidity: $comorbidity, intendedEffect: $intendedEffect, duration: $duration, otherTherapy: $otherTherapy, undesirableEffect: $undesirableEffect, population: $population)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIndication &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure) ||
                const DeepCollectionEquality().equals(
                    other.diseaseSymptomProcedure, diseaseSymptomProcedure)) &&
            (identical(other.diseaseStatus, diseaseStatus) ||
                const DeepCollectionEquality()
                    .equals(other.diseaseStatus, diseaseStatus)) &&
            (identical(other.comorbidity, comorbidity) ||
                const DeepCollectionEquality()
                    .equals(other.comorbidity, comorbidity)) &&
            (identical(other.intendedEffect, intendedEffect) ||
                const DeepCollectionEquality()
                    .equals(other.intendedEffect, intendedEffect)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.otherTherapy, otherTherapy) ||
                const DeepCollectionEquality()
                    .equals(other.otherTherapy, otherTherapy)) &&
            (identical(other.undesirableEffect, undesirableEffect) ||
                const DeepCollectionEquality()
                    .equals(other.undesirableEffect, undesirableEffect)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(diseaseSymptomProcedure) ^
      const DeepCollectionEquality().hash(diseaseStatus) ^
      const DeepCollectionEquality().hash(comorbidity) ^
      const DeepCollectionEquality().hash(intendedEffect) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(otherTherapy) ^
      const DeepCollectionEquality().hash(undesirableEffect) ^
      const DeepCollectionEquality().hash(population);

  @override
  _$MedicinalProductIndicationCopyWith<_MedicinalProductIndication>
      get copyWith => __$MedicinalProductIndicationCopyWithImpl<
          _MedicinalProductIndication>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIndicationToJson(this);
  }
}

abstract class _MedicinalProductIndication
    implements MedicinalProductIndication {
  const factory _MedicinalProductIndication(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept diseaseSymptomProcedure,
      CodeableConcept diseaseStatus,
      List<CodeableConcept> comorbidity,
      CodeableConcept intendedEffect,
      Quantity duration,
      List<MedicinalProductIndicationOtherTherapy> otherTherapy,
      List<Reference> undesirableEffect,
      List<Population> population}) = _$_MedicinalProductIndication;

  factory _MedicinalProductIndication.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductIndication.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductIndication')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Reference> get subject;
  @override
  CodeableConcept get diseaseSymptomProcedure;
  @override
  CodeableConcept get diseaseStatus;
  @override
  List<CodeableConcept> get comorbidity;
  @override
  CodeableConcept get intendedEffect;
  @override
  Quantity get duration;
  @override
  List<MedicinalProductIndicationOtherTherapy> get otherTherapy;
  @override
  List<Reference> get undesirableEffect;
  @override
  List<Population> get population;
  @override
  _$MedicinalProductIndicationCopyWith<_MedicinalProductIndication>
      get copyWith;
}

MedicinalProductIndicationOtherTherapy
    _$MedicinalProductIndicationOtherTherapyFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductIndicationOtherTherapy.fromJson(json);
}

class _$MedicinalProductIndicationOtherTherapyTearOff {
  const _$MedicinalProductIndicationOtherTherapyTearOff();

  _MedicinalProductIndicationOtherTherapy call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required
      @JsonKey(required: true)
          CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference}) {
    return _MedicinalProductIndicationOtherTherapy(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      therapyRelationshipType: therapyRelationshipType,
      medicationCodeableConcept: medicationCodeableConcept,
      medicationReference: medicationReference,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIndicationOtherTherapy =
    _$MedicinalProductIndicationOtherTherapyTearOff();

mixin _$MedicinalProductIndicationOtherTherapy {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get therapyRelationshipType;
  CodeableConcept get medicationCodeableConcept;
  Reference get medicationReference;

  Map<String, dynamic> toJson();
  $MedicinalProductIndicationOtherTherapyCopyWith<
      MedicinalProductIndicationOtherTherapy> get copyWith;
}

abstract class $MedicinalProductIndicationOtherTherapyCopyWith<$Res> {
  factory $MedicinalProductIndicationOtherTherapyCopyWith(
          MedicinalProductIndicationOtherTherapy value,
          $Res Function(MedicinalProductIndicationOtherTherapy) then) =
      _$MedicinalProductIndicationOtherTherapyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference});

  $CodeableConceptCopyWith<$Res> get therapyRelationshipType;
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept;
  $ReferenceCopyWith<$Res> get medicationReference;
}

class _$MedicinalProductIndicationOtherTherapyCopyWithImpl<$Res>
    implements $MedicinalProductIndicationOtherTherapyCopyWith<$Res> {
  _$MedicinalProductIndicationOtherTherapyCopyWithImpl(this._value, this._then);

  final MedicinalProductIndicationOtherTherapy _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIndicationOtherTherapy) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object therapyRelationshipType = freezed,
    Object medicationCodeableConcept = freezed,
    Object medicationReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      therapyRelationshipType: therapyRelationshipType == freezed
          ? _value.therapyRelationshipType
          : therapyRelationshipType as CodeableConcept,
      medicationCodeableConcept: medicationCodeableConcept == freezed
          ? _value.medicationCodeableConcept
          : medicationCodeableConcept as CodeableConcept,
      medicationReference: medicationReference == freezed
          ? _value.medicationReference
          : medicationReference as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get therapyRelationshipType {
    if (_value.therapyRelationshipType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.therapyRelationshipType,
        (value) {
      return _then(_value.copyWith(therapyRelationshipType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept {
    if (_value.medicationCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.medicationCodeableConcept,
        (value) {
      return _then(_value.copyWith(medicationCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get medicationReference {
    if (_value.medicationReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.medicationReference, (value) {
      return _then(_value.copyWith(medicationReference: value));
    });
  }
}

abstract class _$MedicinalProductIndicationOtherTherapyCopyWith<$Res>
    implements $MedicinalProductIndicationOtherTherapyCopyWith<$Res> {
  factory _$MedicinalProductIndicationOtherTherapyCopyWith(
          _MedicinalProductIndicationOtherTherapy value,
          $Res Function(_MedicinalProductIndicationOtherTherapy) then) =
      __$MedicinalProductIndicationOtherTherapyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept therapyRelationshipType,
      CodeableConcept medicationCodeableConcept,
      Reference medicationReference});

  @override
  $CodeableConceptCopyWith<$Res> get therapyRelationshipType;
  @override
  $CodeableConceptCopyWith<$Res> get medicationCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get medicationReference;
}

class __$MedicinalProductIndicationOtherTherapyCopyWithImpl<$Res>
    extends _$MedicinalProductIndicationOtherTherapyCopyWithImpl<$Res>
    implements _$MedicinalProductIndicationOtherTherapyCopyWith<$Res> {
  __$MedicinalProductIndicationOtherTherapyCopyWithImpl(
      _MedicinalProductIndicationOtherTherapy _value,
      $Res Function(_MedicinalProductIndicationOtherTherapy) _then)
      : super(
            _value, (v) => _then(v as _MedicinalProductIndicationOtherTherapy));

  @override
  _MedicinalProductIndicationOtherTherapy get _value =>
      super._value as _MedicinalProductIndicationOtherTherapy;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object therapyRelationshipType = freezed,
    Object medicationCodeableConcept = freezed,
    Object medicationReference = freezed,
  }) {
    return _then(_MedicinalProductIndicationOtherTherapy(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      therapyRelationshipType: therapyRelationshipType == freezed
          ? _value.therapyRelationshipType
          : therapyRelationshipType as CodeableConcept,
      medicationCodeableConcept: medicationCodeableConcept == freezed
          ? _value.medicationCodeableConcept
          : medicationCodeableConcept as CodeableConcept,
      medicationReference: medicationReference == freezed
          ? _value.medicationReference
          : medicationReference as Reference,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIndicationOtherTherapy
    implements _MedicinalProductIndicationOtherTherapy {
  const _$_MedicinalProductIndicationOtherTherapy(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.therapyRelationshipType,
      this.medicationCodeableConcept,
      this.medicationReference})
      : assert(therapyRelationshipType != null);

  factory _$_MedicinalProductIndicationOtherTherapy.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductIndicationOtherTherapyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept therapyRelationshipType;
  @override
  final CodeableConcept medicationCodeableConcept;
  @override
  final Reference medicationReference;

  @override
  String toString() {
    return 'MedicinalProductIndicationOtherTherapy(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, therapyRelationshipType: $therapyRelationshipType, medicationCodeableConcept: $medicationCodeableConcept, medicationReference: $medicationReference)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIndicationOtherTherapy &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(
                    other.therapyRelationshipType, therapyRelationshipType) ||
                const DeepCollectionEquality().equals(
                    other.therapyRelationshipType, therapyRelationshipType)) &&
            (identical(other.medicationCodeableConcept,
                    medicationCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.medicationCodeableConcept,
                    medicationCodeableConcept)) &&
            (identical(other.medicationReference, medicationReference) ||
                const DeepCollectionEquality()
                    .equals(other.medicationReference, medicationReference)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(therapyRelationshipType) ^
      const DeepCollectionEquality().hash(medicationCodeableConcept) ^
      const DeepCollectionEquality().hash(medicationReference);

  @override
  _$MedicinalProductIndicationOtherTherapyCopyWith<
          _MedicinalProductIndicationOtherTherapy>
      get copyWith => __$MedicinalProductIndicationOtherTherapyCopyWithImpl<
          _MedicinalProductIndicationOtherTherapy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIndicationOtherTherapyToJson(this);
  }
}

abstract class _MedicinalProductIndicationOtherTherapy
    implements MedicinalProductIndicationOtherTherapy {
  const factory _MedicinalProductIndicationOtherTherapy(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required
          @JsonKey(required: true)
              CodeableConcept therapyRelationshipType,
          CodeableConcept medicationCodeableConcept,
          Reference medicationReference}) =
      _$_MedicinalProductIndicationOtherTherapy;

  factory _MedicinalProductIndicationOtherTherapy.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductIndicationOtherTherapy.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get therapyRelationshipType;
  @override
  CodeableConcept get medicationCodeableConcept;
  @override
  Reference get medicationReference;
  @override
  _$MedicinalProductIndicationOtherTherapyCopyWith<
      _MedicinalProductIndicationOtherTherapy> get copyWith;
}

MedicinalProductIngredient _$MedicinalProductIngredientFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductIngredient.fromJson(json);
}

class _$MedicinalProductIngredientTearOff {
  const _$MedicinalProductIngredientTearOff();

  _MedicinalProductIngredient call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @required
      @JsonKey(required: true)
          CodeableConcept role,
      Boolean allergenicIndicator,
      List<Reference> manufacturer,
      List<MedicinalProductIngredientSpecifiedSubstance> specifiedSubstance,
      MedicinalProductIngredientSubstance substance}) {
    return _MedicinalProductIngredient(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      role: role,
      allergenicIndicator: allergenicIndicator,
      manufacturer: manufacturer,
      specifiedSubstance: specifiedSubstance,
      substance: substance,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIngredient = _$MedicinalProductIngredientTearOff();

mixin _$MedicinalProductIngredient {
  @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  @JsonKey(required: true)
  CodeableConcept get role;
  Boolean get allergenicIndicator;
  List<Reference> get manufacturer;
  List<MedicinalProductIngredientSpecifiedSubstance> get specifiedSubstance;
  MedicinalProductIngredientSubstance get substance;

  Map<String, dynamic> toJson();
  $MedicinalProductIngredientCopyWith<MedicinalProductIngredient> get copyWith;
}

abstract class $MedicinalProductIngredientCopyWith<$Res> {
  factory $MedicinalProductIngredientCopyWith(MedicinalProductIngredient value,
          $Res Function(MedicinalProductIngredient) then) =
      _$MedicinalProductIngredientCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @JsonKey(required: true)
          CodeableConcept role,
      Boolean allergenicIndicator,
      List<Reference> manufacturer,
      List<MedicinalProductIngredientSpecifiedSubstance> specifiedSubstance,
      MedicinalProductIngredientSubstance substance});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get role;
  $MedicinalProductIngredientSubstanceCopyWith<$Res> get substance;
}

class _$MedicinalProductIngredientCopyWithImpl<$Res>
    implements $MedicinalProductIngredientCopyWith<$Res> {
  _$MedicinalProductIngredientCopyWithImpl(this._value, this._then);

  final MedicinalProductIngredient _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIngredient) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object role = freezed,
    Object allergenicIndicator = freezed,
    Object manufacturer = freezed,
    Object specifiedSubstance = freezed,
    Object substance = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      role: role == freezed ? _value.role : role as CodeableConcept,
      allergenicIndicator: allergenicIndicator == freezed
          ? _value.allergenicIndicator
          : allergenicIndicator as Boolean,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      specifiedSubstance: specifiedSubstance == freezed
          ? _value.specifiedSubstance
          : specifiedSubstance
              as List<MedicinalProductIngredientSpecifiedSubstance>,
      substance: substance == freezed
          ? _value.substance
          : substance as MedicinalProductIngredientSubstance,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get role {
    if (_value.role == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value));
    });
  }

  @override
  $MedicinalProductIngredientSubstanceCopyWith<$Res> get substance {
    if (_value.substance == null) {
      return null;
    }
    return $MedicinalProductIngredientSubstanceCopyWith<$Res>(_value.substance,
        (value) {
      return _then(_value.copyWith(substance: value));
    });
  }
}

abstract class _$MedicinalProductIngredientCopyWith<$Res>
    implements $MedicinalProductIngredientCopyWith<$Res> {
  factory _$MedicinalProductIngredientCopyWith(
          _MedicinalProductIngredient value,
          $Res Function(_MedicinalProductIngredient) then) =
      __$MedicinalProductIngredientCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      @JsonKey(required: true)
          CodeableConcept role,
      Boolean allergenicIndicator,
      List<Reference> manufacturer,
      List<MedicinalProductIngredientSpecifiedSubstance> specifiedSubstance,
      MedicinalProductIngredientSubstance substance});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get role;
  @override
  $MedicinalProductIngredientSubstanceCopyWith<$Res> get substance;
}

class __$MedicinalProductIngredientCopyWithImpl<$Res>
    extends _$MedicinalProductIngredientCopyWithImpl<$Res>
    implements _$MedicinalProductIngredientCopyWith<$Res> {
  __$MedicinalProductIngredientCopyWithImpl(_MedicinalProductIngredient _value,
      $Res Function(_MedicinalProductIngredient) _then)
      : super(_value, (v) => _then(v as _MedicinalProductIngredient));

  @override
  _MedicinalProductIngredient get _value =>
      super._value as _MedicinalProductIngredient;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object role = freezed,
    Object allergenicIndicator = freezed,
    Object manufacturer = freezed,
    Object specifiedSubstance = freezed,
    Object substance = freezed,
  }) {
    return _then(_MedicinalProductIngredient(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      role: role == freezed ? _value.role : role as CodeableConcept,
      allergenicIndicator: allergenicIndicator == freezed
          ? _value.allergenicIndicator
          : allergenicIndicator as Boolean,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      specifiedSubstance: specifiedSubstance == freezed
          ? _value.specifiedSubstance
          : specifiedSubstance
              as List<MedicinalProductIngredientSpecifiedSubstance>,
      substance: substance == freezed
          ? _value.substance
          : substance as MedicinalProductIngredientSubstance,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIngredient implements _MedicinalProductIngredient {
  const _$_MedicinalProductIngredient(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      @required
      @JsonKey(required: true)
          this.role,
      this.allergenicIndicator,
      this.manufacturer,
      this.specifiedSubstance,
      this.substance})
      : assert(resourceType != null),
        assert(role != null);

  factory _$_MedicinalProductIngredient.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductIngredientFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  @JsonKey(required: true)
  final CodeableConcept role;
  @override
  final Boolean allergenicIndicator;
  @override
  final List<Reference> manufacturer;
  @override
  final List<MedicinalProductIngredientSpecifiedSubstance> specifiedSubstance;
  @override
  final MedicinalProductIngredientSubstance substance;

  @override
  String toString() {
    return 'MedicinalProductIngredient(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, role: $role, allergenicIndicator: $allergenicIndicator, manufacturer: $manufacturer, specifiedSubstance: $specifiedSubstance, substance: $substance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIngredient &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.allergenicIndicator, allergenicIndicator) ||
                const DeepCollectionEquality()
                    .equals(other.allergenicIndicator, allergenicIndicator)) &&
            (identical(other.manufacturer, manufacturer) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturer, manufacturer)) &&
            (identical(other.specifiedSubstance, specifiedSubstance) ||
                const DeepCollectionEquality()
                    .equals(other.specifiedSubstance, specifiedSubstance)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(allergenicIndicator) ^
      const DeepCollectionEquality().hash(manufacturer) ^
      const DeepCollectionEquality().hash(specifiedSubstance) ^
      const DeepCollectionEquality().hash(substance);

  @override
  _$MedicinalProductIngredientCopyWith<_MedicinalProductIngredient>
      get copyWith => __$MedicinalProductIngredientCopyWithImpl<
          _MedicinalProductIngredient>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIngredientToJson(this);
  }
}

abstract class _MedicinalProductIngredient
    implements MedicinalProductIngredient {
  const factory _MedicinalProductIngredient(
          {@required
          @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Identifier identifier,
          @required
          @JsonKey(required: true)
              CodeableConcept role,
          Boolean allergenicIndicator,
          List<Reference> manufacturer,
          List<MedicinalProductIngredientSpecifiedSubstance> specifiedSubstance,
          MedicinalProductIngredientSubstance substance}) =
      _$_MedicinalProductIngredient;

  factory _MedicinalProductIngredient.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductIngredient.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductIngredient')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  @JsonKey(required: true)
  CodeableConcept get role;
  @override
  Boolean get allergenicIndicator;
  @override
  List<Reference> get manufacturer;
  @override
  List<MedicinalProductIngredientSpecifiedSubstance> get specifiedSubstance;
  @override
  MedicinalProductIngredientSubstance get substance;
  @override
  _$MedicinalProductIngredientCopyWith<_MedicinalProductIngredient>
      get copyWith;
}

MedicinalProductIngredientSpecifiedSubstance
    _$MedicinalProductIngredientSpecifiedSubstanceFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductIngredientSpecifiedSubstance.fromJson(json);
}

class _$MedicinalProductIngredientSpecifiedSubstanceTearOff {
  const _$MedicinalProductIngredientSpecifiedSubstanceTearOff();

  _MedicinalProductIngredientSpecifiedSubstance call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      @required @JsonKey(required: true) CodeableConcept group,
      CodeableConcept confidentiality,
      List<MedicinalProductIngredientStrength> strength}) {
    return _MedicinalProductIngredientSpecifiedSubstance(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      group: group,
      confidentiality: confidentiality,
      strength: strength,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIngredientSpecifiedSubstance =
    _$MedicinalProductIngredientSpecifiedSubstanceTearOff();

mixin _$MedicinalProductIngredientSpecifiedSubstance {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  @JsonKey(required: true)
  CodeableConcept get group;
  CodeableConcept get confidentiality;
  List<MedicinalProductIngredientStrength> get strength;

  Map<String, dynamic> toJson();
  $MedicinalProductIngredientSpecifiedSubstanceCopyWith<
      MedicinalProductIngredientSpecifiedSubstance> get copyWith;
}

abstract class $MedicinalProductIngredientSpecifiedSubstanceCopyWith<$Res> {
  factory $MedicinalProductIngredientSpecifiedSubstanceCopyWith(
          MedicinalProductIngredientSpecifiedSubstance value,
          $Res Function(MedicinalProductIngredientSpecifiedSubstance) then) =
      _$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      @JsonKey(required: true) CodeableConcept group,
      CodeableConcept confidentiality,
      List<MedicinalProductIngredientStrength> strength});

  $CodeableConceptCopyWith<$Res> get code;
  $CodeableConceptCopyWith<$Res> get group;
  $CodeableConceptCopyWith<$Res> get confidentiality;
}

class _$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<$Res>
    implements $MedicinalProductIngredientSpecifiedSubstanceCopyWith<$Res> {
  _$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl(
      this._value, this._then);

  final MedicinalProductIngredientSpecifiedSubstance _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIngredientSpecifiedSubstance) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object group = freezed,
    Object confidentiality = freezed,
    Object strength = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      group: group == freezed ? _value.group : group as CodeableConcept,
      confidentiality: confidentiality == freezed
          ? _value.confidentiality
          : confidentiality as CodeableConcept,
      strength: strength == freezed
          ? _value.strength
          : strength as List<MedicinalProductIngredientStrength>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get group {
    if (_value.group == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.group, (value) {
      return _then(_value.copyWith(group: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get confidentiality {
    if (_value.confidentiality == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.confidentiality, (value) {
      return _then(_value.copyWith(confidentiality: value));
    });
  }
}

abstract class _$MedicinalProductIngredientSpecifiedSubstanceCopyWith<$Res>
    implements $MedicinalProductIngredientSpecifiedSubstanceCopyWith<$Res> {
  factory _$MedicinalProductIngredientSpecifiedSubstanceCopyWith(
          _MedicinalProductIngredientSpecifiedSubstance value,
          $Res Function(_MedicinalProductIngredientSpecifiedSubstance) then) =
      __$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      @JsonKey(required: true) CodeableConcept group,
      CodeableConcept confidentiality,
      List<MedicinalProductIngredientStrength> strength});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $CodeableConceptCopyWith<$Res> get group;
  @override
  $CodeableConceptCopyWith<$Res> get confidentiality;
}

class __$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<$Res>
    extends _$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<$Res>
    implements _$MedicinalProductIngredientSpecifiedSubstanceCopyWith<$Res> {
  __$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl(
      _MedicinalProductIngredientSpecifiedSubstance _value,
      $Res Function(_MedicinalProductIngredientSpecifiedSubstance) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductIngredientSpecifiedSubstance));

  @override
  _MedicinalProductIngredientSpecifiedSubstance get _value =>
      super._value as _MedicinalProductIngredientSpecifiedSubstance;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object group = freezed,
    Object confidentiality = freezed,
    Object strength = freezed,
  }) {
    return _then(_MedicinalProductIngredientSpecifiedSubstance(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      group: group == freezed ? _value.group : group as CodeableConcept,
      confidentiality: confidentiality == freezed
          ? _value.confidentiality
          : confidentiality as CodeableConcept,
      strength: strength == freezed
          ? _value.strength
          : strength as List<MedicinalProductIngredientStrength>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIngredientSpecifiedSubstance
    implements _MedicinalProductIngredientSpecifiedSubstance {
  const _$_MedicinalProductIngredientSpecifiedSubstance(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      @required @JsonKey(required: true) this.group,
      this.confidentiality,
      this.strength})
      : assert(code != null),
        assert(group != null);

  factory _$_MedicinalProductIngredientSpecifiedSubstance.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductIngredientSpecifiedSubstanceFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  @JsonKey(required: true)
  final CodeableConcept group;
  @override
  final CodeableConcept confidentiality;
  @override
  final List<MedicinalProductIngredientStrength> strength;

  @override
  String toString() {
    return 'MedicinalProductIngredientSpecifiedSubstance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, group: $group, confidentiality: $confidentiality, strength: $strength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIngredientSpecifiedSubstance &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.group, group) ||
                const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.confidentiality, confidentiality) ||
                const DeepCollectionEquality()
                    .equals(other.confidentiality, confidentiality)) &&
            (identical(other.strength, strength) ||
                const DeepCollectionEquality()
                    .equals(other.strength, strength)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(confidentiality) ^
      const DeepCollectionEquality().hash(strength);

  @override
  _$MedicinalProductIngredientSpecifiedSubstanceCopyWith<
          _MedicinalProductIngredientSpecifiedSubstance>
      get copyWith =>
          __$MedicinalProductIngredientSpecifiedSubstanceCopyWithImpl<
              _MedicinalProductIngredientSpecifiedSubstance>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIngredientSpecifiedSubstanceToJson(this);
  }
}

abstract class _MedicinalProductIngredientSpecifiedSubstance
    implements MedicinalProductIngredientSpecifiedSubstance {
  const factory _MedicinalProductIngredientSpecifiedSubstance(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept code,
          @required @JsonKey(required: true) CodeableConcept group,
          CodeableConcept confidentiality,
          List<MedicinalProductIngredientStrength> strength}) =
      _$_MedicinalProductIngredientSpecifiedSubstance;

  factory _MedicinalProductIngredientSpecifiedSubstance.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductIngredientSpecifiedSubstance.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  @JsonKey(required: true)
  CodeableConcept get group;
  @override
  CodeableConcept get confidentiality;
  @override
  List<MedicinalProductIngredientStrength> get strength;
  @override
  _$MedicinalProductIngredientSpecifiedSubstanceCopyWith<
      _MedicinalProductIngredientSpecifiedSubstance> get copyWith;
}

MedicinalProductIngredientStrength _$MedicinalProductIngredientStrengthFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductIngredientStrength.fromJson(json);
}

class _$MedicinalProductIngredientStrengthTearOff {
  const _$MedicinalProductIngredientStrengthTearOff();

  _MedicinalProductIngredientStrength call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) Ratio presentation,
      Ratio presentationLowLimit,
      Ratio concentration,
      Ratio concentrationLowLimit,
      String measurementPoint,
      List<CodeableConcept> country,
      List<MedicinalProductIngredientReferenceStrength> referenceStrength}) {
    return _MedicinalProductIngredientStrength(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      presentation: presentation,
      presentationLowLimit: presentationLowLimit,
      concentration: concentration,
      concentrationLowLimit: concentrationLowLimit,
      measurementPoint: measurementPoint,
      country: country,
      referenceStrength: referenceStrength,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIngredientStrength =
    _$MedicinalProductIngredientStrengthTearOff();

mixin _$MedicinalProductIngredientStrength {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  Ratio get presentation;
  Ratio get presentationLowLimit;
  Ratio get concentration;
  Ratio get concentrationLowLimit;
  String get measurementPoint;
  List<CodeableConcept> get country;
  List<MedicinalProductIngredientReferenceStrength> get referenceStrength;

  Map<String, dynamic> toJson();
  $MedicinalProductIngredientStrengthCopyWith<
      MedicinalProductIngredientStrength> get copyWith;
}

abstract class $MedicinalProductIngredientStrengthCopyWith<$Res> {
  factory $MedicinalProductIngredientStrengthCopyWith(
          MedicinalProductIngredientStrength value,
          $Res Function(MedicinalProductIngredientStrength) then) =
      _$MedicinalProductIngredientStrengthCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) Ratio presentation,
      Ratio presentationLowLimit,
      Ratio concentration,
      Ratio concentrationLowLimit,
      String measurementPoint,
      List<CodeableConcept> country,
      List<MedicinalProductIngredientReferenceStrength> referenceStrength});

  $RatioCopyWith<$Res> get presentation;
  $RatioCopyWith<$Res> get presentationLowLimit;
  $RatioCopyWith<$Res> get concentration;
  $RatioCopyWith<$Res> get concentrationLowLimit;
}

class _$MedicinalProductIngredientStrengthCopyWithImpl<$Res>
    implements $MedicinalProductIngredientStrengthCopyWith<$Res> {
  _$MedicinalProductIngredientStrengthCopyWithImpl(this._value, this._then);

  final MedicinalProductIngredientStrength _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIngredientStrength) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object presentation = freezed,
    Object presentationLowLimit = freezed,
    Object concentration = freezed,
    Object concentrationLowLimit = freezed,
    Object measurementPoint = freezed,
    Object country = freezed,
    Object referenceStrength = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      presentation:
          presentation == freezed ? _value.presentation : presentation as Ratio,
      presentationLowLimit: presentationLowLimit == freezed
          ? _value.presentationLowLimit
          : presentationLowLimit as Ratio,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration as Ratio,
      concentrationLowLimit: concentrationLowLimit == freezed
          ? _value.concentrationLowLimit
          : concentrationLowLimit as Ratio,
      measurementPoint: measurementPoint == freezed
          ? _value.measurementPoint
          : measurementPoint as String,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
      referenceStrength: referenceStrength == freezed
          ? _value.referenceStrength
          : referenceStrength
              as List<MedicinalProductIngredientReferenceStrength>,
    ));
  }

  @override
  $RatioCopyWith<$Res> get presentation {
    if (_value.presentation == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.presentation, (value) {
      return _then(_value.copyWith(presentation: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get presentationLowLimit {
    if (_value.presentationLowLimit == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.presentationLowLimit, (value) {
      return _then(_value.copyWith(presentationLowLimit: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get concentration {
    if (_value.concentration == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.concentration, (value) {
      return _then(_value.copyWith(concentration: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get concentrationLowLimit {
    if (_value.concentrationLowLimit == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.concentrationLowLimit, (value) {
      return _then(_value.copyWith(concentrationLowLimit: value));
    });
  }
}

abstract class _$MedicinalProductIngredientStrengthCopyWith<$Res>
    implements $MedicinalProductIngredientStrengthCopyWith<$Res> {
  factory _$MedicinalProductIngredientStrengthCopyWith(
          _MedicinalProductIngredientStrength value,
          $Res Function(_MedicinalProductIngredientStrength) then) =
      __$MedicinalProductIngredientStrengthCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) Ratio presentation,
      Ratio presentationLowLimit,
      Ratio concentration,
      Ratio concentrationLowLimit,
      String measurementPoint,
      List<CodeableConcept> country,
      List<MedicinalProductIngredientReferenceStrength> referenceStrength});

  @override
  $RatioCopyWith<$Res> get presentation;
  @override
  $RatioCopyWith<$Res> get presentationLowLimit;
  @override
  $RatioCopyWith<$Res> get concentration;
  @override
  $RatioCopyWith<$Res> get concentrationLowLimit;
}

class __$MedicinalProductIngredientStrengthCopyWithImpl<$Res>
    extends _$MedicinalProductIngredientStrengthCopyWithImpl<$Res>
    implements _$MedicinalProductIngredientStrengthCopyWith<$Res> {
  __$MedicinalProductIngredientStrengthCopyWithImpl(
      _MedicinalProductIngredientStrength _value,
      $Res Function(_MedicinalProductIngredientStrength) _then)
      : super(_value, (v) => _then(v as _MedicinalProductIngredientStrength));

  @override
  _MedicinalProductIngredientStrength get _value =>
      super._value as _MedicinalProductIngredientStrength;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object presentation = freezed,
    Object presentationLowLimit = freezed,
    Object concentration = freezed,
    Object concentrationLowLimit = freezed,
    Object measurementPoint = freezed,
    Object country = freezed,
    Object referenceStrength = freezed,
  }) {
    return _then(_MedicinalProductIngredientStrength(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      presentation:
          presentation == freezed ? _value.presentation : presentation as Ratio,
      presentationLowLimit: presentationLowLimit == freezed
          ? _value.presentationLowLimit
          : presentationLowLimit as Ratio,
      concentration: concentration == freezed
          ? _value.concentration
          : concentration as Ratio,
      concentrationLowLimit: concentrationLowLimit == freezed
          ? _value.concentrationLowLimit
          : concentrationLowLimit as Ratio,
      measurementPoint: measurementPoint == freezed
          ? _value.measurementPoint
          : measurementPoint as String,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
      referenceStrength: referenceStrength == freezed
          ? _value.referenceStrength
          : referenceStrength
              as List<MedicinalProductIngredientReferenceStrength>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIngredientStrength
    implements _MedicinalProductIngredientStrength {
  const _$_MedicinalProductIngredientStrength(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.presentation,
      this.presentationLowLimit,
      this.concentration,
      this.concentrationLowLimit,
      this.measurementPoint,
      this.country,
      this.referenceStrength})
      : assert(presentation != null);

  factory _$_MedicinalProductIngredientStrength.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductIngredientStrengthFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final Ratio presentation;
  @override
  final Ratio presentationLowLimit;
  @override
  final Ratio concentration;
  @override
  final Ratio concentrationLowLimit;
  @override
  final String measurementPoint;
  @override
  final List<CodeableConcept> country;
  @override
  final List<MedicinalProductIngredientReferenceStrength> referenceStrength;

  @override
  String toString() {
    return 'MedicinalProductIngredientStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, presentation: $presentation, presentationLowLimit: $presentationLowLimit, concentration: $concentration, concentrationLowLimit: $concentrationLowLimit, measurementPoint: $measurementPoint, country: $country, referenceStrength: $referenceStrength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIngredientStrength &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.presentation, presentation) ||
                const DeepCollectionEquality()
                    .equals(other.presentation, presentation)) &&
            (identical(other.presentationLowLimit, presentationLowLimit) ||
                const DeepCollectionEquality().equals(
                    other.presentationLowLimit, presentationLowLimit)) &&
            (identical(other.concentration, concentration) ||
                const DeepCollectionEquality()
                    .equals(other.concentration, concentration)) &&
            (identical(other.concentrationLowLimit, concentrationLowLimit) ||
                const DeepCollectionEquality().equals(
                    other.concentrationLowLimit, concentrationLowLimit)) &&
            (identical(other.measurementPoint, measurementPoint) ||
                const DeepCollectionEquality()
                    .equals(other.measurementPoint, measurementPoint)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.referenceStrength, referenceStrength) ||
                const DeepCollectionEquality()
                    .equals(other.referenceStrength, referenceStrength)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(presentation) ^
      const DeepCollectionEquality().hash(presentationLowLimit) ^
      const DeepCollectionEquality().hash(concentration) ^
      const DeepCollectionEquality().hash(concentrationLowLimit) ^
      const DeepCollectionEquality().hash(measurementPoint) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(referenceStrength);

  @override
  _$MedicinalProductIngredientStrengthCopyWith<
          _MedicinalProductIngredientStrength>
      get copyWith => __$MedicinalProductIngredientStrengthCopyWithImpl<
          _MedicinalProductIngredientStrength>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIngredientStrengthToJson(this);
  }
}

abstract class _MedicinalProductIngredientStrength
    implements MedicinalProductIngredientStrength {
  const factory _MedicinalProductIngredientStrength(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) Ratio presentation,
      Ratio presentationLowLimit,
      Ratio concentration,
      Ratio concentrationLowLimit,
      String measurementPoint,
      List<CodeableConcept> country,
      List<MedicinalProductIngredientReferenceStrength>
          referenceStrength}) = _$_MedicinalProductIngredientStrength;

  factory _MedicinalProductIngredientStrength.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductIngredientStrength.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  Ratio get presentation;
  @override
  Ratio get presentationLowLimit;
  @override
  Ratio get concentration;
  @override
  Ratio get concentrationLowLimit;
  @override
  String get measurementPoint;
  @override
  List<CodeableConcept> get country;
  @override
  List<MedicinalProductIngredientReferenceStrength> get referenceStrength;
  @override
  _$MedicinalProductIngredientStrengthCopyWith<
      _MedicinalProductIngredientStrength> get copyWith;
}

MedicinalProductIngredientReferenceStrength
    _$MedicinalProductIngredientReferenceStrengthFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductIngredientReferenceStrength.fromJson(json);
}

class _$MedicinalProductIngredientReferenceStrengthTearOff {
  const _$MedicinalProductIngredientReferenceStrengthTearOff();

  _MedicinalProductIngredientReferenceStrength call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept substance,
      @required @JsonKey(required: true) Ratio strength,
      Ratio strengthLowLimit,
      String measurementPoint,
      List<CodeableConcept> country}) {
    return _MedicinalProductIngredientReferenceStrength(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      substance: substance,
      strength: strength,
      strengthLowLimit: strengthLowLimit,
      measurementPoint: measurementPoint,
      country: country,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIngredientReferenceStrength =
    _$MedicinalProductIngredientReferenceStrengthTearOff();

mixin _$MedicinalProductIngredientReferenceStrength {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get substance;
  @JsonKey(required: true)
  Ratio get strength;
  Ratio get strengthLowLimit;
  String get measurementPoint;
  List<CodeableConcept> get country;

  Map<String, dynamic> toJson();
  $MedicinalProductIngredientReferenceStrengthCopyWith<
      MedicinalProductIngredientReferenceStrength> get copyWith;
}

abstract class $MedicinalProductIngredientReferenceStrengthCopyWith<$Res> {
  factory $MedicinalProductIngredientReferenceStrengthCopyWith(
          MedicinalProductIngredientReferenceStrength value,
          $Res Function(MedicinalProductIngredientReferenceStrength) then) =
      _$MedicinalProductIngredientReferenceStrengthCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept substance,
      @JsonKey(required: true) Ratio strength,
      Ratio strengthLowLimit,
      String measurementPoint,
      List<CodeableConcept> country});

  $CodeableConceptCopyWith<$Res> get substance;
  $RatioCopyWith<$Res> get strength;
  $RatioCopyWith<$Res> get strengthLowLimit;
}

class _$MedicinalProductIngredientReferenceStrengthCopyWithImpl<$Res>
    implements $MedicinalProductIngredientReferenceStrengthCopyWith<$Res> {
  _$MedicinalProductIngredientReferenceStrengthCopyWithImpl(
      this._value, this._then);

  final MedicinalProductIngredientReferenceStrength _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIngredientReferenceStrength) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substance = freezed,
    Object strength = freezed,
    Object strengthLowLimit = freezed,
    Object measurementPoint = freezed,
    Object country = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substance: substance == freezed
          ? _value.substance
          : substance as CodeableConcept,
      strength: strength == freezed ? _value.strength : strength as Ratio,
      strengthLowLimit: strengthLowLimit == freezed
          ? _value.strengthLowLimit
          : strengthLowLimit as Ratio,
      measurementPoint: measurementPoint == freezed
          ? _value.measurementPoint
          : measurementPoint as String,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get substance {
    if (_value.substance == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.substance, (value) {
      return _then(_value.copyWith(substance: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get strength {
    if (_value.strength == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.strength, (value) {
      return _then(_value.copyWith(strength: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get strengthLowLimit {
    if (_value.strengthLowLimit == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.strengthLowLimit, (value) {
      return _then(_value.copyWith(strengthLowLimit: value));
    });
  }
}

abstract class _$MedicinalProductIngredientReferenceStrengthCopyWith<$Res>
    implements $MedicinalProductIngredientReferenceStrengthCopyWith<$Res> {
  factory _$MedicinalProductIngredientReferenceStrengthCopyWith(
          _MedicinalProductIngredientReferenceStrength value,
          $Res Function(_MedicinalProductIngredientReferenceStrength) then) =
      __$MedicinalProductIngredientReferenceStrengthCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept substance,
      @JsonKey(required: true) Ratio strength,
      Ratio strengthLowLimit,
      String measurementPoint,
      List<CodeableConcept> country});

  @override
  $CodeableConceptCopyWith<$Res> get substance;
  @override
  $RatioCopyWith<$Res> get strength;
  @override
  $RatioCopyWith<$Res> get strengthLowLimit;
}

class __$MedicinalProductIngredientReferenceStrengthCopyWithImpl<$Res>
    extends _$MedicinalProductIngredientReferenceStrengthCopyWithImpl<$Res>
    implements _$MedicinalProductIngredientReferenceStrengthCopyWith<$Res> {
  __$MedicinalProductIngredientReferenceStrengthCopyWithImpl(
      _MedicinalProductIngredientReferenceStrength _value,
      $Res Function(_MedicinalProductIngredientReferenceStrength) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductIngredientReferenceStrength));

  @override
  _MedicinalProductIngredientReferenceStrength get _value =>
      super._value as _MedicinalProductIngredientReferenceStrength;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substance = freezed,
    Object strength = freezed,
    Object strengthLowLimit = freezed,
    Object measurementPoint = freezed,
    Object country = freezed,
  }) {
    return _then(_MedicinalProductIngredientReferenceStrength(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substance: substance == freezed
          ? _value.substance
          : substance as CodeableConcept,
      strength: strength == freezed ? _value.strength : strength as Ratio,
      strengthLowLimit: strengthLowLimit == freezed
          ? _value.strengthLowLimit
          : strengthLowLimit as Ratio,
      measurementPoint: measurementPoint == freezed
          ? _value.measurementPoint
          : measurementPoint as String,
      country: country == freezed
          ? _value.country
          : country as List<CodeableConcept>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIngredientReferenceStrength
    implements _MedicinalProductIngredientReferenceStrength {
  const _$_MedicinalProductIngredientReferenceStrength(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.substance,
      @required @JsonKey(required: true) this.strength,
      this.strengthLowLimit,
      this.measurementPoint,
      this.country})
      : assert(strength != null);

  factory _$_MedicinalProductIngredientReferenceStrength.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductIngredientReferenceStrengthFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept substance;
  @override
  @JsonKey(required: true)
  final Ratio strength;
  @override
  final Ratio strengthLowLimit;
  @override
  final String measurementPoint;
  @override
  final List<CodeableConcept> country;

  @override
  String toString() {
    return 'MedicinalProductIngredientReferenceStrength(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substance: $substance, strength: $strength, strengthLowLimit: $strengthLowLimit, measurementPoint: $measurementPoint, country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIngredientReferenceStrength &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)) &&
            (identical(other.strength, strength) ||
                const DeepCollectionEquality()
                    .equals(other.strength, strength)) &&
            (identical(other.strengthLowLimit, strengthLowLimit) ||
                const DeepCollectionEquality()
                    .equals(other.strengthLowLimit, strengthLowLimit)) &&
            (identical(other.measurementPoint, measurementPoint) ||
                const DeepCollectionEquality()
                    .equals(other.measurementPoint, measurementPoint)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(substance) ^
      const DeepCollectionEquality().hash(strength) ^
      const DeepCollectionEquality().hash(strengthLowLimit) ^
      const DeepCollectionEquality().hash(measurementPoint) ^
      const DeepCollectionEquality().hash(country);

  @override
  _$MedicinalProductIngredientReferenceStrengthCopyWith<
          _MedicinalProductIngredientReferenceStrength>
      get copyWith =>
          __$MedicinalProductIngredientReferenceStrengthCopyWithImpl<
              _MedicinalProductIngredientReferenceStrength>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIngredientReferenceStrengthToJson(this);
  }
}

abstract class _MedicinalProductIngredientReferenceStrength
    implements MedicinalProductIngredientReferenceStrength {
  const factory _MedicinalProductIngredientReferenceStrength(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept substance,
          @required @JsonKey(required: true) Ratio strength,
          Ratio strengthLowLimit,
          String measurementPoint,
          List<CodeableConcept> country}) =
      _$_MedicinalProductIngredientReferenceStrength;

  factory _MedicinalProductIngredientReferenceStrength.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductIngredientReferenceStrength.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get substance;
  @override
  @JsonKey(required: true)
  Ratio get strength;
  @override
  Ratio get strengthLowLimit;
  @override
  String get measurementPoint;
  @override
  List<CodeableConcept> get country;
  @override
  _$MedicinalProductIngredientReferenceStrengthCopyWith<
      _MedicinalProductIngredientReferenceStrength> get copyWith;
}

MedicinalProductIngredientSubstance
    _$MedicinalProductIngredientSubstanceFromJson(Map<String, dynamic> json) {
  return _MedicinalProductIngredientSubstance.fromJson(json);
}

class _$MedicinalProductIngredientSubstanceTearOff {
  const _$MedicinalProductIngredientSubstanceTearOff();

  _MedicinalProductIngredientSubstance call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductIngredientStrength> strength}) {
    return _MedicinalProductIngredientSubstance(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      strength: strength,
    );
  }
}

// ignore: unused_element
const $MedicinalProductIngredientSubstance =
    _$MedicinalProductIngredientSubstanceTearOff();

mixin _$MedicinalProductIngredientSubstance {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  List<MedicinalProductIngredientStrength> get strength;

  Map<String, dynamic> toJson();
  $MedicinalProductIngredientSubstanceCopyWith<
      MedicinalProductIngredientSubstance> get copyWith;
}

abstract class $MedicinalProductIngredientSubstanceCopyWith<$Res> {
  factory $MedicinalProductIngredientSubstanceCopyWith(
          MedicinalProductIngredientSubstance value,
          $Res Function(MedicinalProductIngredientSubstance) then) =
      _$MedicinalProductIngredientSubstanceCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductIngredientStrength> strength});

  $CodeableConceptCopyWith<$Res> get code;
}

class _$MedicinalProductIngredientSubstanceCopyWithImpl<$Res>
    implements $MedicinalProductIngredientSubstanceCopyWith<$Res> {
  _$MedicinalProductIngredientSubstanceCopyWithImpl(this._value, this._then);

  final MedicinalProductIngredientSubstance _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductIngredientSubstance) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object strength = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      strength: strength == freezed
          ? _value.strength
          : strength as List<MedicinalProductIngredientStrength>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

abstract class _$MedicinalProductIngredientSubstanceCopyWith<$Res>
    implements $MedicinalProductIngredientSubstanceCopyWith<$Res> {
  factory _$MedicinalProductIngredientSubstanceCopyWith(
          _MedicinalProductIngredientSubstance value,
          $Res Function(_MedicinalProductIngredientSubstance) then) =
      __$MedicinalProductIngredientSubstanceCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductIngredientStrength> strength});

  @override
  $CodeableConceptCopyWith<$Res> get code;
}

class __$MedicinalProductIngredientSubstanceCopyWithImpl<$Res>
    extends _$MedicinalProductIngredientSubstanceCopyWithImpl<$Res>
    implements _$MedicinalProductIngredientSubstanceCopyWith<$Res> {
  __$MedicinalProductIngredientSubstanceCopyWithImpl(
      _MedicinalProductIngredientSubstance _value,
      $Res Function(_MedicinalProductIngredientSubstance) _then)
      : super(_value, (v) => _then(v as _MedicinalProductIngredientSubstance));

  @override
  _MedicinalProductIngredientSubstance get _value =>
      super._value as _MedicinalProductIngredientSubstance;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object strength = freezed,
  }) {
    return _then(_MedicinalProductIngredientSubstance(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      strength: strength == freezed
          ? _value.strength
          : strength as List<MedicinalProductIngredientStrength>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductIngredientSubstance
    implements _MedicinalProductIngredientSubstance {
  const _$_MedicinalProductIngredientSubstance(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      this.strength})
      : assert(code != null);

  factory _$_MedicinalProductIngredientSubstance.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductIngredientSubstanceFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  final List<MedicinalProductIngredientStrength> strength;

  @override
  String toString() {
    return 'MedicinalProductIngredientSubstance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, strength: $strength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductIngredientSubstance &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.strength, strength) ||
                const DeepCollectionEquality()
                    .equals(other.strength, strength)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(strength);

  @override
  _$MedicinalProductIngredientSubstanceCopyWith<
          _MedicinalProductIngredientSubstance>
      get copyWith => __$MedicinalProductIngredientSubstanceCopyWithImpl<
          _MedicinalProductIngredientSubstance>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductIngredientSubstanceToJson(this);
  }
}

abstract class _MedicinalProductIngredientSubstance
    implements MedicinalProductIngredientSubstance {
  const factory _MedicinalProductIngredientSubstance(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept code,
          List<MedicinalProductIngredientStrength> strength}) =
      _$_MedicinalProductIngredientSubstance;

  factory _MedicinalProductIngredientSubstance.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductIngredientSubstance.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  List<MedicinalProductIngredientStrength> get strength;
  @override
  _$MedicinalProductIngredientSubstanceCopyWith<
      _MedicinalProductIngredientSubstance> get copyWith;
}

MedicinalProductInteraction _$MedicinalProductInteractionFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductInteraction.fromJson(json);
}

class _$MedicinalProductInteractionTearOff {
  const _$MedicinalProductInteractionTearOff();

  _MedicinalProductInteraction call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      String description,
      List<MedicinalProductInteractionInteractant> interactant,
      CodeableConcept type,
      CodeableConcept effect,
      CodeableConcept incidence,
      CodeableConcept management}) {
    return _MedicinalProductInteraction(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subject: subject,
      description: description,
      interactant: interactant,
      type: type,
      effect: effect,
      incidence: incidence,
      management: management,
    );
  }
}

// ignore: unused_element
const $MedicinalProductInteraction = _$MedicinalProductInteractionTearOff();

mixin _$MedicinalProductInteraction {
  @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Reference> get subject;
  String get description;
  List<MedicinalProductInteractionInteractant> get interactant;
  CodeableConcept get type;
  CodeableConcept get effect;
  CodeableConcept get incidence;
  CodeableConcept get management;

  Map<String, dynamic> toJson();
  $MedicinalProductInteractionCopyWith<MedicinalProductInteraction>
      get copyWith;
}

abstract class $MedicinalProductInteractionCopyWith<$Res> {
  factory $MedicinalProductInteractionCopyWith(
          MedicinalProductInteraction value,
          $Res Function(MedicinalProductInteraction) then) =
      _$MedicinalProductInteractionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      String description,
      List<MedicinalProductInteractionInteractant> interactant,
      CodeableConcept type,
      CodeableConcept effect,
      CodeableConcept incidence,
      CodeableConcept management});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get effect;
  $CodeableConceptCopyWith<$Res> get incidence;
  $CodeableConceptCopyWith<$Res> get management;
}

class _$MedicinalProductInteractionCopyWithImpl<$Res>
    implements $MedicinalProductInteractionCopyWith<$Res> {
  _$MedicinalProductInteractionCopyWithImpl(this._value, this._then);

  final MedicinalProductInteraction _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductInteraction) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object description = freezed,
    Object interactant = freezed,
    Object type = freezed,
    Object effect = freezed,
    Object incidence = freezed,
    Object management = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      description:
          description == freezed ? _value.description : description as String,
      interactant: interactant == freezed
          ? _value.interactant
          : interactant as List<MedicinalProductInteractionInteractant>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      effect: effect == freezed ? _value.effect : effect as CodeableConcept,
      incidence: incidence == freezed
          ? _value.incidence
          : incidence as CodeableConcept,
      management: management == freezed
          ? _value.management
          : management as CodeableConcept,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get effect {
    if (_value.effect == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.effect, (value) {
      return _then(_value.copyWith(effect: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get incidence {
    if (_value.incidence == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.incidence, (value) {
      return _then(_value.copyWith(incidence: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get management {
    if (_value.management == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.management, (value) {
      return _then(_value.copyWith(management: value));
    });
  }
}

abstract class _$MedicinalProductInteractionCopyWith<$Res>
    implements $MedicinalProductInteractionCopyWith<$Res> {
  factory _$MedicinalProductInteractionCopyWith(
          _MedicinalProductInteraction value,
          $Res Function(_MedicinalProductInteraction) then) =
      __$MedicinalProductInteractionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      String description,
      List<MedicinalProductInteractionInteractant> interactant,
      CodeableConcept type,
      CodeableConcept effect,
      CodeableConcept incidence,
      CodeableConcept management});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get effect;
  @override
  $CodeableConceptCopyWith<$Res> get incidence;
  @override
  $CodeableConceptCopyWith<$Res> get management;
}

class __$MedicinalProductInteractionCopyWithImpl<$Res>
    extends _$MedicinalProductInteractionCopyWithImpl<$Res>
    implements _$MedicinalProductInteractionCopyWith<$Res> {
  __$MedicinalProductInteractionCopyWithImpl(
      _MedicinalProductInteraction _value,
      $Res Function(_MedicinalProductInteraction) _then)
      : super(_value, (v) => _then(v as _MedicinalProductInteraction));

  @override
  _MedicinalProductInteraction get _value =>
      super._value as _MedicinalProductInteraction;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object description = freezed,
    Object interactant = freezed,
    Object type = freezed,
    Object effect = freezed,
    Object incidence = freezed,
    Object management = freezed,
  }) {
    return _then(_MedicinalProductInteraction(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      description:
          description == freezed ? _value.description : description as String,
      interactant: interactant == freezed
          ? _value.interactant
          : interactant as List<MedicinalProductInteractionInteractant>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      effect: effect == freezed ? _value.effect : effect as CodeableConcept,
      incidence: incidence == freezed
          ? _value.incidence
          : incidence as CodeableConcept,
      management: management == freezed
          ? _value.management
          : management as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductInteraction implements _MedicinalProductInteraction {
  const _$_MedicinalProductInteraction(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.subject,
      this.description,
      this.interactant,
      this.type,
      this.effect,
      this.incidence,
      this.management})
      : assert(resourceType != null);

  factory _$_MedicinalProductInteraction.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductInteractionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Reference> subject;
  @override
  final String description;
  @override
  final List<MedicinalProductInteractionInteractant> interactant;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept effect;
  @override
  final CodeableConcept incidence;
  @override
  final CodeableConcept management;

  @override
  String toString() {
    return 'MedicinalProductInteraction(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, subject: $subject, description: $description, interactant: $interactant, type: $type, effect: $effect, incidence: $incidence, management: $management)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductInteraction &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.interactant, interactant) ||
                const DeepCollectionEquality()
                    .equals(other.interactant, interactant)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.effect, effect) ||
                const DeepCollectionEquality().equals(other.effect, effect)) &&
            (identical(other.incidence, incidence) ||
                const DeepCollectionEquality()
                    .equals(other.incidence, incidence)) &&
            (identical(other.management, management) ||
                const DeepCollectionEquality()
                    .equals(other.management, management)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(interactant) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(effect) ^
      const DeepCollectionEquality().hash(incidence) ^
      const DeepCollectionEquality().hash(management);

  @override
  _$MedicinalProductInteractionCopyWith<_MedicinalProductInteraction>
      get copyWith => __$MedicinalProductInteractionCopyWithImpl<
          _MedicinalProductInteraction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductInteractionToJson(this);
  }
}

abstract class _MedicinalProductInteraction
    implements MedicinalProductInteraction {
  const factory _MedicinalProductInteraction(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      String description,
      List<MedicinalProductInteractionInteractant> interactant,
      CodeableConcept type,
      CodeableConcept effect,
      CodeableConcept incidence,
      CodeableConcept management}) = _$_MedicinalProductInteraction;

  factory _MedicinalProductInteraction.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductInteraction.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductInteraction')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Reference> get subject;
  @override
  String get description;
  @override
  List<MedicinalProductInteractionInteractant> get interactant;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get effect;
  @override
  CodeableConcept get incidence;
  @override
  CodeableConcept get management;
  @override
  _$MedicinalProductInteractionCopyWith<_MedicinalProductInteraction>
      get copyWith;
}

MedicinalProductInteractionInteractant
    _$MedicinalProductInteractionInteractantFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductInteractionInteractant.fromJson(json);
}

class _$MedicinalProductInteractionInteractantTearOff {
  const _$MedicinalProductInteractionInteractantTearOff();

  _MedicinalProductInteractionInteractant call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference itemReference,
      CodeableConcept itemCodeableConcept}) {
    return _MedicinalProductInteractionInteractant(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      itemReference: itemReference,
      itemCodeableConcept: itemCodeableConcept,
    );
  }
}

// ignore: unused_element
const $MedicinalProductInteractionInteractant =
    _$MedicinalProductInteractionInteractantTearOff();

mixin _$MedicinalProductInteractionInteractant {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Reference get itemReference;
  CodeableConcept get itemCodeableConcept;

  Map<String, dynamic> toJson();
  $MedicinalProductInteractionInteractantCopyWith<
      MedicinalProductInteractionInteractant> get copyWith;
}

abstract class $MedicinalProductInteractionInteractantCopyWith<$Res> {
  factory $MedicinalProductInteractionInteractantCopyWith(
          MedicinalProductInteractionInteractant value,
          $Res Function(MedicinalProductInteractionInteractant) then) =
      _$MedicinalProductInteractionInteractantCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference itemReference,
      CodeableConcept itemCodeableConcept});

  $ReferenceCopyWith<$Res> get itemReference;
  $CodeableConceptCopyWith<$Res> get itemCodeableConcept;
}

class _$MedicinalProductInteractionInteractantCopyWithImpl<$Res>
    implements $MedicinalProductInteractionInteractantCopyWith<$Res> {
  _$MedicinalProductInteractionInteractantCopyWithImpl(this._value, this._then);

  final MedicinalProductInteractionInteractant _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductInteractionInteractant) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object itemReference = freezed,
    Object itemCodeableConcept = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      itemReference: itemReference == freezed
          ? _value.itemReference
          : itemReference as Reference,
      itemCodeableConcept: itemCodeableConcept == freezed
          ? _value.itemCodeableConcept
          : itemCodeableConcept as CodeableConcept,
    ));
  }

  @override
  $ReferenceCopyWith<$Res> get itemReference {
    if (_value.itemReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.itemReference, (value) {
      return _then(_value.copyWith(itemReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get itemCodeableConcept {
    if (_value.itemCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.itemCodeableConcept, (value) {
      return _then(_value.copyWith(itemCodeableConcept: value));
    });
  }
}

abstract class _$MedicinalProductInteractionInteractantCopyWith<$Res>
    implements $MedicinalProductInteractionInteractantCopyWith<$Res> {
  factory _$MedicinalProductInteractionInteractantCopyWith(
          _MedicinalProductInteractionInteractant value,
          $Res Function(_MedicinalProductInteractionInteractant) then) =
      __$MedicinalProductInteractionInteractantCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference itemReference,
      CodeableConcept itemCodeableConcept});

  @override
  $ReferenceCopyWith<$Res> get itemReference;
  @override
  $CodeableConceptCopyWith<$Res> get itemCodeableConcept;
}

class __$MedicinalProductInteractionInteractantCopyWithImpl<$Res>
    extends _$MedicinalProductInteractionInteractantCopyWithImpl<$Res>
    implements _$MedicinalProductInteractionInteractantCopyWith<$Res> {
  __$MedicinalProductInteractionInteractantCopyWithImpl(
      _MedicinalProductInteractionInteractant _value,
      $Res Function(_MedicinalProductInteractionInteractant) _then)
      : super(
            _value, (v) => _then(v as _MedicinalProductInteractionInteractant));

  @override
  _MedicinalProductInteractionInteractant get _value =>
      super._value as _MedicinalProductInteractionInteractant;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object itemReference = freezed,
    Object itemCodeableConcept = freezed,
  }) {
    return _then(_MedicinalProductInteractionInteractant(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      itemReference: itemReference == freezed
          ? _value.itemReference
          : itemReference as Reference,
      itemCodeableConcept: itemCodeableConcept == freezed
          ? _value.itemCodeableConcept
          : itemCodeableConcept as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductInteractionInteractant
    implements _MedicinalProductInteractionInteractant {
  const _$_MedicinalProductInteractionInteractant(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.itemReference,
      this.itemCodeableConcept});

  factory _$_MedicinalProductInteractionInteractant.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductInteractionInteractantFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Reference itemReference;
  @override
  final CodeableConcept itemCodeableConcept;

  @override
  String toString() {
    return 'MedicinalProductInteractionInteractant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, itemReference: $itemReference, itemCodeableConcept: $itemCodeableConcept)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductInteractionInteractant &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.itemReference, itemReference) ||
                const DeepCollectionEquality()
                    .equals(other.itemReference, itemReference)) &&
            (identical(other.itemCodeableConcept, itemCodeableConcept) ||
                const DeepCollectionEquality()
                    .equals(other.itemCodeableConcept, itemCodeableConcept)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(itemReference) ^
      const DeepCollectionEquality().hash(itemCodeableConcept);

  @override
  _$MedicinalProductInteractionInteractantCopyWith<
          _MedicinalProductInteractionInteractant>
      get copyWith => __$MedicinalProductInteractionInteractantCopyWithImpl<
          _MedicinalProductInteractionInteractant>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductInteractionInteractantToJson(this);
  }
}

abstract class _MedicinalProductInteractionInteractant
    implements MedicinalProductInteractionInteractant {
  const factory _MedicinalProductInteractionInteractant(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Reference itemReference,
          CodeableConcept itemCodeableConcept}) =
      _$_MedicinalProductInteractionInteractant;

  factory _MedicinalProductInteractionInteractant.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductInteractionInteractant.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Reference get itemReference;
  @override
  CodeableConcept get itemCodeableConcept;
  @override
  _$MedicinalProductInteractionInteractantCopyWith<
      _MedicinalProductInteractionInteractant> get copyWith;
}

MedicinalProductManufactured _$MedicinalProductManufacturedFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductManufactured.fromJson(json);
}

class _$MedicinalProductManufacturedTearOff {
  const _$MedicinalProductManufacturedTearOff();

  _MedicinalProductManufactured call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required
      @JsonKey(required: true)
          CodeableConcept manufacturedDoseForm,
      CodeableConcept unitOfPresentation,
      @required
      @JsonKey(required: true)
          Quantity quantity,
      List<Reference> manufacturer,
      List<Reference> ingredient,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics}) {
    return _MedicinalProductManufactured(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      manufacturedDoseForm: manufacturedDoseForm,
      unitOfPresentation: unitOfPresentation,
      quantity: quantity,
      manufacturer: manufacturer,
      ingredient: ingredient,
      physicalCharacteristics: physicalCharacteristics,
      otherCharacteristics: otherCharacteristics,
    );
  }
}

// ignore: unused_element
const $MedicinalProductManufactured = _$MedicinalProductManufacturedTearOff();

mixin _$MedicinalProductManufactured {
  @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get manufacturedDoseForm;
  CodeableConcept get unitOfPresentation;
  @JsonKey(required: true)
  Quantity get quantity;
  List<Reference> get manufacturer;
  List<Reference> get ingredient;
  ProdCharacteristic get physicalCharacteristics;
  List<CodeableConcept> get otherCharacteristics;

  Map<String, dynamic> toJson();
  $MedicinalProductManufacturedCopyWith<MedicinalProductManufactured>
      get copyWith;
}

abstract class $MedicinalProductManufacturedCopyWith<$Res> {
  factory $MedicinalProductManufacturedCopyWith(
          MedicinalProductManufactured value,
          $Res Function(MedicinalProductManufactured) then) =
      _$MedicinalProductManufacturedCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true)
          CodeableConcept manufacturedDoseForm,
      CodeableConcept unitOfPresentation,
      @JsonKey(required: true)
          Quantity quantity,
      List<Reference> manufacturer,
      List<Reference> ingredient,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  $CodeableConceptCopyWith<$Res> get unitOfPresentation;
  $QuantityCopyWith<$Res> get quantity;
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
}

class _$MedicinalProductManufacturedCopyWithImpl<$Res>
    implements $MedicinalProductManufacturedCopyWith<$Res> {
  _$MedicinalProductManufacturedCopyWithImpl(this._value, this._then);

  final MedicinalProductManufactured _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductManufactured) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object manufacturedDoseForm = freezed,
    Object unitOfPresentation = freezed,
    Object quantity = freezed,
    Object manufacturer = freezed,
    Object ingredient = freezed,
    Object physicalCharacteristics = freezed,
    Object otherCharacteristics = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      manufacturedDoseForm: manufacturedDoseForm == freezed
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm as CodeableConcept,
      unitOfPresentation: unitOfPresentation == freezed
          ? _value.unitOfPresentation
          : unitOfPresentation as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      ingredient: ingredient == freezed
          ? _value.ingredient
          : ingredient as List<Reference>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      otherCharacteristics: otherCharacteristics == freezed
          ? _value.otherCharacteristics
          : otherCharacteristics as List<CodeableConcept>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm {
    if (_value.manufacturedDoseForm == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.manufacturedDoseForm, (value) {
      return _then(_value.copyWith(manufacturedDoseForm: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation, (value) {
      return _then(_value.copyWith(unitOfPresentation: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get quantity {
    if (_value.quantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.quantity, (value) {
      return _then(_value.copyWith(quantity: value));
    });
  }

  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics {
    if (_value.physicalCharacteristics == null) {
      return null;
    }
    return $ProdCharacteristicCopyWith<$Res>(_value.physicalCharacteristics,
        (value) {
      return _then(_value.copyWith(physicalCharacteristics: value));
    });
  }
}

abstract class _$MedicinalProductManufacturedCopyWith<$Res>
    implements $MedicinalProductManufacturedCopyWith<$Res> {
  factory _$MedicinalProductManufacturedCopyWith(
          _MedicinalProductManufactured value,
          $Res Function(_MedicinalProductManufactured) then) =
      __$MedicinalProductManufacturedCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true)
          CodeableConcept manufacturedDoseForm,
      CodeableConcept unitOfPresentation,
      @JsonKey(required: true)
          Quantity quantity,
      List<Reference> manufacturer,
      List<Reference> ingredient,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get manufacturedDoseForm;
  @override
  $CodeableConceptCopyWith<$Res> get unitOfPresentation;
  @override
  $QuantityCopyWith<$Res> get quantity;
  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
}

class __$MedicinalProductManufacturedCopyWithImpl<$Res>
    extends _$MedicinalProductManufacturedCopyWithImpl<$Res>
    implements _$MedicinalProductManufacturedCopyWith<$Res> {
  __$MedicinalProductManufacturedCopyWithImpl(
      _MedicinalProductManufactured _value,
      $Res Function(_MedicinalProductManufactured) _then)
      : super(_value, (v) => _then(v as _MedicinalProductManufactured));

  @override
  _MedicinalProductManufactured get _value =>
      super._value as _MedicinalProductManufactured;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object manufacturedDoseForm = freezed,
    Object unitOfPresentation = freezed,
    Object quantity = freezed,
    Object manufacturer = freezed,
    Object ingredient = freezed,
    Object physicalCharacteristics = freezed,
    Object otherCharacteristics = freezed,
  }) {
    return _then(_MedicinalProductManufactured(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      manufacturedDoseForm: manufacturedDoseForm == freezed
          ? _value.manufacturedDoseForm
          : manufacturedDoseForm as CodeableConcept,
      unitOfPresentation: unitOfPresentation == freezed
          ? _value.unitOfPresentation
          : unitOfPresentation as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      ingredient: ingredient == freezed
          ? _value.ingredient
          : ingredient as List<Reference>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      otherCharacteristics: otherCharacteristics == freezed
          ? _value.otherCharacteristics
          : otherCharacteristics as List<CodeableConcept>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductManufactured implements _MedicinalProductManufactured {
  const _$_MedicinalProductManufactured(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      @required
      @JsonKey(required: true)
          this.manufacturedDoseForm,
      this.unitOfPresentation,
      @required
      @JsonKey(required: true)
          this.quantity,
      this.manufacturer,
      this.ingredient,
      this.physicalCharacteristics,
      this.otherCharacteristics})
      : assert(resourceType != null),
        assert(manufacturedDoseForm != null),
        assert(quantity != null);

  factory _$_MedicinalProductManufactured.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductManufacturedFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept manufacturedDoseForm;
  @override
  final CodeableConcept unitOfPresentation;
  @override
  @JsonKey(required: true)
  final Quantity quantity;
  @override
  final List<Reference> manufacturer;
  @override
  final List<Reference> ingredient;
  @override
  final ProdCharacteristic physicalCharacteristics;
  @override
  final List<CodeableConcept> otherCharacteristics;

  @override
  String toString() {
    return 'MedicinalProductManufactured(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, manufacturedDoseForm: $manufacturedDoseForm, unitOfPresentation: $unitOfPresentation, quantity: $quantity, manufacturer: $manufacturer, ingredient: $ingredient, physicalCharacteristics: $physicalCharacteristics, otherCharacteristics: $otherCharacteristics)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductManufactured &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.manufacturedDoseForm, manufacturedDoseForm) ||
                const DeepCollectionEquality().equals(
                    other.manufacturedDoseForm, manufacturedDoseForm)) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                const DeepCollectionEquality()
                    .equals(other.unitOfPresentation, unitOfPresentation)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.manufacturer, manufacturer) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturer, manufacturer)) &&
            (identical(other.ingredient, ingredient) ||
                const DeepCollectionEquality()
                    .equals(other.ingredient, ingredient)) &&
            (identical(
                    other.physicalCharacteristics, physicalCharacteristics) ||
                const DeepCollectionEquality().equals(
                    other.physicalCharacteristics, physicalCharacteristics)) &&
            (identical(other.otherCharacteristics, otherCharacteristics) ||
                const DeepCollectionEquality()
                    .equals(other.otherCharacteristics, otherCharacteristics)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(manufacturedDoseForm) ^
      const DeepCollectionEquality().hash(unitOfPresentation) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(manufacturer) ^
      const DeepCollectionEquality().hash(ingredient) ^
      const DeepCollectionEquality().hash(physicalCharacteristics) ^
      const DeepCollectionEquality().hash(otherCharacteristics);

  @override
  _$MedicinalProductManufacturedCopyWith<_MedicinalProductManufactured>
      get copyWith => __$MedicinalProductManufacturedCopyWithImpl<
          _MedicinalProductManufactured>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductManufacturedToJson(this);
  }
}

abstract class _MedicinalProductManufactured
    implements MedicinalProductManufactured {
  const factory _MedicinalProductManufactured(
          {@required
          @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required
          @JsonKey(required: true)
              CodeableConcept manufacturedDoseForm,
          CodeableConcept unitOfPresentation,
          @required
          @JsonKey(required: true)
              Quantity quantity,
          List<Reference> manufacturer,
          List<Reference> ingredient,
          ProdCharacteristic physicalCharacteristics,
          List<CodeableConcept> otherCharacteristics}) =
      _$_MedicinalProductManufactured;

  factory _MedicinalProductManufactured.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductManufactured.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductManufactured')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get manufacturedDoseForm;
  @override
  CodeableConcept get unitOfPresentation;
  @override
  @JsonKey(required: true)
  Quantity get quantity;
  @override
  List<Reference> get manufacturer;
  @override
  List<Reference> get ingredient;
  @override
  ProdCharacteristic get physicalCharacteristics;
  @override
  List<CodeableConcept> get otherCharacteristics;
  @override
  _$MedicinalProductManufacturedCopyWith<_MedicinalProductManufactured>
      get copyWith;
}

MedicinalProductPackaged _$MedicinalProductPackagedFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductPackaged.fromJson(json);
}

class _$MedicinalProductPackagedTearOff {
  const _$MedicinalProductPackagedTearOff();

  _MedicinalProductPackaged call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<Reference> subject,
      String description,
      CodeableConcept legalStatusOfSupply,
      List<MarketingStatus> marketingStatus,
      Reference marketingAuthorization,
      List<Reference> manufacturer,
      List<MedicinalProductPackagedBatchIdentifier> batchIdentifier,
      @required
      @JsonKey(required: true)
          List<MedicinalProductPackagedPackageItem> packageItem}) {
    return _MedicinalProductPackaged(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      subject: subject,
      description: description,
      legalStatusOfSupply: legalStatusOfSupply,
      marketingStatus: marketingStatus,
      marketingAuthorization: marketingAuthorization,
      manufacturer: manufacturer,
      batchIdentifier: batchIdentifier,
      packageItem: packageItem,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPackaged = _$MedicinalProductPackagedTearOff();

mixin _$MedicinalProductPackaged {
  @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  List<Reference> get subject;
  String get description;
  CodeableConcept get legalStatusOfSupply;
  List<MarketingStatus> get marketingStatus;
  Reference get marketingAuthorization;
  List<Reference> get manufacturer;
  List<MedicinalProductPackagedBatchIdentifier> get batchIdentifier;
  @JsonKey(required: true)
  List<MedicinalProductPackagedPackageItem> get packageItem;

  Map<String, dynamic> toJson();
  $MedicinalProductPackagedCopyWith<MedicinalProductPackaged> get copyWith;
}

abstract class $MedicinalProductPackagedCopyWith<$Res> {
  factory $MedicinalProductPackagedCopyWith(MedicinalProductPackaged value,
          $Res Function(MedicinalProductPackaged) then) =
      _$MedicinalProductPackagedCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<Reference> subject,
      String description,
      CodeableConcept legalStatusOfSupply,
      List<MarketingStatus> marketingStatus,
      Reference marketingAuthorization,
      List<Reference> manufacturer,
      List<MedicinalProductPackagedBatchIdentifier> batchIdentifier,
      @JsonKey(required: true)
          List<MedicinalProductPackagedPackageItem> packageItem});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  $ReferenceCopyWith<$Res> get marketingAuthorization;
}

class _$MedicinalProductPackagedCopyWithImpl<$Res>
    implements $MedicinalProductPackagedCopyWith<$Res> {
  _$MedicinalProductPackagedCopyWithImpl(this._value, this._then);

  final MedicinalProductPackaged _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPackaged) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object subject = freezed,
    Object description = freezed,
    Object legalStatusOfSupply = freezed,
    Object marketingStatus = freezed,
    Object marketingAuthorization = freezed,
    Object manufacturer = freezed,
    Object batchIdentifier = freezed,
    Object packageItem = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      description:
          description == freezed ? _value.description : description as String,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      marketingStatus: marketingStatus == freezed
          ? _value.marketingStatus
          : marketingStatus as List<MarketingStatus>,
      marketingAuthorization: marketingAuthorization == freezed
          ? _value.marketingAuthorization
          : marketingAuthorization as Reference,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      batchIdentifier: batchIdentifier == freezed
          ? _value.batchIdentifier
          : batchIdentifier as List<MedicinalProductPackagedBatchIdentifier>,
      packageItem: packageItem == freezed
          ? _value.packageItem
          : packageItem as List<MedicinalProductPackagedPackageItem>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply {
    if (_value.legalStatusOfSupply == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.legalStatusOfSupply, (value) {
      return _then(_value.copyWith(legalStatusOfSupply: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get marketingAuthorization {
    if (_value.marketingAuthorization == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.marketingAuthorization, (value) {
      return _then(_value.copyWith(marketingAuthorization: value));
    });
  }
}

abstract class _$MedicinalProductPackagedCopyWith<$Res>
    implements $MedicinalProductPackagedCopyWith<$Res> {
  factory _$MedicinalProductPackagedCopyWith(_MedicinalProductPackaged value,
          $Res Function(_MedicinalProductPackaged) then) =
      __$MedicinalProductPackagedCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      List<Reference> subject,
      String description,
      CodeableConcept legalStatusOfSupply,
      List<MarketingStatus> marketingStatus,
      Reference marketingAuthorization,
      List<Reference> manufacturer,
      List<MedicinalProductPackagedBatchIdentifier> batchIdentifier,
      @JsonKey(required: true)
          List<MedicinalProductPackagedPackageItem> packageItem});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get legalStatusOfSupply;
  @override
  $ReferenceCopyWith<$Res> get marketingAuthorization;
}

class __$MedicinalProductPackagedCopyWithImpl<$Res>
    extends _$MedicinalProductPackagedCopyWithImpl<$Res>
    implements _$MedicinalProductPackagedCopyWith<$Res> {
  __$MedicinalProductPackagedCopyWithImpl(_MedicinalProductPackaged _value,
      $Res Function(_MedicinalProductPackaged) _then)
      : super(_value, (v) => _then(v as _MedicinalProductPackaged));

  @override
  _MedicinalProductPackaged get _value =>
      super._value as _MedicinalProductPackaged;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object subject = freezed,
    Object description = freezed,
    Object legalStatusOfSupply = freezed,
    Object marketingStatus = freezed,
    Object marketingAuthorization = freezed,
    Object manufacturer = freezed,
    Object batchIdentifier = freezed,
    Object packageItem = freezed,
  }) {
    return _then(_MedicinalProductPackaged(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      description:
          description == freezed ? _value.description : description as String,
      legalStatusOfSupply: legalStatusOfSupply == freezed
          ? _value.legalStatusOfSupply
          : legalStatusOfSupply as CodeableConcept,
      marketingStatus: marketingStatus == freezed
          ? _value.marketingStatus
          : marketingStatus as List<MarketingStatus>,
      marketingAuthorization: marketingAuthorization == freezed
          ? _value.marketingAuthorization
          : marketingAuthorization as Reference,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
      batchIdentifier: batchIdentifier == freezed
          ? _value.batchIdentifier
          : batchIdentifier as List<MedicinalProductPackagedBatchIdentifier>,
      packageItem: packageItem == freezed
          ? _value.packageItem
          : packageItem as List<MedicinalProductPackagedPackageItem>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPackaged implements _MedicinalProductPackaged {
  const _$_MedicinalProductPackaged(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.subject,
      this.description,
      this.legalStatusOfSupply,
      this.marketingStatus,
      this.marketingAuthorization,
      this.manufacturer,
      this.batchIdentifier,
      @required
      @JsonKey(required: true)
          this.packageItem})
      : assert(resourceType != null),
        assert(packageItem != null);

  factory _$_MedicinalProductPackaged.fromJson(Map<String, dynamic> json) =>
      _$_$_MedicinalProductPackagedFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final List<Reference> subject;
  @override
  final String description;
  @override
  final CodeableConcept legalStatusOfSupply;
  @override
  final List<MarketingStatus> marketingStatus;
  @override
  final Reference marketingAuthorization;
  @override
  final List<Reference> manufacturer;
  @override
  final List<MedicinalProductPackagedBatchIdentifier> batchIdentifier;
  @override
  @JsonKey(required: true)
  final List<MedicinalProductPackagedPackageItem> packageItem;

  @override
  String toString() {
    return 'MedicinalProductPackaged(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, subject: $subject, description: $description, legalStatusOfSupply: $legalStatusOfSupply, marketingStatus: $marketingStatus, marketingAuthorization: $marketingAuthorization, manufacturer: $manufacturer, batchIdentifier: $batchIdentifier, packageItem: $packageItem)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPackaged &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.legalStatusOfSupply, legalStatusOfSupply) ||
                const DeepCollectionEquality()
                    .equals(other.legalStatusOfSupply, legalStatusOfSupply)) &&
            (identical(other.marketingStatus, marketingStatus) ||
                const DeepCollectionEquality()
                    .equals(other.marketingStatus, marketingStatus)) &&
            (identical(other.marketingAuthorization, marketingAuthorization) ||
                const DeepCollectionEquality().equals(
                    other.marketingAuthorization, marketingAuthorization)) &&
            (identical(other.manufacturer, manufacturer) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturer, manufacturer)) &&
            (identical(other.batchIdentifier, batchIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.batchIdentifier, batchIdentifier)) &&
            (identical(other.packageItem, packageItem) ||
                const DeepCollectionEquality()
                    .equals(other.packageItem, packageItem)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(legalStatusOfSupply) ^
      const DeepCollectionEquality().hash(marketingStatus) ^
      const DeepCollectionEquality().hash(marketingAuthorization) ^
      const DeepCollectionEquality().hash(manufacturer) ^
      const DeepCollectionEquality().hash(batchIdentifier) ^
      const DeepCollectionEquality().hash(packageItem);

  @override
  _$MedicinalProductPackagedCopyWith<_MedicinalProductPackaged> get copyWith =>
      __$MedicinalProductPackagedCopyWithImpl<_MedicinalProductPackaged>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPackagedToJson(this);
  }
}

abstract class _MedicinalProductPackaged implements MedicinalProductPackaged {
  const factory _MedicinalProductPackaged(
          {@required
          @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          List<Identifier> identifier,
          List<Reference> subject,
          String description,
          CodeableConcept legalStatusOfSupply,
          List<MarketingStatus> marketingStatus,
          Reference marketingAuthorization,
          List<Reference> manufacturer,
          List<MedicinalProductPackagedBatchIdentifier> batchIdentifier,
          @required
          @JsonKey(required: true)
              List<MedicinalProductPackagedPackageItem> packageItem}) =
      _$_MedicinalProductPackaged;

  factory _MedicinalProductPackaged.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductPackaged.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductPackaged')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  List<Reference> get subject;
  @override
  String get description;
  @override
  CodeableConcept get legalStatusOfSupply;
  @override
  List<MarketingStatus> get marketingStatus;
  @override
  Reference get marketingAuthorization;
  @override
  List<Reference> get manufacturer;
  @override
  List<MedicinalProductPackagedBatchIdentifier> get batchIdentifier;
  @override
  @JsonKey(required: true)
  List<MedicinalProductPackagedPackageItem> get packageItem;
  @override
  _$MedicinalProductPackagedCopyWith<_MedicinalProductPackaged> get copyWith;
}

MedicinalProductPackagedBatchIdentifier
    _$MedicinalProductPackagedBatchIdentifierFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductPackagedBatchIdentifier.fromJson(json);
}

class _$MedicinalProductPackagedBatchIdentifierTearOff {
  const _$MedicinalProductPackagedBatchIdentifierTearOff();

  _MedicinalProductPackagedBatchIdentifier call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) Identifier outerPackaging,
      Identifier immediatePackaging}) {
    return _MedicinalProductPackagedBatchIdentifier(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      outerPackaging: outerPackaging,
      immediatePackaging: immediatePackaging,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPackagedBatchIdentifier =
    _$MedicinalProductPackagedBatchIdentifierTearOff();

mixin _$MedicinalProductPackagedBatchIdentifier {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  Identifier get outerPackaging;
  Identifier get immediatePackaging;

  Map<String, dynamic> toJson();
  $MedicinalProductPackagedBatchIdentifierCopyWith<
      MedicinalProductPackagedBatchIdentifier> get copyWith;
}

abstract class $MedicinalProductPackagedBatchIdentifierCopyWith<$Res> {
  factory $MedicinalProductPackagedBatchIdentifierCopyWith(
          MedicinalProductPackagedBatchIdentifier value,
          $Res Function(MedicinalProductPackagedBatchIdentifier) then) =
      _$MedicinalProductPackagedBatchIdentifierCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) Identifier outerPackaging,
      Identifier immediatePackaging});

  $IdentifierCopyWith<$Res> get outerPackaging;
  $IdentifierCopyWith<$Res> get immediatePackaging;
}

class _$MedicinalProductPackagedBatchIdentifierCopyWithImpl<$Res>
    implements $MedicinalProductPackagedBatchIdentifierCopyWith<$Res> {
  _$MedicinalProductPackagedBatchIdentifierCopyWithImpl(
      this._value, this._then);

  final MedicinalProductPackagedBatchIdentifier _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPackagedBatchIdentifier) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object outerPackaging = freezed,
    Object immediatePackaging = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      outerPackaging: outerPackaging == freezed
          ? _value.outerPackaging
          : outerPackaging as Identifier,
      immediatePackaging: immediatePackaging == freezed
          ? _value.immediatePackaging
          : immediatePackaging as Identifier,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get outerPackaging {
    if (_value.outerPackaging == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.outerPackaging, (value) {
      return _then(_value.copyWith(outerPackaging: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get immediatePackaging {
    if (_value.immediatePackaging == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.immediatePackaging, (value) {
      return _then(_value.copyWith(immediatePackaging: value));
    });
  }
}

abstract class _$MedicinalProductPackagedBatchIdentifierCopyWith<$Res>
    implements $MedicinalProductPackagedBatchIdentifierCopyWith<$Res> {
  factory _$MedicinalProductPackagedBatchIdentifierCopyWith(
          _MedicinalProductPackagedBatchIdentifier value,
          $Res Function(_MedicinalProductPackagedBatchIdentifier) then) =
      __$MedicinalProductPackagedBatchIdentifierCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) Identifier outerPackaging,
      Identifier immediatePackaging});

  @override
  $IdentifierCopyWith<$Res> get outerPackaging;
  @override
  $IdentifierCopyWith<$Res> get immediatePackaging;
}

class __$MedicinalProductPackagedBatchIdentifierCopyWithImpl<$Res>
    extends _$MedicinalProductPackagedBatchIdentifierCopyWithImpl<$Res>
    implements _$MedicinalProductPackagedBatchIdentifierCopyWith<$Res> {
  __$MedicinalProductPackagedBatchIdentifierCopyWithImpl(
      _MedicinalProductPackagedBatchIdentifier _value,
      $Res Function(_MedicinalProductPackagedBatchIdentifier) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductPackagedBatchIdentifier));

  @override
  _MedicinalProductPackagedBatchIdentifier get _value =>
      super._value as _MedicinalProductPackagedBatchIdentifier;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object outerPackaging = freezed,
    Object immediatePackaging = freezed,
  }) {
    return _then(_MedicinalProductPackagedBatchIdentifier(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      outerPackaging: outerPackaging == freezed
          ? _value.outerPackaging
          : outerPackaging as Identifier,
      immediatePackaging: immediatePackaging == freezed
          ? _value.immediatePackaging
          : immediatePackaging as Identifier,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPackagedBatchIdentifier
    implements _MedicinalProductPackagedBatchIdentifier {
  const _$_MedicinalProductPackagedBatchIdentifier(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.outerPackaging,
      this.immediatePackaging})
      : assert(outerPackaging != null);

  factory _$_MedicinalProductPackagedBatchIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPackagedBatchIdentifierFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final Identifier outerPackaging;
  @override
  final Identifier immediatePackaging;

  @override
  String toString() {
    return 'MedicinalProductPackagedBatchIdentifier(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, outerPackaging: $outerPackaging, immediatePackaging: $immediatePackaging)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPackagedBatchIdentifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.outerPackaging, outerPackaging) ||
                const DeepCollectionEquality()
                    .equals(other.outerPackaging, outerPackaging)) &&
            (identical(other.immediatePackaging, immediatePackaging) ||
                const DeepCollectionEquality()
                    .equals(other.immediatePackaging, immediatePackaging)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(outerPackaging) ^
      const DeepCollectionEquality().hash(immediatePackaging);

  @override
  _$MedicinalProductPackagedBatchIdentifierCopyWith<
          _MedicinalProductPackagedBatchIdentifier>
      get copyWith => __$MedicinalProductPackagedBatchIdentifierCopyWithImpl<
          _MedicinalProductPackagedBatchIdentifier>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPackagedBatchIdentifierToJson(this);
  }
}

abstract class _MedicinalProductPackagedBatchIdentifier
    implements MedicinalProductPackagedBatchIdentifier {
  const factory _MedicinalProductPackagedBatchIdentifier(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) Identifier outerPackaging,
          Identifier immediatePackaging}) =
      _$_MedicinalProductPackagedBatchIdentifier;

  factory _MedicinalProductPackagedBatchIdentifier.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPackagedBatchIdentifier.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  Identifier get outerPackaging;
  @override
  Identifier get immediatePackaging;
  @override
  _$MedicinalProductPackagedBatchIdentifierCopyWith<
      _MedicinalProductPackagedBatchIdentifier> get copyWith;
}

MedicinalProductPackagedPackageItem
    _$MedicinalProductPackagedPackageItemFromJson(Map<String, dynamic> json) {
  return _MedicinalProductPackagedPackageItem.fromJson(json);
}

class _$MedicinalProductPackagedPackageItemTearOff {
  const _$MedicinalProductPackagedPackageItemTearOff();

  _MedicinalProductPackagedPackageItem call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @required @JsonKey(required: true) CodeableConcept type,
      @required @JsonKey(required: true) Quantity quantity,
      List<CodeableConcept> material,
      List<CodeableConcept> alternateMaterial,
      List<Reference> device,
      List<Reference> manufacturedItem,
      List<MedicinalProductPackagedPackageItem> packageItem,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics,
      List<ProductShelfLife> shelfLifeStorage,
      List<Reference> manufacturer}) {
    return _MedicinalProductPackagedPackageItem(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      type: type,
      quantity: quantity,
      material: material,
      alternateMaterial: alternateMaterial,
      device: device,
      manufacturedItem: manufacturedItem,
      packageItem: packageItem,
      physicalCharacteristics: physicalCharacteristics,
      otherCharacteristics: otherCharacteristics,
      shelfLifeStorage: shelfLifeStorage,
      manufacturer: manufacturer,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPackagedPackageItem =
    _$MedicinalProductPackagedPackageItemTearOff();

mixin _$MedicinalProductPackagedPackageItem {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  @JsonKey(required: true)
  CodeableConcept get type;
  @JsonKey(required: true)
  Quantity get quantity;
  List<CodeableConcept> get material;
  List<CodeableConcept> get alternateMaterial;
  List<Reference> get device;
  List<Reference> get manufacturedItem;
  List<MedicinalProductPackagedPackageItem> get packageItem;
  ProdCharacteristic get physicalCharacteristics;
  List<CodeableConcept> get otherCharacteristics;
  List<ProductShelfLife> get shelfLifeStorage;
  List<Reference> get manufacturer;

  Map<String, dynamic> toJson();
  $MedicinalProductPackagedPackageItemCopyWith<
      MedicinalProductPackagedPackageItem> get copyWith;
}

abstract class $MedicinalProductPackagedPackageItemCopyWith<$Res> {
  factory $MedicinalProductPackagedPackageItemCopyWith(
          MedicinalProductPackagedPackageItem value,
          $Res Function(MedicinalProductPackagedPackageItem) then) =
      _$MedicinalProductPackagedPackageItemCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(required: true) CodeableConcept type,
      @JsonKey(required: true) Quantity quantity,
      List<CodeableConcept> material,
      List<CodeableConcept> alternateMaterial,
      List<Reference> device,
      List<Reference> manufacturedItem,
      List<MedicinalProductPackagedPackageItem> packageItem,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics,
      List<ProductShelfLife> shelfLifeStorage,
      List<Reference> manufacturer});

  $CodeableConceptCopyWith<$Res> get type;
  $QuantityCopyWith<$Res> get quantity;
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
}

class _$MedicinalProductPackagedPackageItemCopyWithImpl<$Res>
    implements $MedicinalProductPackagedPackageItemCopyWith<$Res> {
  _$MedicinalProductPackagedPackageItemCopyWithImpl(this._value, this._then);

  final MedicinalProductPackagedPackageItem _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPackagedPackageItem) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object quantity = freezed,
    Object material = freezed,
    Object alternateMaterial = freezed,
    Object device = freezed,
    Object manufacturedItem = freezed,
    Object packageItem = freezed,
    Object physicalCharacteristics = freezed,
    Object otherCharacteristics = freezed,
    Object shelfLifeStorage = freezed,
    Object manufacturer = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      material: material == freezed
          ? _value.material
          : material as List<CodeableConcept>,
      alternateMaterial: alternateMaterial == freezed
          ? _value.alternateMaterial
          : alternateMaterial as List<CodeableConcept>,
      device: device == freezed ? _value.device : device as List<Reference>,
      manufacturedItem: manufacturedItem == freezed
          ? _value.manufacturedItem
          : manufacturedItem as List<Reference>,
      packageItem: packageItem == freezed
          ? _value.packageItem
          : packageItem as List<MedicinalProductPackagedPackageItem>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      otherCharacteristics: otherCharacteristics == freezed
          ? _value.otherCharacteristics
          : otherCharacteristics as List<CodeableConcept>,
      shelfLifeStorage: shelfLifeStorage == freezed
          ? _value.shelfLifeStorage
          : shelfLifeStorage as List<ProductShelfLife>,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get quantity {
    if (_value.quantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.quantity, (value) {
      return _then(_value.copyWith(quantity: value));
    });
  }

  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics {
    if (_value.physicalCharacteristics == null) {
      return null;
    }
    return $ProdCharacteristicCopyWith<$Res>(_value.physicalCharacteristics,
        (value) {
      return _then(_value.copyWith(physicalCharacteristics: value));
    });
  }
}

abstract class _$MedicinalProductPackagedPackageItemCopyWith<$Res>
    implements $MedicinalProductPackagedPackageItemCopyWith<$Res> {
  factory _$MedicinalProductPackagedPackageItemCopyWith(
          _MedicinalProductPackagedPackageItem value,
          $Res Function(_MedicinalProductPackagedPackageItem) then) =
      __$MedicinalProductPackagedPackageItemCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(required: true) CodeableConcept type,
      @JsonKey(required: true) Quantity quantity,
      List<CodeableConcept> material,
      List<CodeableConcept> alternateMaterial,
      List<Reference> device,
      List<Reference> manufacturedItem,
      List<MedicinalProductPackagedPackageItem> packageItem,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics,
      List<ProductShelfLife> shelfLifeStorage,
      List<Reference> manufacturer});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $QuantityCopyWith<$Res> get quantity;
  @override
  $ProdCharacteristicCopyWith<$Res> get physicalCharacteristics;
}

class __$MedicinalProductPackagedPackageItemCopyWithImpl<$Res>
    extends _$MedicinalProductPackagedPackageItemCopyWithImpl<$Res>
    implements _$MedicinalProductPackagedPackageItemCopyWith<$Res> {
  __$MedicinalProductPackagedPackageItemCopyWithImpl(
      _MedicinalProductPackagedPackageItem _value,
      $Res Function(_MedicinalProductPackagedPackageItem) _then)
      : super(_value, (v) => _then(v as _MedicinalProductPackagedPackageItem));

  @override
  _MedicinalProductPackagedPackageItem get _value =>
      super._value as _MedicinalProductPackagedPackageItem;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object quantity = freezed,
    Object material = freezed,
    Object alternateMaterial = freezed,
    Object device = freezed,
    Object manufacturedItem = freezed,
    Object packageItem = freezed,
    Object physicalCharacteristics = freezed,
    Object otherCharacteristics = freezed,
    Object shelfLifeStorage = freezed,
    Object manufacturer = freezed,
  }) {
    return _then(_MedicinalProductPackagedPackageItem(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      quantity: quantity == freezed ? _value.quantity : quantity as Quantity,
      material: material == freezed
          ? _value.material
          : material as List<CodeableConcept>,
      alternateMaterial: alternateMaterial == freezed
          ? _value.alternateMaterial
          : alternateMaterial as List<CodeableConcept>,
      device: device == freezed ? _value.device : device as List<Reference>,
      manufacturedItem: manufacturedItem == freezed
          ? _value.manufacturedItem
          : manufacturedItem as List<Reference>,
      packageItem: packageItem == freezed
          ? _value.packageItem
          : packageItem as List<MedicinalProductPackagedPackageItem>,
      physicalCharacteristics: physicalCharacteristics == freezed
          ? _value.physicalCharacteristics
          : physicalCharacteristics as ProdCharacteristic,
      otherCharacteristics: otherCharacteristics == freezed
          ? _value.otherCharacteristics
          : otherCharacteristics as List<CodeableConcept>,
      shelfLifeStorage: shelfLifeStorage == freezed
          ? _value.shelfLifeStorage
          : shelfLifeStorage as List<ProductShelfLife>,
      manufacturer: manufacturer == freezed
          ? _value.manufacturer
          : manufacturer as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPackagedPackageItem
    implements _MedicinalProductPackagedPackageItem {
  const _$_MedicinalProductPackagedPackageItem(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      @required @JsonKey(required: true) this.type,
      @required @JsonKey(required: true) this.quantity,
      this.material,
      this.alternateMaterial,
      this.device,
      this.manufacturedItem,
      this.packageItem,
      this.physicalCharacteristics,
      this.otherCharacteristics,
      this.shelfLifeStorage,
      this.manufacturer})
      : assert(type != null),
        assert(quantity != null);

  factory _$_MedicinalProductPackagedPackageItem.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPackagedPackageItemFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  @JsonKey(required: true)
  final CodeableConcept type;
  @override
  @JsonKey(required: true)
  final Quantity quantity;
  @override
  final List<CodeableConcept> material;
  @override
  final List<CodeableConcept> alternateMaterial;
  @override
  final List<Reference> device;
  @override
  final List<Reference> manufacturedItem;
  @override
  final List<MedicinalProductPackagedPackageItem> packageItem;
  @override
  final ProdCharacteristic physicalCharacteristics;
  @override
  final List<CodeableConcept> otherCharacteristics;
  @override
  final List<ProductShelfLife> shelfLifeStorage;
  @override
  final List<Reference> manufacturer;

  @override
  String toString() {
    return 'MedicinalProductPackagedPackageItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, quantity: $quantity, material: $material, alternateMaterial: $alternateMaterial, device: $device, manufacturedItem: $manufacturedItem, packageItem: $packageItem, physicalCharacteristics: $physicalCharacteristics, otherCharacteristics: $otherCharacteristics, shelfLifeStorage: $shelfLifeStorage, manufacturer: $manufacturer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPackagedPackageItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.material, material) ||
                const DeepCollectionEquality()
                    .equals(other.material, material)) &&
            (identical(other.alternateMaterial, alternateMaterial) ||
                const DeepCollectionEquality()
                    .equals(other.alternateMaterial, alternateMaterial)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.manufacturedItem, manufacturedItem) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturedItem, manufacturedItem)) &&
            (identical(other.packageItem, packageItem) ||
                const DeepCollectionEquality()
                    .equals(other.packageItem, packageItem)) &&
            (identical(
                    other.physicalCharacteristics, physicalCharacteristics) ||
                const DeepCollectionEquality().equals(
                    other.physicalCharacteristics, physicalCharacteristics)) &&
            (identical(other.otherCharacteristics, otherCharacteristics) ||
                const DeepCollectionEquality().equals(
                    other.otherCharacteristics, otherCharacteristics)) &&
            (identical(other.shelfLifeStorage, shelfLifeStorage) ||
                const DeepCollectionEquality()
                    .equals(other.shelfLifeStorage, shelfLifeStorage)) &&
            (identical(other.manufacturer, manufacturer) ||
                const DeepCollectionEquality()
                    .equals(other.manufacturer, manufacturer)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(material) ^
      const DeepCollectionEquality().hash(alternateMaterial) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(manufacturedItem) ^
      const DeepCollectionEquality().hash(packageItem) ^
      const DeepCollectionEquality().hash(physicalCharacteristics) ^
      const DeepCollectionEquality().hash(otherCharacteristics) ^
      const DeepCollectionEquality().hash(shelfLifeStorage) ^
      const DeepCollectionEquality().hash(manufacturer);

  @override
  _$MedicinalProductPackagedPackageItemCopyWith<
          _MedicinalProductPackagedPackageItem>
      get copyWith => __$MedicinalProductPackagedPackageItemCopyWithImpl<
          _MedicinalProductPackagedPackageItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPackagedPackageItemToJson(this);
  }
}

abstract class _MedicinalProductPackagedPackageItem
    implements MedicinalProductPackagedPackageItem {
  const factory _MedicinalProductPackagedPackageItem(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @required @JsonKey(required: true) CodeableConcept type,
      @required @JsonKey(required: true) Quantity quantity,
      List<CodeableConcept> material,
      List<CodeableConcept> alternateMaterial,
      List<Reference> device,
      List<Reference> manufacturedItem,
      List<MedicinalProductPackagedPackageItem> packageItem,
      ProdCharacteristic physicalCharacteristics,
      List<CodeableConcept> otherCharacteristics,
      List<ProductShelfLife> shelfLifeStorage,
      List<Reference> manufacturer}) = _$_MedicinalProductPackagedPackageItem;

  factory _MedicinalProductPackagedPackageItem.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPackagedPackageItem.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  @JsonKey(required: true)
  CodeableConcept get type;
  @override
  @JsonKey(required: true)
  Quantity get quantity;
  @override
  List<CodeableConcept> get material;
  @override
  List<CodeableConcept> get alternateMaterial;
  @override
  List<Reference> get device;
  @override
  List<Reference> get manufacturedItem;
  @override
  List<MedicinalProductPackagedPackageItem> get packageItem;
  @override
  ProdCharacteristic get physicalCharacteristics;
  @override
  List<CodeableConcept> get otherCharacteristics;
  @override
  List<ProductShelfLife> get shelfLifeStorage;
  @override
  List<Reference> get manufacturer;
  @override
  _$MedicinalProductPackagedPackageItemCopyWith<
      _MedicinalProductPackagedPackageItem> get copyWith;
}

MedicinalProductPharmaceutical _$MedicinalProductPharmaceuticalFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductPharmaceutical.fromJson(json);
}

class _$MedicinalProductPharmaceuticalTearOff {
  const _$MedicinalProductPharmaceuticalTearOff();

  _MedicinalProductPharmaceutical call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @required
      @JsonKey(required: true)
          CodeableConcept administrableDoseForm,
      CodeableConcept unitOfPresentation,
      List<Reference> ingredient,
      List<Reference> device,
      List<MedicinalProductPharmaceuticalCharacteristics> characteristics,
      @required
      @JsonKey(required: true)
          List<MedicinalProductPharmaceuticalRouteOfAdministration>
              routeOfAdministration}) {
    return _MedicinalProductPharmaceutical(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      administrableDoseForm: administrableDoseForm,
      unitOfPresentation: unitOfPresentation,
      ingredient: ingredient,
      device: device,
      characteristics: characteristics,
      routeOfAdministration: routeOfAdministration,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPharmaceutical =
    _$MedicinalProductPharmaceuticalTearOff();

mixin _$MedicinalProductPharmaceutical {
  @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  @JsonKey(required: true)
  CodeableConcept get administrableDoseForm;
  CodeableConcept get unitOfPresentation;
  List<Reference> get ingredient;
  List<Reference> get device;
  List<MedicinalProductPharmaceuticalCharacteristics> get characteristics;
  @JsonKey(required: true)
  List<MedicinalProductPharmaceuticalRouteOfAdministration>
      get routeOfAdministration;

  Map<String, dynamic> toJson();
  $MedicinalProductPharmaceuticalCopyWith<MedicinalProductPharmaceutical>
      get copyWith;
}

abstract class $MedicinalProductPharmaceuticalCopyWith<$Res> {
  factory $MedicinalProductPharmaceuticalCopyWith(
          MedicinalProductPharmaceutical value,
          $Res Function(MedicinalProductPharmaceutical) then) =
      _$MedicinalProductPharmaceuticalCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(required: true)
          CodeableConcept administrableDoseForm,
      CodeableConcept unitOfPresentation,
      List<Reference> ingredient,
      List<Reference> device,
      List<MedicinalProductPharmaceuticalCharacteristics> characteristics,
      @JsonKey(required: true)
          List<MedicinalProductPharmaceuticalRouteOfAdministration>
              routeOfAdministration});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get administrableDoseForm;
  $CodeableConceptCopyWith<$Res> get unitOfPresentation;
}

class _$MedicinalProductPharmaceuticalCopyWithImpl<$Res>
    implements $MedicinalProductPharmaceuticalCopyWith<$Res> {
  _$MedicinalProductPharmaceuticalCopyWithImpl(this._value, this._then);

  final MedicinalProductPharmaceutical _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPharmaceutical) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object administrableDoseForm = freezed,
    Object unitOfPresentation = freezed,
    Object ingredient = freezed,
    Object device = freezed,
    Object characteristics = freezed,
    Object routeOfAdministration = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      administrableDoseForm: administrableDoseForm == freezed
          ? _value.administrableDoseForm
          : administrableDoseForm as CodeableConcept,
      unitOfPresentation: unitOfPresentation == freezed
          ? _value.unitOfPresentation
          : unitOfPresentation as CodeableConcept,
      ingredient: ingredient == freezed
          ? _value.ingredient
          : ingredient as List<Reference>,
      device: device == freezed ? _value.device : device as List<Reference>,
      characteristics: characteristics == freezed
          ? _value.characteristics
          : characteristics
              as List<MedicinalProductPharmaceuticalCharacteristics>,
      routeOfAdministration: routeOfAdministration == freezed
          ? _value.routeOfAdministration
          : routeOfAdministration
              as List<MedicinalProductPharmaceuticalRouteOfAdministration>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get administrableDoseForm {
    if (_value.administrableDoseForm == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.administrableDoseForm,
        (value) {
      return _then(_value.copyWith(administrableDoseForm: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unitOfPresentation {
    if (_value.unitOfPresentation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unitOfPresentation, (value) {
      return _then(_value.copyWith(unitOfPresentation: value));
    });
  }
}

abstract class _$MedicinalProductPharmaceuticalCopyWith<$Res>
    implements $MedicinalProductPharmaceuticalCopyWith<$Res> {
  factory _$MedicinalProductPharmaceuticalCopyWith(
          _MedicinalProductPharmaceutical value,
          $Res Function(_MedicinalProductPharmaceutical) then) =
      __$MedicinalProductPharmaceuticalCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(required: true)
          CodeableConcept administrableDoseForm,
      CodeableConcept unitOfPresentation,
      List<Reference> ingredient,
      List<Reference> device,
      List<MedicinalProductPharmaceuticalCharacteristics> characteristics,
      @JsonKey(required: true)
          List<MedicinalProductPharmaceuticalRouteOfAdministration>
              routeOfAdministration});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get administrableDoseForm;
  @override
  $CodeableConceptCopyWith<$Res> get unitOfPresentation;
}

class __$MedicinalProductPharmaceuticalCopyWithImpl<$Res>
    extends _$MedicinalProductPharmaceuticalCopyWithImpl<$Res>
    implements _$MedicinalProductPharmaceuticalCopyWith<$Res> {
  __$MedicinalProductPharmaceuticalCopyWithImpl(
      _MedicinalProductPharmaceutical _value,
      $Res Function(_MedicinalProductPharmaceutical) _then)
      : super(_value, (v) => _then(v as _MedicinalProductPharmaceutical));

  @override
  _MedicinalProductPharmaceutical get _value =>
      super._value as _MedicinalProductPharmaceutical;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object administrableDoseForm = freezed,
    Object unitOfPresentation = freezed,
    Object ingredient = freezed,
    Object device = freezed,
    Object characteristics = freezed,
    Object routeOfAdministration = freezed,
  }) {
    return _then(_MedicinalProductPharmaceutical(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      administrableDoseForm: administrableDoseForm == freezed
          ? _value.administrableDoseForm
          : administrableDoseForm as CodeableConcept,
      unitOfPresentation: unitOfPresentation == freezed
          ? _value.unitOfPresentation
          : unitOfPresentation as CodeableConcept,
      ingredient: ingredient == freezed
          ? _value.ingredient
          : ingredient as List<Reference>,
      device: device == freezed ? _value.device : device as List<Reference>,
      characteristics: characteristics == freezed
          ? _value.characteristics
          : characteristics
              as List<MedicinalProductPharmaceuticalCharacteristics>,
      routeOfAdministration: routeOfAdministration == freezed
          ? _value.routeOfAdministration
          : routeOfAdministration
              as List<MedicinalProductPharmaceuticalRouteOfAdministration>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPharmaceutical
    implements _MedicinalProductPharmaceutical {
  const _$_MedicinalProductPharmaceutical(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      @required
      @JsonKey(required: true)
          this.administrableDoseForm,
      this.unitOfPresentation,
      this.ingredient,
      this.device,
      this.characteristics,
      @required
      @JsonKey(required: true)
          this.routeOfAdministration})
      : assert(resourceType != null),
        assert(administrableDoseForm != null),
        assert(routeOfAdministration != null);

  factory _$_MedicinalProductPharmaceutical.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPharmaceuticalFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  @JsonKey(required: true)
  final CodeableConcept administrableDoseForm;
  @override
  final CodeableConcept unitOfPresentation;
  @override
  final List<Reference> ingredient;
  @override
  final List<Reference> device;
  @override
  final List<MedicinalProductPharmaceuticalCharacteristics> characteristics;
  @override
  @JsonKey(required: true)
  final List<MedicinalProductPharmaceuticalRouteOfAdministration>
      routeOfAdministration;

  @override
  String toString() {
    return 'MedicinalProductPharmaceutical(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, administrableDoseForm: $administrableDoseForm, unitOfPresentation: $unitOfPresentation, ingredient: $ingredient, device: $device, characteristics: $characteristics, routeOfAdministration: $routeOfAdministration)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPharmaceutical &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.administrableDoseForm, administrableDoseForm) ||
                const DeepCollectionEquality().equals(
                    other.administrableDoseForm, administrableDoseForm)) &&
            (identical(other.unitOfPresentation, unitOfPresentation) ||
                const DeepCollectionEquality()
                    .equals(other.unitOfPresentation, unitOfPresentation)) &&
            (identical(other.ingredient, ingredient) ||
                const DeepCollectionEquality()
                    .equals(other.ingredient, ingredient)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.characteristics, characteristics) ||
                const DeepCollectionEquality()
                    .equals(other.characteristics, characteristics)) &&
            (identical(other.routeOfAdministration, routeOfAdministration) ||
                const DeepCollectionEquality().equals(
                    other.routeOfAdministration, routeOfAdministration)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(administrableDoseForm) ^
      const DeepCollectionEquality().hash(unitOfPresentation) ^
      const DeepCollectionEquality().hash(ingredient) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(characteristics) ^
      const DeepCollectionEquality().hash(routeOfAdministration);

  @override
  _$MedicinalProductPharmaceuticalCopyWith<_MedicinalProductPharmaceutical>
      get copyWith => __$MedicinalProductPharmaceuticalCopyWithImpl<
          _MedicinalProductPharmaceutical>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPharmaceuticalToJson(this);
  }
}

abstract class _MedicinalProductPharmaceutical
    implements MedicinalProductPharmaceutical {
  const factory _MedicinalProductPharmaceutical(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @required
      @JsonKey(required: true)
          CodeableConcept administrableDoseForm,
      CodeableConcept unitOfPresentation,
      List<Reference> ingredient,
      List<Reference> device,
      List<MedicinalProductPharmaceuticalCharacteristics> characteristics,
      @required
      @JsonKey(required: true)
          List<MedicinalProductPharmaceuticalRouteOfAdministration>
              routeOfAdministration}) = _$_MedicinalProductPharmaceutical;

  factory _MedicinalProductPharmaceutical.fromJson(Map<String, dynamic> json) =
      _$_MedicinalProductPharmaceutical.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductPharmaceutical')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  @JsonKey(required: true)
  CodeableConcept get administrableDoseForm;
  @override
  CodeableConcept get unitOfPresentation;
  @override
  List<Reference> get ingredient;
  @override
  List<Reference> get device;
  @override
  List<MedicinalProductPharmaceuticalCharacteristics> get characteristics;
  @override
  @JsonKey(required: true)
  List<MedicinalProductPharmaceuticalRouteOfAdministration>
      get routeOfAdministration;
  @override
  _$MedicinalProductPharmaceuticalCopyWith<_MedicinalProductPharmaceutical>
      get copyWith;
}

MedicinalProductPharmaceuticalCharacteristics
    _$MedicinalProductPharmaceuticalCharacteristicsFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductPharmaceuticalCharacteristics.fromJson(json);
}

class _$MedicinalProductPharmaceuticalCharacteristicsTearOff {
  const _$MedicinalProductPharmaceuticalCharacteristicsTearOff();

  _MedicinalProductPharmaceuticalCharacteristics call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      CodeableConcept status}) {
    return _MedicinalProductPharmaceuticalCharacteristics(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      status: status,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPharmaceuticalCharacteristics =
    _$MedicinalProductPharmaceuticalCharacteristicsTearOff();

mixin _$MedicinalProductPharmaceuticalCharacteristics {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  CodeableConcept get status;

  Map<String, dynamic> toJson();
  $MedicinalProductPharmaceuticalCharacteristicsCopyWith<
      MedicinalProductPharmaceuticalCharacteristics> get copyWith;
}

abstract class $MedicinalProductPharmaceuticalCharacteristicsCopyWith<$Res> {
  factory $MedicinalProductPharmaceuticalCharacteristicsCopyWith(
          MedicinalProductPharmaceuticalCharacteristics value,
          $Res Function(MedicinalProductPharmaceuticalCharacteristics) then) =
      _$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      CodeableConcept status});

  $CodeableConceptCopyWith<$Res> get code;
  $CodeableConceptCopyWith<$Res> get status;
}

class _$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<$Res>
    implements $MedicinalProductPharmaceuticalCharacteristicsCopyWith<$Res> {
  _$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl(
      this._value, this._then);

  final MedicinalProductPharmaceuticalCharacteristics _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPharmaceuticalCharacteristics) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object status = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

abstract class _$MedicinalProductPharmaceuticalCharacteristicsCopyWith<$Res>
    implements $MedicinalProductPharmaceuticalCharacteristicsCopyWith<$Res> {
  factory _$MedicinalProductPharmaceuticalCharacteristicsCopyWith(
          _MedicinalProductPharmaceuticalCharacteristics value,
          $Res Function(_MedicinalProductPharmaceuticalCharacteristics) then) =
      __$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      CodeableConcept status});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $CodeableConceptCopyWith<$Res> get status;
}

class __$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<$Res>
    extends _$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<$Res>
    implements _$MedicinalProductPharmaceuticalCharacteristicsCopyWith<$Res> {
  __$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl(
      _MedicinalProductPharmaceuticalCharacteristics _value,
      $Res Function(_MedicinalProductPharmaceuticalCharacteristics) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductPharmaceuticalCharacteristics));

  @override
  _MedicinalProductPharmaceuticalCharacteristics get _value =>
      super._value as _MedicinalProductPharmaceuticalCharacteristics;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object status = freezed,
  }) {
    return _then(_MedicinalProductPharmaceuticalCharacteristics(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPharmaceuticalCharacteristics
    implements _MedicinalProductPharmaceuticalCharacteristics {
  const _$_MedicinalProductPharmaceuticalCharacteristics(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      this.status})
      : assert(code != null);

  factory _$_MedicinalProductPharmaceuticalCharacteristics.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPharmaceuticalCharacteristicsFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  final CodeableConcept status;

  @override
  String toString() {
    return 'MedicinalProductPharmaceuticalCharacteristics(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPharmaceuticalCharacteristics &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(status);

  @override
  _$MedicinalProductPharmaceuticalCharacteristicsCopyWith<
          _MedicinalProductPharmaceuticalCharacteristics>
      get copyWith =>
          __$MedicinalProductPharmaceuticalCharacteristicsCopyWithImpl<
              _MedicinalProductPharmaceuticalCharacteristics>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPharmaceuticalCharacteristicsToJson(this);
  }
}

abstract class _MedicinalProductPharmaceuticalCharacteristics
    implements MedicinalProductPharmaceuticalCharacteristics {
  const factory _MedicinalProductPharmaceuticalCharacteristics(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept code,
          CodeableConcept status}) =
      _$_MedicinalProductPharmaceuticalCharacteristics;

  factory _MedicinalProductPharmaceuticalCharacteristics.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPharmaceuticalCharacteristics.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  CodeableConcept get status;
  @override
  _$MedicinalProductPharmaceuticalCharacteristicsCopyWith<
      _MedicinalProductPharmaceuticalCharacteristics> get copyWith;
}

MedicinalProductPharmaceuticalRouteOfAdministration
    _$MedicinalProductPharmaceuticalRouteOfAdministrationFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductPharmaceuticalRouteOfAdministration.fromJson(json);
}

class _$MedicinalProductPharmaceuticalRouteOfAdministrationTearOff {
  const _$MedicinalProductPharmaceuticalRouteOfAdministrationTearOff();

  _MedicinalProductPharmaceuticalRouteOfAdministration call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      Quantity firstDose,
      Quantity maxSingleDose,
      Quantity maxDosePerDay,
      Ratio maxDosePerTreatmentPeriod,
      Duration maxTreatmentPeriod,
      List<MedicinalProductPharmaceuticalTargetSpecies> targetSpecies}) {
    return _MedicinalProductPharmaceuticalRouteOfAdministration(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      firstDose: firstDose,
      maxSingleDose: maxSingleDose,
      maxDosePerDay: maxDosePerDay,
      maxDosePerTreatmentPeriod: maxDosePerTreatmentPeriod,
      maxTreatmentPeriod: maxTreatmentPeriod,
      targetSpecies: targetSpecies,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPharmaceuticalRouteOfAdministration =
    _$MedicinalProductPharmaceuticalRouteOfAdministrationTearOff();

mixin _$MedicinalProductPharmaceuticalRouteOfAdministration {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  Quantity get firstDose;
  Quantity get maxSingleDose;
  Quantity get maxDosePerDay;
  Ratio get maxDosePerTreatmentPeriod;
  Duration get maxTreatmentPeriod;
  List<MedicinalProductPharmaceuticalTargetSpecies> get targetSpecies;

  Map<String, dynamic> toJson();
  $MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<
      MedicinalProductPharmaceuticalRouteOfAdministration> get copyWith;
}

abstract class $MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<
    $Res> {
  factory $MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith(
          MedicinalProductPharmaceuticalRouteOfAdministration value,
          $Res Function(MedicinalProductPharmaceuticalRouteOfAdministration)
              then) =
      _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      Quantity firstDose,
      Quantity maxSingleDose,
      Quantity maxDosePerDay,
      Ratio maxDosePerTreatmentPeriod,
      Duration maxTreatmentPeriod,
      List<MedicinalProductPharmaceuticalTargetSpecies> targetSpecies});

  $CodeableConceptCopyWith<$Res> get code;
  $QuantityCopyWith<$Res> get firstDose;
  $QuantityCopyWith<$Res> get maxSingleDose;
  $QuantityCopyWith<$Res> get maxDosePerDay;
  $RatioCopyWith<$Res> get maxDosePerTreatmentPeriod;
  $DurationCopyWith<$Res> get maxTreatmentPeriod;
}

class _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<$Res>
    implements
        $MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<$Res> {
  _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl(
      this._value, this._then);

  final MedicinalProductPharmaceuticalRouteOfAdministration _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPharmaceuticalRouteOfAdministration)
      _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object firstDose = freezed,
    Object maxSingleDose = freezed,
    Object maxDosePerDay = freezed,
    Object maxDosePerTreatmentPeriod = freezed,
    Object maxTreatmentPeriod = freezed,
    Object targetSpecies = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      firstDose:
          firstDose == freezed ? _value.firstDose : firstDose as Quantity,
      maxSingleDose: maxSingleDose == freezed
          ? _value.maxSingleDose
          : maxSingleDose as Quantity,
      maxDosePerDay: maxDosePerDay == freezed
          ? _value.maxDosePerDay
          : maxDosePerDay as Quantity,
      maxDosePerTreatmentPeriod: maxDosePerTreatmentPeriod == freezed
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod as Ratio,
      maxTreatmentPeriod: maxTreatmentPeriod == freezed
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod as Duration,
      targetSpecies: targetSpecies == freezed
          ? _value.targetSpecies
          : targetSpecies as List<MedicinalProductPharmaceuticalTargetSpecies>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get firstDose {
    if (_value.firstDose == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.firstDose, (value) {
      return _then(_value.copyWith(firstDose: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get maxSingleDose {
    if (_value.maxSingleDose == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.maxSingleDose, (value) {
      return _then(_value.copyWith(maxSingleDose: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get maxDosePerDay {
    if (_value.maxDosePerDay == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.maxDosePerDay, (value) {
      return _then(_value.copyWith(maxDosePerDay: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get maxDosePerTreatmentPeriod {
    if (_value.maxDosePerTreatmentPeriod == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.maxDosePerTreatmentPeriod, (value) {
      return _then(_value.copyWith(maxDosePerTreatmentPeriod: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get maxTreatmentPeriod {
    if (_value.maxTreatmentPeriod == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.maxTreatmentPeriod, (value) {
      return _then(_value.copyWith(maxTreatmentPeriod: value));
    });
  }
}

abstract class _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<
        $Res>
    implements
        $MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<$Res> {
  factory _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith(
          _MedicinalProductPharmaceuticalRouteOfAdministration value,
          $Res Function(_MedicinalProductPharmaceuticalRouteOfAdministration)
              then) =
      __$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      Quantity firstDose,
      Quantity maxSingleDose,
      Quantity maxDosePerDay,
      Ratio maxDosePerTreatmentPeriod,
      Duration maxTreatmentPeriod,
      List<MedicinalProductPharmaceuticalTargetSpecies> targetSpecies});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $QuantityCopyWith<$Res> get firstDose;
  @override
  $QuantityCopyWith<$Res> get maxSingleDose;
  @override
  $QuantityCopyWith<$Res> get maxDosePerDay;
  @override
  $RatioCopyWith<$Res> get maxDosePerTreatmentPeriod;
  @override
  $DurationCopyWith<$Res> get maxTreatmentPeriod;
}

class __$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<$Res>
    extends _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<
        $Res>
    implements
        _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<$Res> {
  __$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl(
      _MedicinalProductPharmaceuticalRouteOfAdministration _value,
      $Res Function(_MedicinalProductPharmaceuticalRouteOfAdministration) _then)
      : super(
            _value,
            (v) => _then(
                v as _MedicinalProductPharmaceuticalRouteOfAdministration));

  @override
  _MedicinalProductPharmaceuticalRouteOfAdministration get _value =>
      super._value as _MedicinalProductPharmaceuticalRouteOfAdministration;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object firstDose = freezed,
    Object maxSingleDose = freezed,
    Object maxDosePerDay = freezed,
    Object maxDosePerTreatmentPeriod = freezed,
    Object maxTreatmentPeriod = freezed,
    Object targetSpecies = freezed,
  }) {
    return _then(_MedicinalProductPharmaceuticalRouteOfAdministration(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      firstDose:
          firstDose == freezed ? _value.firstDose : firstDose as Quantity,
      maxSingleDose: maxSingleDose == freezed
          ? _value.maxSingleDose
          : maxSingleDose as Quantity,
      maxDosePerDay: maxDosePerDay == freezed
          ? _value.maxDosePerDay
          : maxDosePerDay as Quantity,
      maxDosePerTreatmentPeriod: maxDosePerTreatmentPeriod == freezed
          ? _value.maxDosePerTreatmentPeriod
          : maxDosePerTreatmentPeriod as Ratio,
      maxTreatmentPeriod: maxTreatmentPeriod == freezed
          ? _value.maxTreatmentPeriod
          : maxTreatmentPeriod as Duration,
      targetSpecies: targetSpecies == freezed
          ? _value.targetSpecies
          : targetSpecies as List<MedicinalProductPharmaceuticalTargetSpecies>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPharmaceuticalRouteOfAdministration
    implements _MedicinalProductPharmaceuticalRouteOfAdministration {
  const _$_MedicinalProductPharmaceuticalRouteOfAdministration(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      this.firstDose,
      this.maxSingleDose,
      this.maxDosePerDay,
      this.maxDosePerTreatmentPeriod,
      this.maxTreatmentPeriod,
      this.targetSpecies})
      : assert(code != null);

  factory _$_MedicinalProductPharmaceuticalRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPharmaceuticalRouteOfAdministrationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  final Quantity firstDose;
  @override
  final Quantity maxSingleDose;
  @override
  final Quantity maxDosePerDay;
  @override
  final Ratio maxDosePerTreatmentPeriod;
  @override
  final Duration maxTreatmentPeriod;
  @override
  final List<MedicinalProductPharmaceuticalTargetSpecies> targetSpecies;

  @override
  String toString() {
    return 'MedicinalProductPharmaceuticalRouteOfAdministration(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, firstDose: $firstDose, maxSingleDose: $maxSingleDose, maxDosePerDay: $maxDosePerDay, maxDosePerTreatmentPeriod: $maxDosePerTreatmentPeriod, maxTreatmentPeriod: $maxTreatmentPeriod, targetSpecies: $targetSpecies)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPharmaceuticalRouteOfAdministration &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.firstDose, firstDose) ||
                const DeepCollectionEquality()
                    .equals(other.firstDose, firstDose)) &&
            (identical(other.maxSingleDose, maxSingleDose) ||
                const DeepCollectionEquality()
                    .equals(other.maxSingleDose, maxSingleDose)) &&
            (identical(other.maxDosePerDay, maxDosePerDay) ||
                const DeepCollectionEquality()
                    .equals(other.maxDosePerDay, maxDosePerDay)) &&
            (identical(other.maxDosePerTreatmentPeriod,
                    maxDosePerTreatmentPeriod) ||
                const DeepCollectionEquality().equals(
                    other.maxDosePerTreatmentPeriod,
                    maxDosePerTreatmentPeriod)) &&
            (identical(other.maxTreatmentPeriod, maxTreatmentPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.maxTreatmentPeriod, maxTreatmentPeriod)) &&
            (identical(other.targetSpecies, targetSpecies) ||
                const DeepCollectionEquality()
                    .equals(other.targetSpecies, targetSpecies)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(firstDose) ^
      const DeepCollectionEquality().hash(maxSingleDose) ^
      const DeepCollectionEquality().hash(maxDosePerDay) ^
      const DeepCollectionEquality().hash(maxDosePerTreatmentPeriod) ^
      const DeepCollectionEquality().hash(maxTreatmentPeriod) ^
      const DeepCollectionEquality().hash(targetSpecies);

  @override
  _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<
          _MedicinalProductPharmaceuticalRouteOfAdministration>
      get copyWith =>
          __$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWithImpl<
                  _MedicinalProductPharmaceuticalRouteOfAdministration>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPharmaceuticalRouteOfAdministrationToJson(this);
  }
}

abstract class _MedicinalProductPharmaceuticalRouteOfAdministration
    implements MedicinalProductPharmaceuticalRouteOfAdministration {
  const factory _MedicinalProductPharmaceuticalRouteOfAdministration(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept code,
          Quantity firstDose,
          Quantity maxSingleDose,
          Quantity maxDosePerDay,
          Ratio maxDosePerTreatmentPeriod,
          Duration maxTreatmentPeriod,
          List<MedicinalProductPharmaceuticalTargetSpecies> targetSpecies}) =
      _$_MedicinalProductPharmaceuticalRouteOfAdministration;

  factory _MedicinalProductPharmaceuticalRouteOfAdministration.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPharmaceuticalRouteOfAdministration.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  Quantity get firstDose;
  @override
  Quantity get maxSingleDose;
  @override
  Quantity get maxDosePerDay;
  @override
  Ratio get maxDosePerTreatmentPeriod;
  @override
  Duration get maxTreatmentPeriod;
  @override
  List<MedicinalProductPharmaceuticalTargetSpecies> get targetSpecies;
  @override
  _$MedicinalProductPharmaceuticalRouteOfAdministrationCopyWith<
      _MedicinalProductPharmaceuticalRouteOfAdministration> get copyWith;
}

MedicinalProductPharmaceuticalTargetSpecies
    _$MedicinalProductPharmaceuticalTargetSpeciesFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductPharmaceuticalTargetSpecies.fromJson(json);
}

class _$MedicinalProductPharmaceuticalTargetSpeciesTearOff {
  const _$MedicinalProductPharmaceuticalTargetSpeciesTearOff();

  _MedicinalProductPharmaceuticalTargetSpecies call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductPharmaceuticalWithdrawalPeriod> withdrawalPeriod}) {
    return _MedicinalProductPharmaceuticalTargetSpecies(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      withdrawalPeriod: withdrawalPeriod,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPharmaceuticalTargetSpecies =
    _$MedicinalProductPharmaceuticalTargetSpeciesTearOff();

mixin _$MedicinalProductPharmaceuticalTargetSpecies {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get code;
  List<MedicinalProductPharmaceuticalWithdrawalPeriod> get withdrawalPeriod;

  Map<String, dynamic> toJson();
  $MedicinalProductPharmaceuticalTargetSpeciesCopyWith<
      MedicinalProductPharmaceuticalTargetSpecies> get copyWith;
}

abstract class $MedicinalProductPharmaceuticalTargetSpeciesCopyWith<$Res> {
  factory $MedicinalProductPharmaceuticalTargetSpeciesCopyWith(
          MedicinalProductPharmaceuticalTargetSpecies value,
          $Res Function(MedicinalProductPharmaceuticalTargetSpecies) then) =
      _$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductPharmaceuticalWithdrawalPeriod> withdrawalPeriod});

  $CodeableConceptCopyWith<$Res> get code;
}

class _$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<$Res>
    implements $MedicinalProductPharmaceuticalTargetSpeciesCopyWith<$Res> {
  _$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl(
      this._value, this._then);

  final MedicinalProductPharmaceuticalTargetSpecies _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPharmaceuticalTargetSpecies) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object withdrawalPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      withdrawalPeriod: withdrawalPeriod == freezed
          ? _value.withdrawalPeriod
          : withdrawalPeriod
              as List<MedicinalProductPharmaceuticalWithdrawalPeriod>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

abstract class _$MedicinalProductPharmaceuticalTargetSpeciesCopyWith<$Res>
    implements $MedicinalProductPharmaceuticalTargetSpeciesCopyWith<$Res> {
  factory _$MedicinalProductPharmaceuticalTargetSpeciesCopyWith(
          _MedicinalProductPharmaceuticalTargetSpecies value,
          $Res Function(_MedicinalProductPharmaceuticalTargetSpecies) then) =
      __$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductPharmaceuticalWithdrawalPeriod> withdrawalPeriod});

  @override
  $CodeableConceptCopyWith<$Res> get code;
}

class __$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<$Res>
    extends _$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<$Res>
    implements _$MedicinalProductPharmaceuticalTargetSpeciesCopyWith<$Res> {
  __$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl(
      _MedicinalProductPharmaceuticalTargetSpecies _value,
      $Res Function(_MedicinalProductPharmaceuticalTargetSpecies) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductPharmaceuticalTargetSpecies));

  @override
  _MedicinalProductPharmaceuticalTargetSpecies get _value =>
      super._value as _MedicinalProductPharmaceuticalTargetSpecies;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object withdrawalPeriod = freezed,
  }) {
    return _then(_MedicinalProductPharmaceuticalTargetSpecies(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      withdrawalPeriod: withdrawalPeriod == freezed
          ? _value.withdrawalPeriod
          : withdrawalPeriod
              as List<MedicinalProductPharmaceuticalWithdrawalPeriod>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPharmaceuticalTargetSpecies
    implements _MedicinalProductPharmaceuticalTargetSpecies {
  const _$_MedicinalProductPharmaceuticalTargetSpecies(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.code,
      this.withdrawalPeriod})
      : assert(code != null);

  factory _$_MedicinalProductPharmaceuticalTargetSpecies.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPharmaceuticalTargetSpeciesFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  final List<MedicinalProductPharmaceuticalWithdrawalPeriod> withdrawalPeriod;

  @override
  String toString() {
    return 'MedicinalProductPharmaceuticalTargetSpecies(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, withdrawalPeriod: $withdrawalPeriod)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPharmaceuticalTargetSpecies &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.withdrawalPeriod, withdrawalPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.withdrawalPeriod, withdrawalPeriod)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(withdrawalPeriod);

  @override
  _$MedicinalProductPharmaceuticalTargetSpeciesCopyWith<
          _MedicinalProductPharmaceuticalTargetSpecies>
      get copyWith =>
          __$MedicinalProductPharmaceuticalTargetSpeciesCopyWithImpl<
              _MedicinalProductPharmaceuticalTargetSpecies>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPharmaceuticalTargetSpeciesToJson(this);
  }
}

abstract class _MedicinalProductPharmaceuticalTargetSpecies
    implements MedicinalProductPharmaceuticalTargetSpecies {
  const factory _MedicinalProductPharmaceuticalTargetSpecies(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept code,
      List<MedicinalProductPharmaceuticalWithdrawalPeriod>
          withdrawalPeriod}) = _$_MedicinalProductPharmaceuticalTargetSpecies;

  factory _MedicinalProductPharmaceuticalTargetSpecies.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPharmaceuticalTargetSpecies.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  List<MedicinalProductPharmaceuticalWithdrawalPeriod> get withdrawalPeriod;
  @override
  _$MedicinalProductPharmaceuticalTargetSpeciesCopyWith<
      _MedicinalProductPharmaceuticalTargetSpecies> get copyWith;
}

MedicinalProductPharmaceuticalWithdrawalPeriod
    _$MedicinalProductPharmaceuticalWithdrawalPeriodFromJson(
        Map<String, dynamic> json) {
  return _MedicinalProductPharmaceuticalWithdrawalPeriod.fromJson(json);
}

class _$MedicinalProductPharmaceuticalWithdrawalPeriodTearOff {
  const _$MedicinalProductPharmaceuticalWithdrawalPeriodTearOff();

  _MedicinalProductPharmaceuticalWithdrawalPeriod call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) CodeableConcept tissue,
      @required @JsonKey(required: true) Quantity value,
      String supportingInformation}) {
    return _MedicinalProductPharmaceuticalWithdrawalPeriod(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      tissue: tissue,
      value: value,
      supportingInformation: supportingInformation,
    );
  }
}

// ignore: unused_element
const $MedicinalProductPharmaceuticalWithdrawalPeriod =
    _$MedicinalProductPharmaceuticalWithdrawalPeriodTearOff();

mixin _$MedicinalProductPharmaceuticalWithdrawalPeriod {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  CodeableConcept get tissue;
  @JsonKey(required: true)
  Quantity get value;
  String get supportingInformation;

  Map<String, dynamic> toJson();
  $MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<
      MedicinalProductPharmaceuticalWithdrawalPeriod> get copyWith;
}

abstract class $MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<$Res> {
  factory $MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith(
          MedicinalProductPharmaceuticalWithdrawalPeriod value,
          $Res Function(MedicinalProductPharmaceuticalWithdrawalPeriod) then) =
      _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept tissue,
      @JsonKey(required: true) Quantity value,
      String supportingInformation});

  $CodeableConceptCopyWith<$Res> get tissue;
  $QuantityCopyWith<$Res> get value;
}

class _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<$Res>
    implements $MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<$Res> {
  _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl(
      this._value, this._then);

  final MedicinalProductPharmaceuticalWithdrawalPeriod _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductPharmaceuticalWithdrawalPeriod) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object tissue = freezed,
    Object value = freezed,
    Object supportingInformation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      tissue: tissue == freezed ? _value.tissue : tissue as CodeableConcept,
      value: value == freezed ? _value.value : value as Quantity,
      supportingInformation: supportingInformation == freezed
          ? _value.supportingInformation
          : supportingInformation as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get tissue {
    if (_value.tissue == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.tissue, (value) {
      return _then(_value.copyWith(tissue: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get value {
    if (_value.value == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

abstract class _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<$Res>
    implements $MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<$Res> {
  factory _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith(
          _MedicinalProductPharmaceuticalWithdrawalPeriod value,
          $Res Function(_MedicinalProductPharmaceuticalWithdrawalPeriod) then) =
      __$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) CodeableConcept tissue,
      @JsonKey(required: true) Quantity value,
      String supportingInformation});

  @override
  $CodeableConceptCopyWith<$Res> get tissue;
  @override
  $QuantityCopyWith<$Res> get value;
}

class __$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<$Res>
    extends _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<$Res>
    implements _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<$Res> {
  __$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl(
      _MedicinalProductPharmaceuticalWithdrawalPeriod _value,
      $Res Function(_MedicinalProductPharmaceuticalWithdrawalPeriod) _then)
      : super(_value,
            (v) => _then(v as _MedicinalProductPharmaceuticalWithdrawalPeriod));

  @override
  _MedicinalProductPharmaceuticalWithdrawalPeriod get _value =>
      super._value as _MedicinalProductPharmaceuticalWithdrawalPeriod;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object tissue = freezed,
    Object value = freezed,
    Object supportingInformation = freezed,
  }) {
    return _then(_MedicinalProductPharmaceuticalWithdrawalPeriod(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      tissue: tissue == freezed ? _value.tissue : tissue as CodeableConcept,
      value: value == freezed ? _value.value : value as Quantity,
      supportingInformation: supportingInformation == freezed
          ? _value.supportingInformation
          : supportingInformation as String,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductPharmaceuticalWithdrawalPeriod
    implements _MedicinalProductPharmaceuticalWithdrawalPeriod {
  const _$_MedicinalProductPharmaceuticalWithdrawalPeriod(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.tissue,
      @required @JsonKey(required: true) this.value,
      this.supportingInformation})
      : assert(tissue != null),
        assert(value != null);

  factory _$_MedicinalProductPharmaceuticalWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductPharmaceuticalWithdrawalPeriodFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final CodeableConcept tissue;
  @override
  @JsonKey(required: true)
  final Quantity value;
  @override
  final String supportingInformation;

  @override
  String toString() {
    return 'MedicinalProductPharmaceuticalWithdrawalPeriod(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, tissue: $tissue, value: $value, supportingInformation: $supportingInformation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductPharmaceuticalWithdrawalPeriod &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.tissue, tissue) ||
                const DeepCollectionEquality().equals(other.tissue, tissue)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.supportingInformation, supportingInformation) ||
                const DeepCollectionEquality().equals(
                    other.supportingInformation, supportingInformation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(tissue) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(supportingInformation);

  @override
  _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<
          _MedicinalProductPharmaceuticalWithdrawalPeriod>
      get copyWith =>
          __$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWithImpl<
                  _MedicinalProductPharmaceuticalWithdrawalPeriod>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductPharmaceuticalWithdrawalPeriodToJson(this);
  }
}

abstract class _MedicinalProductPharmaceuticalWithdrawalPeriod
    implements MedicinalProductPharmaceuticalWithdrawalPeriod {
  const factory _MedicinalProductPharmaceuticalWithdrawalPeriod(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) CodeableConcept tissue,
          @required @JsonKey(required: true) Quantity value,
          String supportingInformation}) =
      _$_MedicinalProductPharmaceuticalWithdrawalPeriod;

  factory _MedicinalProductPharmaceuticalWithdrawalPeriod.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductPharmaceuticalWithdrawalPeriod.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  CodeableConcept get tissue;
  @override
  @JsonKey(required: true)
  Quantity get value;
  @override
  String get supportingInformation;
  @override
  _$MedicinalProductPharmaceuticalWithdrawalPeriodCopyWith<
      _MedicinalProductPharmaceuticalWithdrawalPeriod> get copyWith;
}

MedicinalProductUndesirableEffect _$MedicinalProductUndesirableEffectFromJson(
    Map<String, dynamic> json) {
  return _MedicinalProductUndesirableEffect.fromJson(json);
}

class _$MedicinalProductUndesirableEffectTearOff {
  const _$MedicinalProductUndesirableEffectTearOff();

  _MedicinalProductUndesirableEffect call(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept symptomConditionEffect,
      CodeableConcept classification,
      CodeableConcept frequencyOfOccurrence,
      List<Population> population}) {
    return _MedicinalProductUndesirableEffect(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subject: subject,
      symptomConditionEffect: symptomConditionEffect,
      classification: classification,
      frequencyOfOccurrence: frequencyOfOccurrence,
      population: population,
    );
  }
}

// ignore: unused_element
const $MedicinalProductUndesirableEffect =
    _$MedicinalProductUndesirableEffectTearOff();

mixin _$MedicinalProductUndesirableEffect {
  @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Reference> get subject;
  CodeableConcept get symptomConditionEffect;
  CodeableConcept get classification;
  CodeableConcept get frequencyOfOccurrence;
  List<Population> get population;

  Map<String, dynamic> toJson();
  $MedicinalProductUndesirableEffectCopyWith<MedicinalProductUndesirableEffect>
      get copyWith;
}

abstract class $MedicinalProductUndesirableEffectCopyWith<$Res> {
  factory $MedicinalProductUndesirableEffectCopyWith(
          MedicinalProductUndesirableEffect value,
          $Res Function(MedicinalProductUndesirableEffect) then) =
      _$MedicinalProductUndesirableEffectCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept symptomConditionEffect,
      CodeableConcept classification,
      CodeableConcept frequencyOfOccurrence,
      List<Population> population});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get symptomConditionEffect;
  $CodeableConceptCopyWith<$Res> get classification;
  $CodeableConceptCopyWith<$Res> get frequencyOfOccurrence;
}

class _$MedicinalProductUndesirableEffectCopyWithImpl<$Res>
    implements $MedicinalProductUndesirableEffectCopyWith<$Res> {
  _$MedicinalProductUndesirableEffectCopyWithImpl(this._value, this._then);

  final MedicinalProductUndesirableEffect _value;
  // ignore: unused_field
  final $Res Function(MedicinalProductUndesirableEffect) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object symptomConditionEffect = freezed,
    Object classification = freezed,
    Object frequencyOfOccurrence = freezed,
    Object population = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      symptomConditionEffect: symptomConditionEffect == freezed
          ? _value.symptomConditionEffect
          : symptomConditionEffect as CodeableConcept,
      classification: classification == freezed
          ? _value.classification
          : classification as CodeableConcept,
      frequencyOfOccurrence: frequencyOfOccurrence == freezed
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence as CodeableConcept,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get symptomConditionEffect {
    if (_value.symptomConditionEffect == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.symptomConditionEffect,
        (value) {
      return _then(_value.copyWith(symptomConditionEffect: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get classification {
    if (_value.classification == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.classification, (value) {
      return _then(_value.copyWith(classification: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get frequencyOfOccurrence {
    if (_value.frequencyOfOccurrence == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.frequencyOfOccurrence,
        (value) {
      return _then(_value.copyWith(frequencyOfOccurrence: value));
    });
  }
}

abstract class _$MedicinalProductUndesirableEffectCopyWith<$Res>
    implements $MedicinalProductUndesirableEffectCopyWith<$Res> {
  factory _$MedicinalProductUndesirableEffectCopyWith(
          _MedicinalProductUndesirableEffect value,
          $Res Function(_MedicinalProductUndesirableEffect) then) =
      __$MedicinalProductUndesirableEffectCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept symptomConditionEffect,
      CodeableConcept classification,
      CodeableConcept frequencyOfOccurrence,
      List<Population> population});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get symptomConditionEffect;
  @override
  $CodeableConceptCopyWith<$Res> get classification;
  @override
  $CodeableConceptCopyWith<$Res> get frequencyOfOccurrence;
}

class __$MedicinalProductUndesirableEffectCopyWithImpl<$Res>
    extends _$MedicinalProductUndesirableEffectCopyWithImpl<$Res>
    implements _$MedicinalProductUndesirableEffectCopyWith<$Res> {
  __$MedicinalProductUndesirableEffectCopyWithImpl(
      _MedicinalProductUndesirableEffect _value,
      $Res Function(_MedicinalProductUndesirableEffect) _then)
      : super(_value, (v) => _then(v as _MedicinalProductUndesirableEffect));

  @override
  _MedicinalProductUndesirableEffect get _value =>
      super._value as _MedicinalProductUndesirableEffect;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subject = freezed,
    Object symptomConditionEffect = freezed,
    Object classification = freezed,
    Object frequencyOfOccurrence = freezed,
    Object population = freezed,
  }) {
    return _then(_MedicinalProductUndesirableEffect(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subject: subject == freezed ? _value.subject : subject as List<Reference>,
      symptomConditionEffect: symptomConditionEffect == freezed
          ? _value.symptomConditionEffect
          : symptomConditionEffect as CodeableConcept,
      classification: classification == freezed
          ? _value.classification
          : classification as CodeableConcept,
      frequencyOfOccurrence: frequencyOfOccurrence == freezed
          ? _value.frequencyOfOccurrence
          : frequencyOfOccurrence as CodeableConcept,
      population: population == freezed
          ? _value.population
          : population as List<Population>,
    ));
  }
}

@JsonSerializable()
class _$_MedicinalProductUndesirableEffect
    implements _MedicinalProductUndesirableEffect {
  const _$_MedicinalProductUndesirableEffect(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.subject,
      this.symptomConditionEffect,
      this.classification,
      this.frequencyOfOccurrence,
      this.population})
      : assert(resourceType != null);

  factory _$_MedicinalProductUndesirableEffect.fromJson(
          Map<String, dynamic> json) =>
      _$_$_MedicinalProductUndesirableEffectFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Reference> subject;
  @override
  final CodeableConcept symptomConditionEffect;
  @override
  final CodeableConcept classification;
  @override
  final CodeableConcept frequencyOfOccurrence;
  @override
  final List<Population> population;

  @override
  String toString() {
    return 'MedicinalProductUndesirableEffect(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, subject: $subject, symptomConditionEffect: $symptomConditionEffect, classification: $classification, frequencyOfOccurrence: $frequencyOfOccurrence, population: $population)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MedicinalProductUndesirableEffect &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.symptomConditionEffect, symptomConditionEffect) ||
                const DeepCollectionEquality().equals(
                    other.symptomConditionEffect, symptomConditionEffect)) &&
            (identical(other.classification, classification) ||
                const DeepCollectionEquality()
                    .equals(other.classification, classification)) &&
            (identical(other.frequencyOfOccurrence, frequencyOfOccurrence) ||
                const DeepCollectionEquality().equals(
                    other.frequencyOfOccurrence, frequencyOfOccurrence)) &&
            (identical(other.population, population) ||
                const DeepCollectionEquality()
                    .equals(other.population, population)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(symptomConditionEffect) ^
      const DeepCollectionEquality().hash(classification) ^
      const DeepCollectionEquality().hash(frequencyOfOccurrence) ^
      const DeepCollectionEquality().hash(population);

  @override
  _$MedicinalProductUndesirableEffectCopyWith<
          _MedicinalProductUndesirableEffect>
      get copyWith => __$MedicinalProductUndesirableEffectCopyWithImpl<
          _MedicinalProductUndesirableEffect>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_MedicinalProductUndesirableEffectToJson(this);
  }
}

abstract class _MedicinalProductUndesirableEffect
    implements MedicinalProductUndesirableEffect {
  const factory _MedicinalProductUndesirableEffect(
      {@required
      @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Reference> subject,
      CodeableConcept symptomConditionEffect,
      CodeableConcept classification,
      CodeableConcept frequencyOfOccurrence,
      List<Population> population}) = _$_MedicinalProductUndesirableEffect;

  factory _MedicinalProductUndesirableEffect.fromJson(
          Map<String, dynamic> json) =
      _$_MedicinalProductUndesirableEffect.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'MedicinalProductUndesirableEffect')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Reference> get subject;
  @override
  CodeableConcept get symptomConditionEffect;
  @override
  CodeableConcept get classification;
  @override
  CodeableConcept get frequencyOfOccurrence;
  @override
  List<Population> get population;
  @override
  _$MedicinalProductUndesirableEffectCopyWith<
      _MedicinalProductUndesirableEffect> get copyWith;
}

ObservationDefinition _$ObservationDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ObservationDefinition.fromJson(json);
}

class _$ObservationDefinitionTearOff {
  const _$ObservationDefinitionTearOff();

  _ObservationDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'ObservationDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> category,
      @required
      @JsonKey(required: true)
          CodeableConcept code,
      List<Identifier> identifier,
      List<ObservationDefinitionPermittedDataType> permittedDataType,
      Boolean multipleResultsAllowed,
      CodeableConcept method,
      String preferredReportName,
      ObservationDefinitionQuantitativeDetails quantitativeDetails,
      List<ObservationDefinitionQualifiedInterval> qualifiedInterval,
      Reference validCodedValueSet,
      Reference normalCodedValueSet,
      Reference abnormalCodedValueSet,
      Reference criticalCodedValueSet}) {
    return _ObservationDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      category: category,
      code: code,
      identifier: identifier,
      permittedDataType: permittedDataType,
      multipleResultsAllowed: multipleResultsAllowed,
      method: method,
      preferredReportName: preferredReportName,
      quantitativeDetails: quantitativeDetails,
      qualifiedInterval: qualifiedInterval,
      validCodedValueSet: validCodedValueSet,
      normalCodedValueSet: normalCodedValueSet,
      abnormalCodedValueSet: abnormalCodedValueSet,
      criticalCodedValueSet: criticalCodedValueSet,
    );
  }
}

// ignore: unused_element
const $ObservationDefinition = _$ObservationDefinitionTearOff();

mixin _$ObservationDefinition {
  @JsonKey(required: true, defaultValue: 'ObservationDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<CodeableConcept> get category;
  @JsonKey(required: true)
  CodeableConcept get code;
  List<Identifier> get identifier;
  List<ObservationDefinitionPermittedDataType> get permittedDataType;
  Boolean get multipleResultsAllowed;
  CodeableConcept get method;
  String get preferredReportName;
  ObservationDefinitionQuantitativeDetails get quantitativeDetails;
  List<ObservationDefinitionQualifiedInterval> get qualifiedInterval;
  Reference get validCodedValueSet;
  Reference get normalCodedValueSet;
  Reference get abnormalCodedValueSet;
  Reference get criticalCodedValueSet;

  Map<String, dynamic> toJson();
  $ObservationDefinitionCopyWith<ObservationDefinition> get copyWith;
}

abstract class $ObservationDefinitionCopyWith<$Res> {
  factory $ObservationDefinitionCopyWith(ObservationDefinition value,
          $Res Function(ObservationDefinition) then) =
      _$ObservationDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ObservationDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> category,
      @JsonKey(required: true)
          CodeableConcept code,
      List<Identifier> identifier,
      List<ObservationDefinitionPermittedDataType> permittedDataType,
      Boolean multipleResultsAllowed,
      CodeableConcept method,
      String preferredReportName,
      ObservationDefinitionQuantitativeDetails quantitativeDetails,
      List<ObservationDefinitionQualifiedInterval> qualifiedInterval,
      Reference validCodedValueSet,
      Reference normalCodedValueSet,
      Reference abnormalCodedValueSet,
      Reference criticalCodedValueSet});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get code;
  $CodeableConceptCopyWith<$Res> get method;
  $ObservationDefinitionQuantitativeDetailsCopyWith<$Res>
      get quantitativeDetails;
  $ReferenceCopyWith<$Res> get validCodedValueSet;
  $ReferenceCopyWith<$Res> get normalCodedValueSet;
  $ReferenceCopyWith<$Res> get abnormalCodedValueSet;
  $ReferenceCopyWith<$Res> get criticalCodedValueSet;
}

class _$ObservationDefinitionCopyWithImpl<$Res>
    implements $ObservationDefinitionCopyWith<$Res> {
  _$ObservationDefinitionCopyWithImpl(this._value, this._then);

  final ObservationDefinition _value;
  // ignore: unused_field
  final $Res Function(ObservationDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object permittedDataType = freezed,
    Object multipleResultsAllowed = freezed,
    Object method = freezed,
    Object preferredReportName = freezed,
    Object quantitativeDetails = freezed,
    Object qualifiedInterval = freezed,
    Object validCodedValueSet = freezed,
    Object normalCodedValueSet = freezed,
    Object abnormalCodedValueSet = freezed,
    Object criticalCodedValueSet = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category: category == freezed
          ? _value.category
          : category as List<CodeableConcept>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      permittedDataType: permittedDataType == freezed
          ? _value.permittedDataType
          : permittedDataType as List<ObservationDefinitionPermittedDataType>,
      multipleResultsAllowed: multipleResultsAllowed == freezed
          ? _value.multipleResultsAllowed
          : multipleResultsAllowed as Boolean,
      method: method == freezed ? _value.method : method as CodeableConcept,
      preferredReportName: preferredReportName == freezed
          ? _value.preferredReportName
          : preferredReportName as String,
      quantitativeDetails: quantitativeDetails == freezed
          ? _value.quantitativeDetails
          : quantitativeDetails as ObservationDefinitionQuantitativeDetails,
      qualifiedInterval: qualifiedInterval == freezed
          ? _value.qualifiedInterval
          : qualifiedInterval as List<ObservationDefinitionQualifiedInterval>,
      validCodedValueSet: validCodedValueSet == freezed
          ? _value.validCodedValueSet
          : validCodedValueSet as Reference,
      normalCodedValueSet: normalCodedValueSet == freezed
          ? _value.normalCodedValueSet
          : normalCodedValueSet as Reference,
      abnormalCodedValueSet: abnormalCodedValueSet == freezed
          ? _value.abnormalCodedValueSet
          : abnormalCodedValueSet as Reference,
      criticalCodedValueSet: criticalCodedValueSet == freezed
          ? _value.criticalCodedValueSet
          : criticalCodedValueSet as Reference,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get method {
    if (_value.method == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.method, (value) {
      return _then(_value.copyWith(method: value));
    });
  }

  @override
  $ObservationDefinitionQuantitativeDetailsCopyWith<$Res>
      get quantitativeDetails {
    if (_value.quantitativeDetails == null) {
      return null;
    }
    return $ObservationDefinitionQuantitativeDetailsCopyWith<$Res>(
        _value.quantitativeDetails, (value) {
      return _then(_value.copyWith(quantitativeDetails: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get validCodedValueSet {
    if (_value.validCodedValueSet == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.validCodedValueSet, (value) {
      return _then(_value.copyWith(validCodedValueSet: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get normalCodedValueSet {
    if (_value.normalCodedValueSet == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.normalCodedValueSet, (value) {
      return _then(_value.copyWith(normalCodedValueSet: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get abnormalCodedValueSet {
    if (_value.abnormalCodedValueSet == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.abnormalCodedValueSet, (value) {
      return _then(_value.copyWith(abnormalCodedValueSet: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get criticalCodedValueSet {
    if (_value.criticalCodedValueSet == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.criticalCodedValueSet, (value) {
      return _then(_value.copyWith(criticalCodedValueSet: value));
    });
  }
}

abstract class _$ObservationDefinitionCopyWith<$Res>
    implements $ObservationDefinitionCopyWith<$Res> {
  factory _$ObservationDefinitionCopyWith(_ObservationDefinition value,
          $Res Function(_ObservationDefinition) then) =
      __$ObservationDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ObservationDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> category,
      @JsonKey(required: true)
          CodeableConcept code,
      List<Identifier> identifier,
      List<ObservationDefinitionPermittedDataType> permittedDataType,
      Boolean multipleResultsAllowed,
      CodeableConcept method,
      String preferredReportName,
      ObservationDefinitionQuantitativeDetails quantitativeDetails,
      List<ObservationDefinitionQualifiedInterval> qualifiedInterval,
      Reference validCodedValueSet,
      Reference normalCodedValueSet,
      Reference abnormalCodedValueSet,
      Reference criticalCodedValueSet});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $CodeableConceptCopyWith<$Res> get method;
  @override
  $ObservationDefinitionQuantitativeDetailsCopyWith<$Res>
      get quantitativeDetails;
  @override
  $ReferenceCopyWith<$Res> get validCodedValueSet;
  @override
  $ReferenceCopyWith<$Res> get normalCodedValueSet;
  @override
  $ReferenceCopyWith<$Res> get abnormalCodedValueSet;
  @override
  $ReferenceCopyWith<$Res> get criticalCodedValueSet;
}

class __$ObservationDefinitionCopyWithImpl<$Res>
    extends _$ObservationDefinitionCopyWithImpl<$Res>
    implements _$ObservationDefinitionCopyWith<$Res> {
  __$ObservationDefinitionCopyWithImpl(_ObservationDefinition _value,
      $Res Function(_ObservationDefinition) _then)
      : super(_value, (v) => _then(v as _ObservationDefinition));

  @override
  _ObservationDefinition get _value => super._value as _ObservationDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object permittedDataType = freezed,
    Object multipleResultsAllowed = freezed,
    Object method = freezed,
    Object preferredReportName = freezed,
    Object quantitativeDetails = freezed,
    Object qualifiedInterval = freezed,
    Object validCodedValueSet = freezed,
    Object normalCodedValueSet = freezed,
    Object abnormalCodedValueSet = freezed,
    Object criticalCodedValueSet = freezed,
  }) {
    return _then(_ObservationDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category: category == freezed
          ? _value.category
          : category as List<CodeableConcept>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      permittedDataType: permittedDataType == freezed
          ? _value.permittedDataType
          : permittedDataType as List<ObservationDefinitionPermittedDataType>,
      multipleResultsAllowed: multipleResultsAllowed == freezed
          ? _value.multipleResultsAllowed
          : multipleResultsAllowed as Boolean,
      method: method == freezed ? _value.method : method as CodeableConcept,
      preferredReportName: preferredReportName == freezed
          ? _value.preferredReportName
          : preferredReportName as String,
      quantitativeDetails: quantitativeDetails == freezed
          ? _value.quantitativeDetails
          : quantitativeDetails as ObservationDefinitionQuantitativeDetails,
      qualifiedInterval: qualifiedInterval == freezed
          ? _value.qualifiedInterval
          : qualifiedInterval as List<ObservationDefinitionQualifiedInterval>,
      validCodedValueSet: validCodedValueSet == freezed
          ? _value.validCodedValueSet
          : validCodedValueSet as Reference,
      normalCodedValueSet: normalCodedValueSet == freezed
          ? _value.normalCodedValueSet
          : normalCodedValueSet as Reference,
      abnormalCodedValueSet: abnormalCodedValueSet == freezed
          ? _value.abnormalCodedValueSet
          : abnormalCodedValueSet as Reference,
      criticalCodedValueSet: criticalCodedValueSet == freezed
          ? _value.criticalCodedValueSet
          : criticalCodedValueSet as Reference,
    ));
  }
}

@JsonSerializable()
class _$_ObservationDefinition implements _ObservationDefinition {
  const _$_ObservationDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ObservationDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.category,
      @required
      @JsonKey(required: true)
          this.code,
      this.identifier,
      this.permittedDataType,
      this.multipleResultsAllowed,
      this.method,
      this.preferredReportName,
      this.quantitativeDetails,
      this.qualifiedInterval,
      this.validCodedValueSet,
      this.normalCodedValueSet,
      this.abnormalCodedValueSet,
      this.criticalCodedValueSet})
      : assert(resourceType != null),
        assert(code != null);

  factory _$_ObservationDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_ObservationDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ObservationDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<CodeableConcept> category;
  @override
  @JsonKey(required: true)
  final CodeableConcept code;
  @override
  final List<Identifier> identifier;
  @override
  final List<ObservationDefinitionPermittedDataType> permittedDataType;
  @override
  final Boolean multipleResultsAllowed;
  @override
  final CodeableConcept method;
  @override
  final String preferredReportName;
  @override
  final ObservationDefinitionQuantitativeDetails quantitativeDetails;
  @override
  final List<ObservationDefinitionQualifiedInterval> qualifiedInterval;
  @override
  final Reference validCodedValueSet;
  @override
  final Reference normalCodedValueSet;
  @override
  final Reference abnormalCodedValueSet;
  @override
  final Reference criticalCodedValueSet;

  @override
  String toString() {
    return 'ObservationDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, code: $code, identifier: $identifier, permittedDataType: $permittedDataType, multipleResultsAllowed: $multipleResultsAllowed, method: $method, preferredReportName: $preferredReportName, quantitativeDetails: $quantitativeDetails, qualifiedInterval: $qualifiedInterval, validCodedValueSet: $validCodedValueSet, normalCodedValueSet: $normalCodedValueSet, abnormalCodedValueSet: $abnormalCodedValueSet, criticalCodedValueSet: $criticalCodedValueSet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ObservationDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.permittedDataType, permittedDataType) ||
                const DeepCollectionEquality()
                    .equals(other.permittedDataType, permittedDataType)) &&
            (identical(other.multipleResultsAllowed, multipleResultsAllowed) ||
                const DeepCollectionEquality().equals(
                    other.multipleResultsAllowed, multipleResultsAllowed)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.preferredReportName, preferredReportName) ||
                const DeepCollectionEquality()
                    .equals(other.preferredReportName, preferredReportName)) &&
            (identical(other.quantitativeDetails, quantitativeDetails) ||
                const DeepCollectionEquality()
                    .equals(other.quantitativeDetails, quantitativeDetails)) &&
            (identical(other.qualifiedInterval, qualifiedInterval) ||
                const DeepCollectionEquality()
                    .equals(other.qualifiedInterval, qualifiedInterval)) &&
            (identical(other.validCodedValueSet, validCodedValueSet) ||
                const DeepCollectionEquality()
                    .equals(other.validCodedValueSet, validCodedValueSet)) &&
            (identical(other.normalCodedValueSet, normalCodedValueSet) ||
                const DeepCollectionEquality()
                    .equals(other.normalCodedValueSet, normalCodedValueSet)) &&
            (identical(other.abnormalCodedValueSet, abnormalCodedValueSet) ||
                const DeepCollectionEquality().equals(
                    other.abnormalCodedValueSet, abnormalCodedValueSet)) &&
            (identical(other.criticalCodedValueSet, criticalCodedValueSet) ||
                const DeepCollectionEquality().equals(
                    other.criticalCodedValueSet, criticalCodedValueSet)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(permittedDataType) ^
      const DeepCollectionEquality().hash(multipleResultsAllowed) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(preferredReportName) ^
      const DeepCollectionEquality().hash(quantitativeDetails) ^
      const DeepCollectionEquality().hash(qualifiedInterval) ^
      const DeepCollectionEquality().hash(validCodedValueSet) ^
      const DeepCollectionEquality().hash(normalCodedValueSet) ^
      const DeepCollectionEquality().hash(abnormalCodedValueSet) ^
      const DeepCollectionEquality().hash(criticalCodedValueSet);

  @override
  _$ObservationDefinitionCopyWith<_ObservationDefinition> get copyWith =>
      __$ObservationDefinitionCopyWithImpl<_ObservationDefinition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ObservationDefinitionToJson(this);
  }
}

abstract class _ObservationDefinition implements ObservationDefinition {
  const factory _ObservationDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ObservationDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> category,
      @required
      @JsonKey(required: true)
          CodeableConcept code,
      List<Identifier> identifier,
      List<ObservationDefinitionPermittedDataType> permittedDataType,
      Boolean multipleResultsAllowed,
      CodeableConcept method,
      String preferredReportName,
      ObservationDefinitionQuantitativeDetails quantitativeDetails,
      List<ObservationDefinitionQualifiedInterval> qualifiedInterval,
      Reference validCodedValueSet,
      Reference normalCodedValueSet,
      Reference abnormalCodedValueSet,
      Reference criticalCodedValueSet}) = _$_ObservationDefinition;

  factory _ObservationDefinition.fromJson(Map<String, dynamic> json) =
      _$_ObservationDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ObservationDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<CodeableConcept> get category;
  @override
  @JsonKey(required: true)
  CodeableConcept get code;
  @override
  List<Identifier> get identifier;
  @override
  List<ObservationDefinitionPermittedDataType> get permittedDataType;
  @override
  Boolean get multipleResultsAllowed;
  @override
  CodeableConcept get method;
  @override
  String get preferredReportName;
  @override
  ObservationDefinitionQuantitativeDetails get quantitativeDetails;
  @override
  List<ObservationDefinitionQualifiedInterval> get qualifiedInterval;
  @override
  Reference get validCodedValueSet;
  @override
  Reference get normalCodedValueSet;
  @override
  Reference get abnormalCodedValueSet;
  @override
  Reference get criticalCodedValueSet;
  @override
  _$ObservationDefinitionCopyWith<_ObservationDefinition> get copyWith;
}

ObservationDefinitionQuantitativeDetails
    _$ObservationDefinitionQuantitativeDetailsFromJson(
        Map<String, dynamic> json) {
  return _ObservationDefinitionQuantitativeDetails.fromJson(json);
}

class _$ObservationDefinitionQuantitativeDetailsTearOff {
  const _$ObservationDefinitionQuantitativeDetailsTearOff();

  _ObservationDefinitionQuantitativeDetails call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept customaryUnit,
      CodeableConcept unit,
      Decimal conversionFactor,
      Integer decimalPrecision}) {
    return _ObservationDefinitionQuantitativeDetails(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      customaryUnit: customaryUnit,
      unit: unit,
      conversionFactor: conversionFactor,
      decimalPrecision: decimalPrecision,
    );
  }
}

// ignore: unused_element
const $ObservationDefinitionQuantitativeDetails =
    _$ObservationDefinitionQuantitativeDetailsTearOff();

mixin _$ObservationDefinitionQuantitativeDetails {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get customaryUnit;
  CodeableConcept get unit;
  Decimal get conversionFactor;
  Integer get decimalPrecision;

  Map<String, dynamic> toJson();
  $ObservationDefinitionQuantitativeDetailsCopyWith<
      ObservationDefinitionQuantitativeDetails> get copyWith;
}

abstract class $ObservationDefinitionQuantitativeDetailsCopyWith<$Res> {
  factory $ObservationDefinitionQuantitativeDetailsCopyWith(
          ObservationDefinitionQuantitativeDetails value,
          $Res Function(ObservationDefinitionQuantitativeDetails) then) =
      _$ObservationDefinitionQuantitativeDetailsCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept customaryUnit,
      CodeableConcept unit,
      Decimal conversionFactor,
      Integer decimalPrecision});

  $CodeableConceptCopyWith<$Res> get customaryUnit;
  $CodeableConceptCopyWith<$Res> get unit;
}

class _$ObservationDefinitionQuantitativeDetailsCopyWithImpl<$Res>
    implements $ObservationDefinitionQuantitativeDetailsCopyWith<$Res> {
  _$ObservationDefinitionQuantitativeDetailsCopyWithImpl(
      this._value, this._then);

  final ObservationDefinitionQuantitativeDetails _value;
  // ignore: unused_field
  final $Res Function(ObservationDefinitionQuantitativeDetails) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object customaryUnit = freezed,
    Object unit = freezed,
    Object conversionFactor = freezed,
    Object decimalPrecision = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      customaryUnit: customaryUnit == freezed
          ? _value.customaryUnit
          : customaryUnit as CodeableConcept,
      unit: unit == freezed ? _value.unit : unit as CodeableConcept,
      conversionFactor: conversionFactor == freezed
          ? _value.conversionFactor
          : conversionFactor as Decimal,
      decimalPrecision: decimalPrecision == freezed
          ? _value.decimalPrecision
          : decimalPrecision as Integer,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get customaryUnit {
    if (_value.customaryUnit == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.customaryUnit, (value) {
      return _then(_value.copyWith(customaryUnit: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unit {
    if (_value.unit == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unit, (value) {
      return _then(_value.copyWith(unit: value));
    });
  }
}

abstract class _$ObservationDefinitionQuantitativeDetailsCopyWith<$Res>
    implements $ObservationDefinitionQuantitativeDetailsCopyWith<$Res> {
  factory _$ObservationDefinitionQuantitativeDetailsCopyWith(
          _ObservationDefinitionQuantitativeDetails value,
          $Res Function(_ObservationDefinitionQuantitativeDetails) then) =
      __$ObservationDefinitionQuantitativeDetailsCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept customaryUnit,
      CodeableConcept unit,
      Decimal conversionFactor,
      Integer decimalPrecision});

  @override
  $CodeableConceptCopyWith<$Res> get customaryUnit;
  @override
  $CodeableConceptCopyWith<$Res> get unit;
}

class __$ObservationDefinitionQuantitativeDetailsCopyWithImpl<$Res>
    extends _$ObservationDefinitionQuantitativeDetailsCopyWithImpl<$Res>
    implements _$ObservationDefinitionQuantitativeDetailsCopyWith<$Res> {
  __$ObservationDefinitionQuantitativeDetailsCopyWithImpl(
      _ObservationDefinitionQuantitativeDetails _value,
      $Res Function(_ObservationDefinitionQuantitativeDetails) _then)
      : super(_value,
            (v) => _then(v as _ObservationDefinitionQuantitativeDetails));

  @override
  _ObservationDefinitionQuantitativeDetails get _value =>
      super._value as _ObservationDefinitionQuantitativeDetails;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object customaryUnit = freezed,
    Object unit = freezed,
    Object conversionFactor = freezed,
    Object decimalPrecision = freezed,
  }) {
    return _then(_ObservationDefinitionQuantitativeDetails(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      customaryUnit: customaryUnit == freezed
          ? _value.customaryUnit
          : customaryUnit as CodeableConcept,
      unit: unit == freezed ? _value.unit : unit as CodeableConcept,
      conversionFactor: conversionFactor == freezed
          ? _value.conversionFactor
          : conversionFactor as Decimal,
      decimalPrecision: decimalPrecision == freezed
          ? _value.decimalPrecision
          : decimalPrecision as Integer,
    ));
  }
}

@JsonSerializable()
class _$_ObservationDefinitionQuantitativeDetails
    implements _ObservationDefinitionQuantitativeDetails {
  const _$_ObservationDefinitionQuantitativeDetails(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.customaryUnit,
      this.unit,
      this.conversionFactor,
      this.decimalPrecision});

  factory _$_ObservationDefinitionQuantitativeDetails.fromJson(
          Map<String, dynamic> json) =>
      _$_$_ObservationDefinitionQuantitativeDetailsFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept customaryUnit;
  @override
  final CodeableConcept unit;
  @override
  final Decimal conversionFactor;
  @override
  final Integer decimalPrecision;

  @override
  String toString() {
    return 'ObservationDefinitionQuantitativeDetails(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, customaryUnit: $customaryUnit, unit: $unit, conversionFactor: $conversionFactor, decimalPrecision: $decimalPrecision)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ObservationDefinitionQuantitativeDetails &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.customaryUnit, customaryUnit) ||
                const DeepCollectionEquality()
                    .equals(other.customaryUnit, customaryUnit)) &&
            (identical(other.unit, unit) ||
                const DeepCollectionEquality().equals(other.unit, unit)) &&
            (identical(other.conversionFactor, conversionFactor) ||
                const DeepCollectionEquality()
                    .equals(other.conversionFactor, conversionFactor)) &&
            (identical(other.decimalPrecision, decimalPrecision) ||
                const DeepCollectionEquality()
                    .equals(other.decimalPrecision, decimalPrecision)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(customaryUnit) ^
      const DeepCollectionEquality().hash(unit) ^
      const DeepCollectionEquality().hash(conversionFactor) ^
      const DeepCollectionEquality().hash(decimalPrecision);

  @override
  _$ObservationDefinitionQuantitativeDetailsCopyWith<
          _ObservationDefinitionQuantitativeDetails>
      get copyWith => __$ObservationDefinitionQuantitativeDetailsCopyWithImpl<
          _ObservationDefinitionQuantitativeDetails>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ObservationDefinitionQuantitativeDetailsToJson(this);
  }
}

abstract class _ObservationDefinitionQuantitativeDetails
    implements ObservationDefinitionQuantitativeDetails {
  const factory _ObservationDefinitionQuantitativeDetails(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept customaryUnit,
      CodeableConcept unit,
      Decimal conversionFactor,
      Integer decimalPrecision}) = _$_ObservationDefinitionQuantitativeDetails;

  factory _ObservationDefinitionQuantitativeDetails.fromJson(
          Map<String, dynamic> json) =
      _$_ObservationDefinitionQuantitativeDetails.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get customaryUnit;
  @override
  CodeableConcept get unit;
  @override
  Decimal get conversionFactor;
  @override
  Integer get decimalPrecision;
  @override
  _$ObservationDefinitionQuantitativeDetailsCopyWith<
      _ObservationDefinitionQuantitativeDetails> get copyWith;
}

ObservationDefinitionQualifiedInterval
    _$ObservationDefinitionQualifiedIntervalFromJson(
        Map<String, dynamic> json) {
  return _ObservationDefinitionQualifiedInterval.fromJson(json);
}

class _$ObservationDefinitionQualifiedIntervalTearOff {
  const _$ObservationDefinitionQualifiedIntervalTearOff();

  _ObservationDefinitionQualifiedInterval call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
          QualifiedIntervalCategory category,
      Range range,
      CodeableConcept context,
      List<CodeableConcept> appliesTo,
      @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
          QualifiedIntervalGender gender,
      Range age,
      Range gestationalAge,
      String condition}) {
    return _ObservationDefinitionQualifiedInterval(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      category: category,
      range: range,
      context: context,
      appliesTo: appliesTo,
      gender: gender,
      age: age,
      gestationalAge: gestationalAge,
      condition: condition,
    );
  }
}

// ignore: unused_element
const $ObservationDefinitionQualifiedInterval =
    _$ObservationDefinitionQualifiedIntervalTearOff();

mixin _$ObservationDefinitionQualifiedInterval {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
  QualifiedIntervalCategory get category;
  Range get range;
  CodeableConcept get context;
  List<CodeableConcept> get appliesTo;
  @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
  QualifiedIntervalGender get gender;
  Range get age;
  Range get gestationalAge;
  String get condition;

  Map<String, dynamic> toJson();
  $ObservationDefinitionQualifiedIntervalCopyWith<
      ObservationDefinitionQualifiedInterval> get copyWith;
}

abstract class $ObservationDefinitionQualifiedIntervalCopyWith<$Res> {
  factory $ObservationDefinitionQualifiedIntervalCopyWith(
          ObservationDefinitionQualifiedInterval value,
          $Res Function(ObservationDefinitionQualifiedInterval) then) =
      _$ObservationDefinitionQualifiedIntervalCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
          QualifiedIntervalCategory category,
      Range range,
      CodeableConcept context,
      List<CodeableConcept> appliesTo,
      @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
          QualifiedIntervalGender gender,
      Range age,
      Range gestationalAge,
      String condition});

  $RangeCopyWith<$Res> get range;
  $CodeableConceptCopyWith<$Res> get context;
  $RangeCopyWith<$Res> get age;
  $RangeCopyWith<$Res> get gestationalAge;
}

class _$ObservationDefinitionQualifiedIntervalCopyWithImpl<$Res>
    implements $ObservationDefinitionQualifiedIntervalCopyWith<$Res> {
  _$ObservationDefinitionQualifiedIntervalCopyWithImpl(this._value, this._then);

  final ObservationDefinitionQualifiedInterval _value;
  // ignore: unused_field
  final $Res Function(ObservationDefinitionQualifiedInterval) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object range = freezed,
    Object context = freezed,
    Object appliesTo = freezed,
    Object gender = freezed,
    Object age = freezed,
    Object gestationalAge = freezed,
    Object condition = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category: category == freezed
          ? _value.category
          : category as QualifiedIntervalCategory,
      range: range == freezed ? _value.range : range as Range,
      context: context == freezed ? _value.context : context as CodeableConcept,
      appliesTo: appliesTo == freezed
          ? _value.appliesTo
          : appliesTo as List<CodeableConcept>,
      gender:
          gender == freezed ? _value.gender : gender as QualifiedIntervalGender,
      age: age == freezed ? _value.age : age as Range,
      gestationalAge: gestationalAge == freezed
          ? _value.gestationalAge
          : gestationalAge as Range,
      condition: condition == freezed ? _value.condition : condition as String,
    ));
  }

  @override
  $RangeCopyWith<$Res> get range {
    if (_value.range == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.range, (value) {
      return _then(_value.copyWith(range: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get context {
    if (_value.context == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.context, (value) {
      return _then(_value.copyWith(context: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get age {
    if (_value.age == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.age, (value) {
      return _then(_value.copyWith(age: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get gestationalAge {
    if (_value.gestationalAge == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.gestationalAge, (value) {
      return _then(_value.copyWith(gestationalAge: value));
    });
  }
}

abstract class _$ObservationDefinitionQualifiedIntervalCopyWith<$Res>
    implements $ObservationDefinitionQualifiedIntervalCopyWith<$Res> {
  factory _$ObservationDefinitionQualifiedIntervalCopyWith(
          _ObservationDefinitionQualifiedInterval value,
          $Res Function(_ObservationDefinitionQualifiedInterval) then) =
      __$ObservationDefinitionQualifiedIntervalCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
          QualifiedIntervalCategory category,
      Range range,
      CodeableConcept context,
      List<CodeableConcept> appliesTo,
      @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
          QualifiedIntervalGender gender,
      Range age,
      Range gestationalAge,
      String condition});

  @override
  $RangeCopyWith<$Res> get range;
  @override
  $CodeableConceptCopyWith<$Res> get context;
  @override
  $RangeCopyWith<$Res> get age;
  @override
  $RangeCopyWith<$Res> get gestationalAge;
}

class __$ObservationDefinitionQualifiedIntervalCopyWithImpl<$Res>
    extends _$ObservationDefinitionQualifiedIntervalCopyWithImpl<$Res>
    implements _$ObservationDefinitionQualifiedIntervalCopyWith<$Res> {
  __$ObservationDefinitionQualifiedIntervalCopyWithImpl(
      _ObservationDefinitionQualifiedInterval _value,
      $Res Function(_ObservationDefinitionQualifiedInterval) _then)
      : super(
            _value, (v) => _then(v as _ObservationDefinitionQualifiedInterval));

  @override
  _ObservationDefinitionQualifiedInterval get _value =>
      super._value as _ObservationDefinitionQualifiedInterval;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object range = freezed,
    Object context = freezed,
    Object appliesTo = freezed,
    Object gender = freezed,
    Object age = freezed,
    Object gestationalAge = freezed,
    Object condition = freezed,
  }) {
    return _then(_ObservationDefinitionQualifiedInterval(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category: category == freezed
          ? _value.category
          : category as QualifiedIntervalCategory,
      range: range == freezed ? _value.range : range as Range,
      context: context == freezed ? _value.context : context as CodeableConcept,
      appliesTo: appliesTo == freezed
          ? _value.appliesTo
          : appliesTo as List<CodeableConcept>,
      gender:
          gender == freezed ? _value.gender : gender as QualifiedIntervalGender,
      age: age == freezed ? _value.age : age as Range,
      gestationalAge: gestationalAge == freezed
          ? _value.gestationalAge
          : gestationalAge as Range,
      condition: condition == freezed ? _value.condition : condition as String,
    ));
  }
}

@JsonSerializable()
class _$_ObservationDefinitionQualifiedInterval
    implements _ObservationDefinitionQualifiedInterval {
  const _$_ObservationDefinitionQualifiedInterval(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
          this.category,
      this.range,
      this.context,
      this.appliesTo,
      @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
          this.gender,
      this.age,
      this.gestationalAge,
      this.condition});

  factory _$_ObservationDefinitionQualifiedInterval.fromJson(
          Map<String, dynamic> json) =>
      _$_$_ObservationDefinitionQualifiedIntervalFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
  final QualifiedIntervalCategory category;
  @override
  final Range range;
  @override
  final CodeableConcept context;
  @override
  final List<CodeableConcept> appliesTo;
  @override
  @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
  final QualifiedIntervalGender gender;
  @override
  final Range age;
  @override
  final Range gestationalAge;
  @override
  final String condition;

  @override
  String toString() {
    return 'ObservationDefinitionQualifiedInterval(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, range: $range, context: $context, appliesTo: $appliesTo, gender: $gender, age: $age, gestationalAge: $gestationalAge, condition: $condition)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ObservationDefinitionQualifiedInterval &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality()
                    .equals(other.context, context)) &&
            (identical(other.appliesTo, appliesTo) ||
                const DeepCollectionEquality()
                    .equals(other.appliesTo, appliesTo)) &&
            (identical(other.gender, gender) ||
                const DeepCollectionEquality().equals(other.gender, gender)) &&
            (identical(other.age, age) ||
                const DeepCollectionEquality().equals(other.age, age)) &&
            (identical(other.gestationalAge, gestationalAge) ||
                const DeepCollectionEquality()
                    .equals(other.gestationalAge, gestationalAge)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(context) ^
      const DeepCollectionEquality().hash(appliesTo) ^
      const DeepCollectionEquality().hash(gender) ^
      const DeepCollectionEquality().hash(age) ^
      const DeepCollectionEquality().hash(gestationalAge) ^
      const DeepCollectionEquality().hash(condition);

  @override
  _$ObservationDefinitionQualifiedIntervalCopyWith<
          _ObservationDefinitionQualifiedInterval>
      get copyWith => __$ObservationDefinitionQualifiedIntervalCopyWithImpl<
          _ObservationDefinitionQualifiedInterval>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ObservationDefinitionQualifiedIntervalToJson(this);
  }
}

abstract class _ObservationDefinitionQualifiedInterval
    implements ObservationDefinitionQualifiedInterval {
  const factory _ObservationDefinitionQualifiedInterval(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
          QualifiedIntervalCategory category,
      Range range,
      CodeableConcept context,
      List<CodeableConcept> appliesTo,
      @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
          QualifiedIntervalGender gender,
      Range age,
      Range gestationalAge,
      String condition}) = _$_ObservationDefinitionQualifiedInterval;

  factory _ObservationDefinitionQualifiedInterval.fromJson(
          Map<String, dynamic> json) =
      _$_ObservationDefinitionQualifiedInterval.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: QualifiedIntervalCategory.unknown)
  QualifiedIntervalCategory get category;
  @override
  Range get range;
  @override
  CodeableConcept get context;
  @override
  List<CodeableConcept> get appliesTo;
  @override
  @JsonKey(unknownEnumValue: QualifiedIntervalGender.unknown)
  QualifiedIntervalGender get gender;
  @override
  Range get age;
  @override
  Range get gestationalAge;
  @override
  String get condition;
  @override
  _$ObservationDefinitionQualifiedIntervalCopyWith<
      _ObservationDefinitionQualifiedInterval> get copyWith;
}

PlanDefinition _$PlanDefinitionFromJson(Map<String, dynamic> json) {
  return _PlanDefinition.fromJson(json);
}

class _$PlanDefinitionTearOff {
  const _$PlanDefinitionTearOff();

  _PlanDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'PlanDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
          PlanDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      List<PlanDefinitionGoal> goal,
      List<PlanDefinitionAction> action}) {
    return _PlanDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      subtitle: subtitle,
      type: type,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      library: library,
      goal: goal,
      action: action,
    );
  }
}

// ignore: unused_element
const $PlanDefinition = _$PlanDefinitionTearOff();

mixin _$PlanDefinition {
  @JsonKey(required: true, defaultValue: 'PlanDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get subtitle;
  CodeableConcept get type;
  @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
  PlanDefinitionStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  List<Canonical> get library;
  List<PlanDefinitionGoal> get goal;
  List<PlanDefinitionAction> get action;

  Map<String, dynamic> toJson();
  $PlanDefinitionCopyWith<PlanDefinition> get copyWith;
}

abstract class $PlanDefinitionCopyWith<$Res> {
  factory $PlanDefinitionCopyWith(
          PlanDefinition value, $Res Function(PlanDefinition) then) =
      _$PlanDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'PlanDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
          PlanDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      List<PlanDefinitionGoal> goal,
      List<PlanDefinitionAction> action});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class _$PlanDefinitionCopyWithImpl<$Res>
    implements $PlanDefinitionCopyWith<$Res> {
  _$PlanDefinitionCopyWithImpl(this._value, this._then);

  final PlanDefinition _value;
  // ignore: unused_field
  final $Res Function(PlanDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object type = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object goal = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status:
          status == freezed ? _value.status : status as PlanDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      goal: goal == freezed ? _value.goal : goal as List<PlanDefinitionGoal>,
      action: action == freezed
          ? _value.action
          : action as List<PlanDefinitionAction>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }
}

abstract class _$PlanDefinitionCopyWith<$Res>
    implements $PlanDefinitionCopyWith<$Res> {
  factory _$PlanDefinitionCopyWith(
          _PlanDefinition value, $Res Function(_PlanDefinition) then) =
      __$PlanDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'PlanDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
          PlanDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      List<PlanDefinitionGoal> goal,
      List<PlanDefinitionAction> action});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class __$PlanDefinitionCopyWithImpl<$Res>
    extends _$PlanDefinitionCopyWithImpl<$Res>
    implements _$PlanDefinitionCopyWith<$Res> {
  __$PlanDefinitionCopyWithImpl(
      _PlanDefinition _value, $Res Function(_PlanDefinition) _then)
      : super(_value, (v) => _then(v as _PlanDefinition));

  @override
  _PlanDefinition get _value => super._value as _PlanDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object subtitle = freezed,
    Object type = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object goal = freezed,
    Object action = freezed,
  }) {
    return _then(_PlanDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status:
          status == freezed ? _value.status : status as PlanDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      goal: goal == freezed ? _value.goal : goal as List<PlanDefinitionGoal>,
      action: action == freezed
          ? _value.action
          : action as List<PlanDefinitionAction>,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinition implements _PlanDefinition {
  const _$_PlanDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'PlanDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.subtitle,
      this.type,
      @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.library,
      this.goal,
      this.action})
      : assert(resourceType != null);

  factory _$_PlanDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'PlanDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String subtitle;
  @override
  final CodeableConcept type;
  @override
  @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
  final PlanDefinitionStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<Canonical> library;
  @override
  final List<PlanDefinitionGoal> goal;
  @override
  final List<PlanDefinitionAction> action;

  @override
  String toString() {
    return 'PlanDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, subtitle: $subtitle, type: $type, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, library: $library, goal: $goal, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality().equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.library, library) || const DeepCollectionEquality().equals(other.library, library)) &&
            (identical(other.goal, goal) || const DeepCollectionEquality().equals(other.goal, goal)) &&
            (identical(other.action, action) || const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(library) ^
      const DeepCollectionEquality().hash(goal) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$PlanDefinitionCopyWith<_PlanDefinition> get copyWith =>
      __$PlanDefinitionCopyWithImpl<_PlanDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionToJson(this);
  }
}

abstract class _PlanDefinition implements PlanDefinition {
  const factory _PlanDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'PlanDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String subtitle,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
          PlanDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      List<PlanDefinitionGoal> goal,
      List<PlanDefinitionAction> action}) = _$_PlanDefinition;

  factory _PlanDefinition.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'PlanDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get subtitle;
  @override
  CodeableConcept get type;
  @override
  @JsonKey(unknownEnumValue: PlanDefinitionStatus.unknown)
  PlanDefinitionStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<Canonical> get library;
  @override
  List<PlanDefinitionGoal> get goal;
  @override
  List<PlanDefinitionAction> get action;
  @override
  _$PlanDefinitionCopyWith<_PlanDefinition> get copyWith;
}

PlanDefinitionGoal _$PlanDefinitionGoalFromJson(Map<String, dynamic> json) {
  return _PlanDefinitionGoal.fromJson(json);
}

class _$PlanDefinitionGoalTearOff {
  const _$PlanDefinitionGoalTearOff();

  _PlanDefinitionGoal call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      @required @JsonKey(required: true) CodeableConcept description,
      CodeableConcept priority,
      CodeableConcept start,
      List<CodeableConcept> addresses,
      List<RelatedArtifact> documentation,
      List<PlanDefinitionTarget> target}) {
    return _PlanDefinitionGoal(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      category: category,
      description: description,
      priority: priority,
      start: start,
      addresses: addresses,
      documentation: documentation,
      target: target,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionGoal = _$PlanDefinitionGoalTearOff();

mixin _$PlanDefinitionGoal {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get category;
  @JsonKey(required: true)
  CodeableConcept get description;
  CodeableConcept get priority;
  CodeableConcept get start;
  List<CodeableConcept> get addresses;
  List<RelatedArtifact> get documentation;
  List<PlanDefinitionTarget> get target;

  Map<String, dynamic> toJson();
  $PlanDefinitionGoalCopyWith<PlanDefinitionGoal> get copyWith;
}

abstract class $PlanDefinitionGoalCopyWith<$Res> {
  factory $PlanDefinitionGoalCopyWith(
          PlanDefinitionGoal value, $Res Function(PlanDefinitionGoal) then) =
      _$PlanDefinitionGoalCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      @JsonKey(required: true) CodeableConcept description,
      CodeableConcept priority,
      CodeableConcept start,
      List<CodeableConcept> addresses,
      List<RelatedArtifact> documentation,
      List<PlanDefinitionTarget> target});

  $CodeableConceptCopyWith<$Res> get category;
  $CodeableConceptCopyWith<$Res> get description;
  $CodeableConceptCopyWith<$Res> get priority;
  $CodeableConceptCopyWith<$Res> get start;
}

class _$PlanDefinitionGoalCopyWithImpl<$Res>
    implements $PlanDefinitionGoalCopyWith<$Res> {
  _$PlanDefinitionGoalCopyWithImpl(this._value, this._then);

  final PlanDefinitionGoal _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionGoal) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object description = freezed,
    Object priority = freezed,
    Object start = freezed,
    Object addresses = freezed,
    Object documentation = freezed,
    Object target = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category:
          category == freezed ? _value.category : category as CodeableConcept,
      description: description == freezed
          ? _value.description
          : description as CodeableConcept,
      priority:
          priority == freezed ? _value.priority : priority as CodeableConcept,
      start: start == freezed ? _value.start : start as CodeableConcept,
      addresses: addresses == freezed
          ? _value.addresses
          : addresses as List<CodeableConcept>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as List<RelatedArtifact>,
      target: target == freezed
          ? _value.target
          : target as List<PlanDefinitionTarget>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get category {
    if (_value.category == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get description {
    if (_value.description == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.description, (value) {
      return _then(_value.copyWith(description: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get priority {
    if (_value.priority == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.priority, (value) {
      return _then(_value.copyWith(priority: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get start {
    if (_value.start == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.start, (value) {
      return _then(_value.copyWith(start: value));
    });
  }
}

abstract class _$PlanDefinitionGoalCopyWith<$Res>
    implements $PlanDefinitionGoalCopyWith<$Res> {
  factory _$PlanDefinitionGoalCopyWith(
          _PlanDefinitionGoal value, $Res Function(_PlanDefinitionGoal) then) =
      __$PlanDefinitionGoalCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      @JsonKey(required: true) CodeableConcept description,
      CodeableConcept priority,
      CodeableConcept start,
      List<CodeableConcept> addresses,
      List<RelatedArtifact> documentation,
      List<PlanDefinitionTarget> target});

  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $CodeableConceptCopyWith<$Res> get description;
  @override
  $CodeableConceptCopyWith<$Res> get priority;
  @override
  $CodeableConceptCopyWith<$Res> get start;
}

class __$PlanDefinitionGoalCopyWithImpl<$Res>
    extends _$PlanDefinitionGoalCopyWithImpl<$Res>
    implements _$PlanDefinitionGoalCopyWith<$Res> {
  __$PlanDefinitionGoalCopyWithImpl(
      _PlanDefinitionGoal _value, $Res Function(_PlanDefinitionGoal) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionGoal));

  @override
  _PlanDefinitionGoal get _value => super._value as _PlanDefinitionGoal;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object description = freezed,
    Object priority = freezed,
    Object start = freezed,
    Object addresses = freezed,
    Object documentation = freezed,
    Object target = freezed,
  }) {
    return _then(_PlanDefinitionGoal(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category:
          category == freezed ? _value.category : category as CodeableConcept,
      description: description == freezed
          ? _value.description
          : description as CodeableConcept,
      priority:
          priority == freezed ? _value.priority : priority as CodeableConcept,
      start: start == freezed ? _value.start : start as CodeableConcept,
      addresses: addresses == freezed
          ? _value.addresses
          : addresses as List<CodeableConcept>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as List<RelatedArtifact>,
      target: target == freezed
          ? _value.target
          : target as List<PlanDefinitionTarget>,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionGoal implements _PlanDefinitionGoal {
  const _$_PlanDefinitionGoal(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.category,
      @required @JsonKey(required: true) this.description,
      this.priority,
      this.start,
      this.addresses,
      this.documentation,
      this.target})
      : assert(description != null);

  factory _$_PlanDefinitionGoal.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionGoalFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept category;
  @override
  @JsonKey(required: true)
  final CodeableConcept description;
  @override
  final CodeableConcept priority;
  @override
  final CodeableConcept start;
  @override
  final List<CodeableConcept> addresses;
  @override
  final List<RelatedArtifact> documentation;
  @override
  final List<PlanDefinitionTarget> target;

  @override
  String toString() {
    return 'PlanDefinitionGoal(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, description: $description, priority: $priority, start: $start, addresses: $addresses, documentation: $documentation, target: $target)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionGoal &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)) &&
            (identical(other.documentation, documentation) ||
                const DeepCollectionEquality()
                    .equals(other.documentation, documentation)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(addresses) ^
      const DeepCollectionEquality().hash(documentation) ^
      const DeepCollectionEquality().hash(target);

  @override
  _$PlanDefinitionGoalCopyWith<_PlanDefinitionGoal> get copyWith =>
      __$PlanDefinitionGoalCopyWithImpl<_PlanDefinitionGoal>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionGoalToJson(this);
  }
}

abstract class _PlanDefinitionGoal implements PlanDefinitionGoal {
  const factory _PlanDefinitionGoal(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      @required @JsonKey(required: true) CodeableConcept description,
      CodeableConcept priority,
      CodeableConcept start,
      List<CodeableConcept> addresses,
      List<RelatedArtifact> documentation,
      List<PlanDefinitionTarget> target}) = _$_PlanDefinitionGoal;

  factory _PlanDefinitionGoal.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionGoal.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get category;
  @override
  @JsonKey(required: true)
  CodeableConcept get description;
  @override
  CodeableConcept get priority;
  @override
  CodeableConcept get start;
  @override
  List<CodeableConcept> get addresses;
  @override
  List<RelatedArtifact> get documentation;
  @override
  List<PlanDefinitionTarget> get target;
  @override
  _$PlanDefinitionGoalCopyWith<_PlanDefinitionGoal> get copyWith;
}

PlanDefinitionTarget _$PlanDefinitionTargetFromJson(Map<String, dynamic> json) {
  return _PlanDefinitionTarget.fromJson(json);
}

class _$PlanDefinitionTargetTearOff {
  const _$PlanDefinitionTargetTearOff();

  _PlanDefinitionTarget call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept measure,
      Quantity detailQuantity,
      Range detailRange,
      CodeableConcept detailCodeableConcept,
      Duration due}) {
    return _PlanDefinitionTarget(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      measure: measure,
      detailQuantity: detailQuantity,
      detailRange: detailRange,
      detailCodeableConcept: detailCodeableConcept,
      due: due,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionTarget = _$PlanDefinitionTargetTearOff();

mixin _$PlanDefinitionTarget {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get measure;
  Quantity get detailQuantity;
  Range get detailRange;
  CodeableConcept get detailCodeableConcept;
  Duration get due;

  Map<String, dynamic> toJson();
  $PlanDefinitionTargetCopyWith<PlanDefinitionTarget> get copyWith;
}

abstract class $PlanDefinitionTargetCopyWith<$Res> {
  factory $PlanDefinitionTargetCopyWith(PlanDefinitionTarget value,
          $Res Function(PlanDefinitionTarget) then) =
      _$PlanDefinitionTargetCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept measure,
      Quantity detailQuantity,
      Range detailRange,
      CodeableConcept detailCodeableConcept,
      Duration due});

  $CodeableConceptCopyWith<$Res> get measure;
  $QuantityCopyWith<$Res> get detailQuantity;
  $RangeCopyWith<$Res> get detailRange;
  $CodeableConceptCopyWith<$Res> get detailCodeableConcept;
  $DurationCopyWith<$Res> get due;
}

class _$PlanDefinitionTargetCopyWithImpl<$Res>
    implements $PlanDefinitionTargetCopyWith<$Res> {
  _$PlanDefinitionTargetCopyWithImpl(this._value, this._then);

  final PlanDefinitionTarget _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionTarget) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object measure = freezed,
    Object detailQuantity = freezed,
    Object detailRange = freezed,
    Object detailCodeableConcept = freezed,
    Object due = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      measure: measure == freezed ? _value.measure : measure as CodeableConcept,
      detailQuantity: detailQuantity == freezed
          ? _value.detailQuantity
          : detailQuantity as Quantity,
      detailRange:
          detailRange == freezed ? _value.detailRange : detailRange as Range,
      detailCodeableConcept: detailCodeableConcept == freezed
          ? _value.detailCodeableConcept
          : detailCodeableConcept as CodeableConcept,
      due: due == freezed ? _value.due : due as Duration,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get measure {
    if (_value.measure == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.measure, (value) {
      return _then(_value.copyWith(measure: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get detailQuantity {
    if (_value.detailQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.detailQuantity, (value) {
      return _then(_value.copyWith(detailQuantity: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get detailRange {
    if (_value.detailRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.detailRange, (value) {
      return _then(_value.copyWith(detailRange: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get detailCodeableConcept {
    if (_value.detailCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.detailCodeableConcept,
        (value) {
      return _then(_value.copyWith(detailCodeableConcept: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get due {
    if (_value.due == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.due, (value) {
      return _then(_value.copyWith(due: value));
    });
  }
}

abstract class _$PlanDefinitionTargetCopyWith<$Res>
    implements $PlanDefinitionTargetCopyWith<$Res> {
  factory _$PlanDefinitionTargetCopyWith(_PlanDefinitionTarget value,
          $Res Function(_PlanDefinitionTarget) then) =
      __$PlanDefinitionTargetCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept measure,
      Quantity detailQuantity,
      Range detailRange,
      CodeableConcept detailCodeableConcept,
      Duration due});

  @override
  $CodeableConceptCopyWith<$Res> get measure;
  @override
  $QuantityCopyWith<$Res> get detailQuantity;
  @override
  $RangeCopyWith<$Res> get detailRange;
  @override
  $CodeableConceptCopyWith<$Res> get detailCodeableConcept;
  @override
  $DurationCopyWith<$Res> get due;
}

class __$PlanDefinitionTargetCopyWithImpl<$Res>
    extends _$PlanDefinitionTargetCopyWithImpl<$Res>
    implements _$PlanDefinitionTargetCopyWith<$Res> {
  __$PlanDefinitionTargetCopyWithImpl(
      _PlanDefinitionTarget _value, $Res Function(_PlanDefinitionTarget) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionTarget));

  @override
  _PlanDefinitionTarget get _value => super._value as _PlanDefinitionTarget;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object measure = freezed,
    Object detailQuantity = freezed,
    Object detailRange = freezed,
    Object detailCodeableConcept = freezed,
    Object due = freezed,
  }) {
    return _then(_PlanDefinitionTarget(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      measure: measure == freezed ? _value.measure : measure as CodeableConcept,
      detailQuantity: detailQuantity == freezed
          ? _value.detailQuantity
          : detailQuantity as Quantity,
      detailRange:
          detailRange == freezed ? _value.detailRange : detailRange as Range,
      detailCodeableConcept: detailCodeableConcept == freezed
          ? _value.detailCodeableConcept
          : detailCodeableConcept as CodeableConcept,
      due: due == freezed ? _value.due : due as Duration,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionTarget implements _PlanDefinitionTarget {
  const _$_PlanDefinitionTarget(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.measure,
      this.detailQuantity,
      this.detailRange,
      this.detailCodeableConcept,
      this.due});

  factory _$_PlanDefinitionTarget.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionTargetFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept measure;
  @override
  final Quantity detailQuantity;
  @override
  final Range detailRange;
  @override
  final CodeableConcept detailCodeableConcept;
  @override
  final Duration due;

  @override
  String toString() {
    return 'PlanDefinitionTarget(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, measure: $measure, detailQuantity: $detailQuantity, detailRange: $detailRange, detailCodeableConcept: $detailCodeableConcept, due: $due)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionTarget &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.measure, measure) ||
                const DeepCollectionEquality()
                    .equals(other.measure, measure)) &&
            (identical(other.detailQuantity, detailQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.detailQuantity, detailQuantity)) &&
            (identical(other.detailRange, detailRange) ||
                const DeepCollectionEquality()
                    .equals(other.detailRange, detailRange)) &&
            (identical(other.detailCodeableConcept, detailCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.detailCodeableConcept, detailCodeableConcept)) &&
            (identical(other.due, due) ||
                const DeepCollectionEquality().equals(other.due, due)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(measure) ^
      const DeepCollectionEquality().hash(detailQuantity) ^
      const DeepCollectionEquality().hash(detailRange) ^
      const DeepCollectionEquality().hash(detailCodeableConcept) ^
      const DeepCollectionEquality().hash(due);

  @override
  _$PlanDefinitionTargetCopyWith<_PlanDefinitionTarget> get copyWith =>
      __$PlanDefinitionTargetCopyWithImpl<_PlanDefinitionTarget>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionTargetToJson(this);
  }
}

abstract class _PlanDefinitionTarget implements PlanDefinitionTarget {
  const factory _PlanDefinitionTarget(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept measure,
      Quantity detailQuantity,
      Range detailRange,
      CodeableConcept detailCodeableConcept,
      Duration due}) = _$_PlanDefinitionTarget;

  factory _PlanDefinitionTarget.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionTarget.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get measure;
  @override
  Quantity get detailQuantity;
  @override
  Range get detailRange;
  @override
  CodeableConcept get detailCodeableConcept;
  @override
  Duration get due;
  @override
  _$PlanDefinitionTargetCopyWith<_PlanDefinitionTarget> get copyWith;
}

PlanDefinitionAction _$PlanDefinitionActionFromJson(Map<String, dynamic> json) {
  return _PlanDefinitionAction.fromJson(json);
}

class _$PlanDefinitionActionTearOff {
  const _$PlanDefinitionActionTearOff();

  _PlanDefinitionAction call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String prefix,
      String title,
      String description,
      String textEquivalent,
      Code priority,
      List<CodeableConcept> code,
      List<CodeableConcept> reason,
      List<RelatedArtifact> documentation,
      List<Id> goalId,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      List<TriggerDefinition> trigger,
      List<PlanDefinitionCondition> condition,
      List<DataRequirement> input,
      List<DataRequirement> output,
      List<PlanDefinitionRelatedAction> relatedAction,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Duration timingDuration,
      Range timingRange,
      Timing timingTiming,
      List<PlanDefinitionParticipant> participant,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
          ActionGroupingBehavior groupingBehavior,
      @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
          ActionSelectionBehavior selectionBehavior,
      @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
          ActionRequiredBehavior requiredBehavior,
      @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
          ActionPrecheckBehavior precheckBehavior,
      @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
          ActionCardinalityBehavior cardinalityBehavior,
      Canonical definitionCanonical,
      FhirUri definitionUri,
      Canonical transform,
      List<PlanDefinitionDynamicValue> dynamicValue,
      List<PlanDefinitionAction> action}) {
    return _PlanDefinitionAction(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      prefix: prefix,
      title: title,
      description: description,
      textEquivalent: textEquivalent,
      priority: priority,
      code: code,
      reason: reason,
      documentation: documentation,
      goalId: goalId,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      trigger: trigger,
      condition: condition,
      input: input,
      output: output,
      relatedAction: relatedAction,
      timingDateTime: timingDateTime,
      timingAge: timingAge,
      timingPeriod: timingPeriod,
      timingDuration: timingDuration,
      timingRange: timingRange,
      timingTiming: timingTiming,
      participant: participant,
      type: type,
      groupingBehavior: groupingBehavior,
      selectionBehavior: selectionBehavior,
      requiredBehavior: requiredBehavior,
      precheckBehavior: precheckBehavior,
      cardinalityBehavior: cardinalityBehavior,
      definitionCanonical: definitionCanonical,
      definitionUri: definitionUri,
      transform: transform,
      dynamicValue: dynamicValue,
      action: action,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionAction = _$PlanDefinitionActionTearOff();

mixin _$PlanDefinitionAction {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get prefix;
  String get title;
  String get description;
  String get textEquivalent;
  Code get priority;
  List<CodeableConcept> get code;
  List<CodeableConcept> get reason;
  List<RelatedArtifact> get documentation;
  List<Id> get goalId;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  List<TriggerDefinition> get trigger;
  List<PlanDefinitionCondition> get condition;
  List<DataRequirement> get input;
  List<DataRequirement> get output;
  List<PlanDefinitionRelatedAction> get relatedAction;
  FhirDateTime get timingDateTime;
  Age get timingAge;
  Period get timingPeriod;
  Duration get timingDuration;
  Range get timingRange;
  Timing get timingTiming;
  List<PlanDefinitionParticipant> get participant;
  CodeableConcept get type;
  @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
  ActionGroupingBehavior get groupingBehavior;
  @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
  ActionSelectionBehavior get selectionBehavior;
  @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
  ActionRequiredBehavior get requiredBehavior;
  @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
  ActionPrecheckBehavior get precheckBehavior;
  @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
  ActionCardinalityBehavior get cardinalityBehavior;
  Canonical get definitionCanonical;
  FhirUri get definitionUri;
  Canonical get transform;
  List<PlanDefinitionDynamicValue> get dynamicValue;
  List<PlanDefinitionAction> get action;

  Map<String, dynamic> toJson();
  $PlanDefinitionActionCopyWith<PlanDefinitionAction> get copyWith;
}

abstract class $PlanDefinitionActionCopyWith<$Res> {
  factory $PlanDefinitionActionCopyWith(PlanDefinitionAction value,
          $Res Function(PlanDefinitionAction) then) =
      _$PlanDefinitionActionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String prefix,
      String title,
      String description,
      String textEquivalent,
      Code priority,
      List<CodeableConcept> code,
      List<CodeableConcept> reason,
      List<RelatedArtifact> documentation,
      List<Id> goalId,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      List<TriggerDefinition> trigger,
      List<PlanDefinitionCondition> condition,
      List<DataRequirement> input,
      List<DataRequirement> output,
      List<PlanDefinitionRelatedAction> relatedAction,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Duration timingDuration,
      Range timingRange,
      Timing timingTiming,
      List<PlanDefinitionParticipant> participant,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
          ActionGroupingBehavior groupingBehavior,
      @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
          ActionSelectionBehavior selectionBehavior,
      @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
          ActionRequiredBehavior requiredBehavior,
      @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
          ActionPrecheckBehavior precheckBehavior,
      @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
          ActionCardinalityBehavior cardinalityBehavior,
      Canonical definitionCanonical,
      FhirUri definitionUri,
      Canonical transform,
      List<PlanDefinitionDynamicValue> dynamicValue,
      List<PlanDefinitionAction> action});

  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $AgeCopyWith<$Res> get timingAge;
  $PeriodCopyWith<$Res> get timingPeriod;
  $DurationCopyWith<$Res> get timingDuration;
  $RangeCopyWith<$Res> get timingRange;
  $TimingCopyWith<$Res> get timingTiming;
  $CodeableConceptCopyWith<$Res> get type;
}

class _$PlanDefinitionActionCopyWithImpl<$Res>
    implements $PlanDefinitionActionCopyWith<$Res> {
  _$PlanDefinitionActionCopyWithImpl(this._value, this._then);

  final PlanDefinitionAction _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionAction) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object prefix = freezed,
    Object title = freezed,
    Object description = freezed,
    Object textEquivalent = freezed,
    Object priority = freezed,
    Object code = freezed,
    Object reason = freezed,
    Object documentation = freezed,
    Object goalId = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object trigger = freezed,
    Object condition = freezed,
    Object input = freezed,
    Object output = freezed,
    Object relatedAction = freezed,
    Object timingDateTime = freezed,
    Object timingAge = freezed,
    Object timingPeriod = freezed,
    Object timingDuration = freezed,
    Object timingRange = freezed,
    Object timingTiming = freezed,
    Object participant = freezed,
    Object type = freezed,
    Object groupingBehavior = freezed,
    Object selectionBehavior = freezed,
    Object requiredBehavior = freezed,
    Object precheckBehavior = freezed,
    Object cardinalityBehavior = freezed,
    Object definitionCanonical = freezed,
    Object definitionUri = freezed,
    Object transform = freezed,
    Object dynamicValue = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      prefix: prefix == freezed ? _value.prefix : prefix as String,
      title: title == freezed ? _value.title : title as String,
      description:
          description == freezed ? _value.description : description as String,
      textEquivalent: textEquivalent == freezed
          ? _value.textEquivalent
          : textEquivalent as String,
      priority: priority == freezed ? _value.priority : priority as Code,
      code: code == freezed ? _value.code : code as List<CodeableConcept>,
      reason:
          reason == freezed ? _value.reason : reason as List<CodeableConcept>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as List<RelatedArtifact>,
      goalId: goalId == freezed ? _value.goalId : goalId as List<Id>,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger as List<TriggerDefinition>,
      condition: condition == freezed
          ? _value.condition
          : condition as List<PlanDefinitionCondition>,
      input: input == freezed ? _value.input : input as List<DataRequirement>,
      output:
          output == freezed ? _value.output : output as List<DataRequirement>,
      relatedAction: relatedAction == freezed
          ? _value.relatedAction
          : relatedAction as List<PlanDefinitionRelatedAction>,
      timingDateTime: timingDateTime == freezed
          ? _value.timingDateTime
          : timingDateTime as FhirDateTime,
      timingAge: timingAge == freezed ? _value.timingAge : timingAge as Age,
      timingPeriod: timingPeriod == freezed
          ? _value.timingPeriod
          : timingPeriod as Period,
      timingDuration: timingDuration == freezed
          ? _value.timingDuration
          : timingDuration as Duration,
      timingRange:
          timingRange == freezed ? _value.timingRange : timingRange as Range,
      timingTiming: timingTiming == freezed
          ? _value.timingTiming
          : timingTiming as Timing,
      participant: participant == freezed
          ? _value.participant
          : participant as List<PlanDefinitionParticipant>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      groupingBehavior: groupingBehavior == freezed
          ? _value.groupingBehavior
          : groupingBehavior as ActionGroupingBehavior,
      selectionBehavior: selectionBehavior == freezed
          ? _value.selectionBehavior
          : selectionBehavior as ActionSelectionBehavior,
      requiredBehavior: requiredBehavior == freezed
          ? _value.requiredBehavior
          : requiredBehavior as ActionRequiredBehavior,
      precheckBehavior: precheckBehavior == freezed
          ? _value.precheckBehavior
          : precheckBehavior as ActionPrecheckBehavior,
      cardinalityBehavior: cardinalityBehavior == freezed
          ? _value.cardinalityBehavior
          : cardinalityBehavior as ActionCardinalityBehavior,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionUri: definitionUri == freezed
          ? _value.definitionUri
          : definitionUri as FhirUri,
      transform:
          transform == freezed ? _value.transform : transform as Canonical,
      dynamicValue: dynamicValue == freezed
          ? _value.dynamicValue
          : dynamicValue as List<PlanDefinitionDynamicValue>,
      action: action == freezed
          ? _value.action
          : action as List<PlanDefinitionAction>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $AgeCopyWith<$Res> get timingAge {
    if (_value.timingAge == null) {
      return null;
    }
    return $AgeCopyWith<$Res>(_value.timingAge, (value) {
      return _then(_value.copyWith(timingAge: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get timingPeriod {
    if (_value.timingPeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.timingPeriod, (value) {
      return _then(_value.copyWith(timingPeriod: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get timingDuration {
    if (_value.timingDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.timingDuration, (value) {
      return _then(_value.copyWith(timingDuration: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get timingRange {
    if (_value.timingRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.timingRange, (value) {
      return _then(_value.copyWith(timingRange: value));
    });
  }

  @override
  $TimingCopyWith<$Res> get timingTiming {
    if (_value.timingTiming == null) {
      return null;
    }
    return $TimingCopyWith<$Res>(_value.timingTiming, (value) {
      return _then(_value.copyWith(timingTiming: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$PlanDefinitionActionCopyWith<$Res>
    implements $PlanDefinitionActionCopyWith<$Res> {
  factory _$PlanDefinitionActionCopyWith(_PlanDefinitionAction value,
          $Res Function(_PlanDefinitionAction) then) =
      __$PlanDefinitionActionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String prefix,
      String title,
      String description,
      String textEquivalent,
      Code priority,
      List<CodeableConcept> code,
      List<CodeableConcept> reason,
      List<RelatedArtifact> documentation,
      List<Id> goalId,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      List<TriggerDefinition> trigger,
      List<PlanDefinitionCondition> condition,
      List<DataRequirement> input,
      List<DataRequirement> output,
      List<PlanDefinitionRelatedAction> relatedAction,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Duration timingDuration,
      Range timingRange,
      Timing timingTiming,
      List<PlanDefinitionParticipant> participant,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
          ActionGroupingBehavior groupingBehavior,
      @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
          ActionSelectionBehavior selectionBehavior,
      @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
          ActionRequiredBehavior requiredBehavior,
      @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
          ActionPrecheckBehavior precheckBehavior,
      @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
          ActionCardinalityBehavior cardinalityBehavior,
      Canonical definitionCanonical,
      FhirUri definitionUri,
      Canonical transform,
      List<PlanDefinitionDynamicValue> dynamicValue,
      List<PlanDefinitionAction> action});

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $AgeCopyWith<$Res> get timingAge;
  @override
  $PeriodCopyWith<$Res> get timingPeriod;
  @override
  $DurationCopyWith<$Res> get timingDuration;
  @override
  $RangeCopyWith<$Res> get timingRange;
  @override
  $TimingCopyWith<$Res> get timingTiming;
  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$PlanDefinitionActionCopyWithImpl<$Res>
    extends _$PlanDefinitionActionCopyWithImpl<$Res>
    implements _$PlanDefinitionActionCopyWith<$Res> {
  __$PlanDefinitionActionCopyWithImpl(
      _PlanDefinitionAction _value, $Res Function(_PlanDefinitionAction) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionAction));

  @override
  _PlanDefinitionAction get _value => super._value as _PlanDefinitionAction;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object prefix = freezed,
    Object title = freezed,
    Object description = freezed,
    Object textEquivalent = freezed,
    Object priority = freezed,
    Object code = freezed,
    Object reason = freezed,
    Object documentation = freezed,
    Object goalId = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object trigger = freezed,
    Object condition = freezed,
    Object input = freezed,
    Object output = freezed,
    Object relatedAction = freezed,
    Object timingDateTime = freezed,
    Object timingAge = freezed,
    Object timingPeriod = freezed,
    Object timingDuration = freezed,
    Object timingRange = freezed,
    Object timingTiming = freezed,
    Object participant = freezed,
    Object type = freezed,
    Object groupingBehavior = freezed,
    Object selectionBehavior = freezed,
    Object requiredBehavior = freezed,
    Object precheckBehavior = freezed,
    Object cardinalityBehavior = freezed,
    Object definitionCanonical = freezed,
    Object definitionUri = freezed,
    Object transform = freezed,
    Object dynamicValue = freezed,
    Object action = freezed,
  }) {
    return _then(_PlanDefinitionAction(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      prefix: prefix == freezed ? _value.prefix : prefix as String,
      title: title == freezed ? _value.title : title as String,
      description:
          description == freezed ? _value.description : description as String,
      textEquivalent: textEquivalent == freezed
          ? _value.textEquivalent
          : textEquivalent as String,
      priority: priority == freezed ? _value.priority : priority as Code,
      code: code == freezed ? _value.code : code as List<CodeableConcept>,
      reason:
          reason == freezed ? _value.reason : reason as List<CodeableConcept>,
      documentation: documentation == freezed
          ? _value.documentation
          : documentation as List<RelatedArtifact>,
      goalId: goalId == freezed ? _value.goalId : goalId as List<Id>,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      trigger: trigger == freezed
          ? _value.trigger
          : trigger as List<TriggerDefinition>,
      condition: condition == freezed
          ? _value.condition
          : condition as List<PlanDefinitionCondition>,
      input: input == freezed ? _value.input : input as List<DataRequirement>,
      output:
          output == freezed ? _value.output : output as List<DataRequirement>,
      relatedAction: relatedAction == freezed
          ? _value.relatedAction
          : relatedAction as List<PlanDefinitionRelatedAction>,
      timingDateTime: timingDateTime == freezed
          ? _value.timingDateTime
          : timingDateTime as FhirDateTime,
      timingAge: timingAge == freezed ? _value.timingAge : timingAge as Age,
      timingPeriod: timingPeriod == freezed
          ? _value.timingPeriod
          : timingPeriod as Period,
      timingDuration: timingDuration == freezed
          ? _value.timingDuration
          : timingDuration as Duration,
      timingRange:
          timingRange == freezed ? _value.timingRange : timingRange as Range,
      timingTiming: timingTiming == freezed
          ? _value.timingTiming
          : timingTiming as Timing,
      participant: participant == freezed
          ? _value.participant
          : participant as List<PlanDefinitionParticipant>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      groupingBehavior: groupingBehavior == freezed
          ? _value.groupingBehavior
          : groupingBehavior as ActionGroupingBehavior,
      selectionBehavior: selectionBehavior == freezed
          ? _value.selectionBehavior
          : selectionBehavior as ActionSelectionBehavior,
      requiredBehavior: requiredBehavior == freezed
          ? _value.requiredBehavior
          : requiredBehavior as ActionRequiredBehavior,
      precheckBehavior: precheckBehavior == freezed
          ? _value.precheckBehavior
          : precheckBehavior as ActionPrecheckBehavior,
      cardinalityBehavior: cardinalityBehavior == freezed
          ? _value.cardinalityBehavior
          : cardinalityBehavior as ActionCardinalityBehavior,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionUri: definitionUri == freezed
          ? _value.definitionUri
          : definitionUri as FhirUri,
      transform:
          transform == freezed ? _value.transform : transform as Canonical,
      dynamicValue: dynamicValue == freezed
          ? _value.dynamicValue
          : dynamicValue as List<PlanDefinitionDynamicValue>,
      action: action == freezed
          ? _value.action
          : action as List<PlanDefinitionAction>,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionAction implements _PlanDefinitionAction {
  const _$_PlanDefinitionAction(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.prefix,
      this.title,
      this.description,
      this.textEquivalent,
      this.priority,
      this.code,
      this.reason,
      this.documentation,
      this.goalId,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.trigger,
      this.condition,
      this.input,
      this.output,
      this.relatedAction,
      this.timingDateTime,
      this.timingAge,
      this.timingPeriod,
      this.timingDuration,
      this.timingRange,
      this.timingTiming,
      this.participant,
      this.type,
      @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
          this.groupingBehavior,
      @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
          this.selectionBehavior,
      @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
          this.requiredBehavior,
      @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
          this.precheckBehavior,
      @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
          this.cardinalityBehavior,
      this.definitionCanonical,
      this.definitionUri,
      this.transform,
      this.dynamicValue,
      this.action});

  factory _$_PlanDefinitionAction.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionActionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String prefix;
  @override
  final String title;
  @override
  final String description;
  @override
  final String textEquivalent;
  @override
  final Code priority;
  @override
  final List<CodeableConcept> code;
  @override
  final List<CodeableConcept> reason;
  @override
  final List<RelatedArtifact> documentation;
  @override
  final List<Id> goalId;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final List<TriggerDefinition> trigger;
  @override
  final List<PlanDefinitionCondition> condition;
  @override
  final List<DataRequirement> input;
  @override
  final List<DataRequirement> output;
  @override
  final List<PlanDefinitionRelatedAction> relatedAction;
  @override
  final FhirDateTime timingDateTime;
  @override
  final Age timingAge;
  @override
  final Period timingPeriod;
  @override
  final Duration timingDuration;
  @override
  final Range timingRange;
  @override
  final Timing timingTiming;
  @override
  final List<PlanDefinitionParticipant> participant;
  @override
  final CodeableConcept type;
  @override
  @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
  final ActionGroupingBehavior groupingBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
  final ActionSelectionBehavior selectionBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
  final ActionRequiredBehavior requiredBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
  final ActionPrecheckBehavior precheckBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
  final ActionCardinalityBehavior cardinalityBehavior;
  @override
  final Canonical definitionCanonical;
  @override
  final FhirUri definitionUri;
  @override
  final Canonical transform;
  @override
  final List<PlanDefinitionDynamicValue> dynamicValue;
  @override
  final List<PlanDefinitionAction> action;

  @override
  String toString() {
    return 'PlanDefinitionAction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, prefix: $prefix, title: $title, description: $description, textEquivalent: $textEquivalent, priority: $priority, code: $code, reason: $reason, documentation: $documentation, goalId: $goalId, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, trigger: $trigger, condition: $condition, input: $input, output: $output, relatedAction: $relatedAction, timingDateTime: $timingDateTime, timingAge: $timingAge, timingPeriod: $timingPeriod, timingDuration: $timingDuration, timingRange: $timingRange, timingTiming: $timingTiming, participant: $participant, type: $type, groupingBehavior: $groupingBehavior, selectionBehavior: $selectionBehavior, requiredBehavior: $requiredBehavior, precheckBehavior: $precheckBehavior, cardinalityBehavior: $cardinalityBehavior, definitionCanonical: $definitionCanonical, definitionUri: $definitionUri, transform: $transform, dynamicValue: $dynamicValue, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionAction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.textEquivalent, textEquivalent) ||
                const DeepCollectionEquality()
                    .equals(other.textEquivalent, textEquivalent)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.documentation, documentation) ||
                const DeepCollectionEquality()
                    .equals(other.documentation, documentation)) &&
            (identical(other.goalId, goalId) ||
                const DeepCollectionEquality().equals(other.goalId, goalId)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.trigger, trigger) ||
                const DeepCollectionEquality()
                    .equals(other.trigger, trigger)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)) &&
            (identical(other.output, output) ||
                const DeepCollectionEquality().equals(other.output, output)) &&
            (identical(other.relatedAction, relatedAction) ||
                const DeepCollectionEquality()
                    .equals(other.relatedAction, relatedAction)) &&
            (identical(other.timingDateTime, timingDateTime) ||
                const DeepCollectionEquality()
                    .equals(other.timingDateTime, timingDateTime)) &&
            (identical(other.timingAge, timingAge) ||
                const DeepCollectionEquality()
                    .equals(other.timingAge, timingAge)) &&
            (identical(other.timingPeriod, timingPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.timingPeriod, timingPeriod)) &&
            (identical(other.timingDuration, timingDuration) ||
                const DeepCollectionEquality()
                    .equals(other.timingDuration, timingDuration)) &&
            (identical(other.timingRange, timingRange) ||
                const DeepCollectionEquality()
                    .equals(other.timingRange, timingRange)) &&
            (identical(other.timingTiming, timingTiming) ||
                const DeepCollectionEquality()
                    .equals(other.timingTiming, timingTiming)) &&
            (identical(other.participant, participant) || const DeepCollectionEquality().equals(other.participant, participant)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.groupingBehavior, groupingBehavior) || const DeepCollectionEquality().equals(other.groupingBehavior, groupingBehavior)) &&
            (identical(other.selectionBehavior, selectionBehavior) || const DeepCollectionEquality().equals(other.selectionBehavior, selectionBehavior)) &&
            (identical(other.requiredBehavior, requiredBehavior) || const DeepCollectionEquality().equals(other.requiredBehavior, requiredBehavior)) &&
            (identical(other.precheckBehavior, precheckBehavior) || const DeepCollectionEquality().equals(other.precheckBehavior, precheckBehavior)) &&
            (identical(other.cardinalityBehavior, cardinalityBehavior) || const DeepCollectionEquality().equals(other.cardinalityBehavior, cardinalityBehavior)) &&
            (identical(other.definitionCanonical, definitionCanonical) || const DeepCollectionEquality().equals(other.definitionCanonical, definitionCanonical)) &&
            (identical(other.definitionUri, definitionUri) || const DeepCollectionEquality().equals(other.definitionUri, definitionUri)) &&
            (identical(other.transform, transform) || const DeepCollectionEquality().equals(other.transform, transform)) &&
            (identical(other.dynamicValue, dynamicValue) || const DeepCollectionEquality().equals(other.dynamicValue, dynamicValue)) &&
            (identical(other.action, action) || const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(textEquivalent) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(documentation) ^
      const DeepCollectionEquality().hash(goalId) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(trigger) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash(input) ^
      const DeepCollectionEquality().hash(output) ^
      const DeepCollectionEquality().hash(relatedAction) ^
      const DeepCollectionEquality().hash(timingDateTime) ^
      const DeepCollectionEquality().hash(timingAge) ^
      const DeepCollectionEquality().hash(timingPeriod) ^
      const DeepCollectionEquality().hash(timingDuration) ^
      const DeepCollectionEquality().hash(timingRange) ^
      const DeepCollectionEquality().hash(timingTiming) ^
      const DeepCollectionEquality().hash(participant) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(groupingBehavior) ^
      const DeepCollectionEquality().hash(selectionBehavior) ^
      const DeepCollectionEquality().hash(requiredBehavior) ^
      const DeepCollectionEquality().hash(precheckBehavior) ^
      const DeepCollectionEquality().hash(cardinalityBehavior) ^
      const DeepCollectionEquality().hash(definitionCanonical) ^
      const DeepCollectionEquality().hash(definitionUri) ^
      const DeepCollectionEquality().hash(transform) ^
      const DeepCollectionEquality().hash(dynamicValue) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$PlanDefinitionActionCopyWith<_PlanDefinitionAction> get copyWith =>
      __$PlanDefinitionActionCopyWithImpl<_PlanDefinitionAction>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionActionToJson(this);
  }
}

abstract class _PlanDefinitionAction implements PlanDefinitionAction {
  const factory _PlanDefinitionAction(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String prefix,
      String title,
      String description,
      String textEquivalent,
      Code priority,
      List<CodeableConcept> code,
      List<CodeableConcept> reason,
      List<RelatedArtifact> documentation,
      List<Id> goalId,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      List<TriggerDefinition> trigger,
      List<PlanDefinitionCondition> condition,
      List<DataRequirement> input,
      List<DataRequirement> output,
      List<PlanDefinitionRelatedAction> relatedAction,
      FhirDateTime timingDateTime,
      Age timingAge,
      Period timingPeriod,
      Duration timingDuration,
      Range timingRange,
      Timing timingTiming,
      List<PlanDefinitionParticipant> participant,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
          ActionGroupingBehavior groupingBehavior,
      @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
          ActionSelectionBehavior selectionBehavior,
      @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
          ActionRequiredBehavior requiredBehavior,
      @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
          ActionPrecheckBehavior precheckBehavior,
      @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
          ActionCardinalityBehavior cardinalityBehavior,
      Canonical definitionCanonical,
      FhirUri definitionUri,
      Canonical transform,
      List<PlanDefinitionDynamicValue> dynamicValue,
      List<PlanDefinitionAction> action}) = _$_PlanDefinitionAction;

  factory _PlanDefinitionAction.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionAction.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get prefix;
  @override
  String get title;
  @override
  String get description;
  @override
  String get textEquivalent;
  @override
  Code get priority;
  @override
  List<CodeableConcept> get code;
  @override
  List<CodeableConcept> get reason;
  @override
  List<RelatedArtifact> get documentation;
  @override
  List<Id> get goalId;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  List<TriggerDefinition> get trigger;
  @override
  List<PlanDefinitionCondition> get condition;
  @override
  List<DataRequirement> get input;
  @override
  List<DataRequirement> get output;
  @override
  List<PlanDefinitionRelatedAction> get relatedAction;
  @override
  FhirDateTime get timingDateTime;
  @override
  Age get timingAge;
  @override
  Period get timingPeriod;
  @override
  Duration get timingDuration;
  @override
  Range get timingRange;
  @override
  Timing get timingTiming;
  @override
  List<PlanDefinitionParticipant> get participant;
  @override
  CodeableConcept get type;
  @override
  @JsonKey(unknownEnumValue: ActionGroupingBehavior.unknown)
  ActionGroupingBehavior get groupingBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionSelectionBehavior.unknown)
  ActionSelectionBehavior get selectionBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionRequiredBehavior.unknown)
  ActionRequiredBehavior get requiredBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionPrecheckBehavior.unknown)
  ActionPrecheckBehavior get precheckBehavior;
  @override
  @JsonKey(unknownEnumValue: ActionCardinalityBehavior.unknown)
  ActionCardinalityBehavior get cardinalityBehavior;
  @override
  Canonical get definitionCanonical;
  @override
  FhirUri get definitionUri;
  @override
  Canonical get transform;
  @override
  List<PlanDefinitionDynamicValue> get dynamicValue;
  @override
  List<PlanDefinitionAction> get action;
  @override
  _$PlanDefinitionActionCopyWith<_PlanDefinitionAction> get copyWith;
}

PlanDefinitionCondition _$PlanDefinitionConditionFromJson(
    Map<String, dynamic> json) {
  return _PlanDefinitionCondition.fromJson(json);
}

class _$PlanDefinitionConditionTearOff {
  const _$PlanDefinitionConditionTearOff();

  _PlanDefinitionCondition call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: ConditionKind.unknown) ConditionKind kind,
      Expression expression}) {
    return _PlanDefinitionCondition(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      kind: kind,
      expression: expression,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionCondition = _$PlanDefinitionConditionTearOff();

mixin _$PlanDefinitionCondition {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: ConditionKind.unknown)
  ConditionKind get kind;
  Expression get expression;

  Map<String, dynamic> toJson();
  $PlanDefinitionConditionCopyWith<PlanDefinitionCondition> get copyWith;
}

abstract class $PlanDefinitionConditionCopyWith<$Res> {
  factory $PlanDefinitionConditionCopyWith(PlanDefinitionCondition value,
          $Res Function(PlanDefinitionCondition) then) =
      _$PlanDefinitionConditionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: ConditionKind.unknown) ConditionKind kind,
      Expression expression});

  $ExpressionCopyWith<$Res> get expression;
}

class _$PlanDefinitionConditionCopyWithImpl<$Res>
    implements $PlanDefinitionConditionCopyWith<$Res> {
  _$PlanDefinitionConditionCopyWithImpl(this._value, this._then);

  final PlanDefinitionCondition _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionCondition) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object kind = freezed,
    Object expression = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      kind: kind == freezed ? _value.kind : kind as ConditionKind,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }

  @override
  $ExpressionCopyWith<$Res> get expression {
    if (_value.expression == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.expression, (value) {
      return _then(_value.copyWith(expression: value));
    });
  }
}

abstract class _$PlanDefinitionConditionCopyWith<$Res>
    implements $PlanDefinitionConditionCopyWith<$Res> {
  factory _$PlanDefinitionConditionCopyWith(_PlanDefinitionCondition value,
          $Res Function(_PlanDefinitionCondition) then) =
      __$PlanDefinitionConditionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: ConditionKind.unknown) ConditionKind kind,
      Expression expression});

  @override
  $ExpressionCopyWith<$Res> get expression;
}

class __$PlanDefinitionConditionCopyWithImpl<$Res>
    extends _$PlanDefinitionConditionCopyWithImpl<$Res>
    implements _$PlanDefinitionConditionCopyWith<$Res> {
  __$PlanDefinitionConditionCopyWithImpl(_PlanDefinitionCondition _value,
      $Res Function(_PlanDefinitionCondition) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionCondition));

  @override
  _PlanDefinitionCondition get _value =>
      super._value as _PlanDefinitionCondition;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object kind = freezed,
    Object expression = freezed,
  }) {
    return _then(_PlanDefinitionCondition(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      kind: kind == freezed ? _value.kind : kind as ConditionKind,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionCondition implements _PlanDefinitionCondition {
  const _$_PlanDefinitionCondition(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: ConditionKind.unknown) this.kind,
      this.expression});

  factory _$_PlanDefinitionCondition.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionConditionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: ConditionKind.unknown)
  final ConditionKind kind;
  @override
  final Expression expression;

  @override
  String toString() {
    return 'PlanDefinitionCondition(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, kind: $kind, expression: $expression)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionCondition &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.kind, kind) ||
                const DeepCollectionEquality().equals(other.kind, kind)) &&
            (identical(other.expression, expression) ||
                const DeepCollectionEquality()
                    .equals(other.expression, expression)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(kind) ^
      const DeepCollectionEquality().hash(expression);

  @override
  _$PlanDefinitionConditionCopyWith<_PlanDefinitionCondition> get copyWith =>
      __$PlanDefinitionConditionCopyWithImpl<_PlanDefinitionCondition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionConditionToJson(this);
  }
}

abstract class _PlanDefinitionCondition implements PlanDefinitionCondition {
  const factory _PlanDefinitionCondition(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: ConditionKind.unknown) ConditionKind kind,
      Expression expression}) = _$_PlanDefinitionCondition;

  factory _PlanDefinitionCondition.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionCondition.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: ConditionKind.unknown)
  ConditionKind get kind;
  @override
  Expression get expression;
  @override
  _$PlanDefinitionConditionCopyWith<_PlanDefinitionCondition> get copyWith;
}

PlanDefinitionRelatedAction _$PlanDefinitionRelatedActionFromJson(
    Map<String, dynamic> json) {
  return _PlanDefinitionRelatedAction.fromJson(json);
}

class _$PlanDefinitionRelatedActionTearOff {
  const _$PlanDefinitionRelatedActionTearOff();

  _PlanDefinitionRelatedAction call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Id actionId,
      @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
          RelatedActionRelationship relationship,
      Duration offsetDuration,
      Range offsetRange}) {
    return _PlanDefinitionRelatedAction(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      actionId: actionId,
      relationship: relationship,
      offsetDuration: offsetDuration,
      offsetRange: offsetRange,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionRelatedAction = _$PlanDefinitionRelatedActionTearOff();

mixin _$PlanDefinitionRelatedAction {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Id get actionId;
  @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
  RelatedActionRelationship get relationship;
  Duration get offsetDuration;
  Range get offsetRange;

  Map<String, dynamic> toJson();
  $PlanDefinitionRelatedActionCopyWith<PlanDefinitionRelatedAction>
      get copyWith;
}

abstract class $PlanDefinitionRelatedActionCopyWith<$Res> {
  factory $PlanDefinitionRelatedActionCopyWith(
          PlanDefinitionRelatedAction value,
          $Res Function(PlanDefinitionRelatedAction) then) =
      _$PlanDefinitionRelatedActionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Id actionId,
      @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
          RelatedActionRelationship relationship,
      Duration offsetDuration,
      Range offsetRange});

  $DurationCopyWith<$Res> get offsetDuration;
  $RangeCopyWith<$Res> get offsetRange;
}

class _$PlanDefinitionRelatedActionCopyWithImpl<$Res>
    implements $PlanDefinitionRelatedActionCopyWith<$Res> {
  _$PlanDefinitionRelatedActionCopyWithImpl(this._value, this._then);

  final PlanDefinitionRelatedAction _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionRelatedAction) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object actionId = freezed,
    Object relationship = freezed,
    Object offsetDuration = freezed,
    Object offsetRange = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      actionId: actionId == freezed ? _value.actionId : actionId as Id,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as RelatedActionRelationship,
      offsetDuration: offsetDuration == freezed
          ? _value.offsetDuration
          : offsetDuration as Duration,
      offsetRange:
          offsetRange == freezed ? _value.offsetRange : offsetRange as Range,
    ));
  }

  @override
  $DurationCopyWith<$Res> get offsetDuration {
    if (_value.offsetDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.offsetDuration, (value) {
      return _then(_value.copyWith(offsetDuration: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get offsetRange {
    if (_value.offsetRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.offsetRange, (value) {
      return _then(_value.copyWith(offsetRange: value));
    });
  }
}

abstract class _$PlanDefinitionRelatedActionCopyWith<$Res>
    implements $PlanDefinitionRelatedActionCopyWith<$Res> {
  factory _$PlanDefinitionRelatedActionCopyWith(
          _PlanDefinitionRelatedAction value,
          $Res Function(_PlanDefinitionRelatedAction) then) =
      __$PlanDefinitionRelatedActionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Id actionId,
      @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
          RelatedActionRelationship relationship,
      Duration offsetDuration,
      Range offsetRange});

  @override
  $DurationCopyWith<$Res> get offsetDuration;
  @override
  $RangeCopyWith<$Res> get offsetRange;
}

class __$PlanDefinitionRelatedActionCopyWithImpl<$Res>
    extends _$PlanDefinitionRelatedActionCopyWithImpl<$Res>
    implements _$PlanDefinitionRelatedActionCopyWith<$Res> {
  __$PlanDefinitionRelatedActionCopyWithImpl(
      _PlanDefinitionRelatedAction _value,
      $Res Function(_PlanDefinitionRelatedAction) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionRelatedAction));

  @override
  _PlanDefinitionRelatedAction get _value =>
      super._value as _PlanDefinitionRelatedAction;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object actionId = freezed,
    Object relationship = freezed,
    Object offsetDuration = freezed,
    Object offsetRange = freezed,
  }) {
    return _then(_PlanDefinitionRelatedAction(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      actionId: actionId == freezed ? _value.actionId : actionId as Id,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as RelatedActionRelationship,
      offsetDuration: offsetDuration == freezed
          ? _value.offsetDuration
          : offsetDuration as Duration,
      offsetRange:
          offsetRange == freezed ? _value.offsetRange : offsetRange as Range,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionRelatedAction implements _PlanDefinitionRelatedAction {
  const _$_PlanDefinitionRelatedAction(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.actionId,
      @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
          this.relationship,
      this.offsetDuration,
      this.offsetRange});

  factory _$_PlanDefinitionRelatedAction.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionRelatedActionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Id actionId;
  @override
  @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
  final RelatedActionRelationship relationship;
  @override
  final Duration offsetDuration;
  @override
  final Range offsetRange;

  @override
  String toString() {
    return 'PlanDefinitionRelatedAction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, actionId: $actionId, relationship: $relationship, offsetDuration: $offsetDuration, offsetRange: $offsetRange)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionRelatedAction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.actionId, actionId) ||
                const DeepCollectionEquality()
                    .equals(other.actionId, actionId)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.offsetDuration, offsetDuration) ||
                const DeepCollectionEquality()
                    .equals(other.offsetDuration, offsetDuration)) &&
            (identical(other.offsetRange, offsetRange) ||
                const DeepCollectionEquality()
                    .equals(other.offsetRange, offsetRange)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(actionId) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(offsetDuration) ^
      const DeepCollectionEquality().hash(offsetRange);

  @override
  _$PlanDefinitionRelatedActionCopyWith<_PlanDefinitionRelatedAction>
      get copyWith => __$PlanDefinitionRelatedActionCopyWithImpl<
          _PlanDefinitionRelatedAction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionRelatedActionToJson(this);
  }
}

abstract class _PlanDefinitionRelatedAction
    implements PlanDefinitionRelatedAction {
  const factory _PlanDefinitionRelatedAction(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Id actionId,
      @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
          RelatedActionRelationship relationship,
      Duration offsetDuration,
      Range offsetRange}) = _$_PlanDefinitionRelatedAction;

  factory _PlanDefinitionRelatedAction.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionRelatedAction.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Id get actionId;
  @override
  @JsonKey(unknownEnumValue: RelatedActionRelationship.unknown)
  RelatedActionRelationship get relationship;
  @override
  Duration get offsetDuration;
  @override
  Range get offsetRange;
  @override
  _$PlanDefinitionRelatedActionCopyWith<_PlanDefinitionRelatedAction>
      get copyWith;
}

PlanDefinitionParticipant _$PlanDefinitionParticipantFromJson(
    Map<String, dynamic> json) {
  return _PlanDefinitionParticipant.fromJson(json);
}

class _$PlanDefinitionParticipantTearOff {
  const _$PlanDefinitionParticipantTearOff();

  _PlanDefinitionParticipant call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
          PlanDefinitionParticipantType type,
      CodeableConcept role}) {
    return _PlanDefinitionParticipant(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      role: role,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionParticipant = _$PlanDefinitionParticipantTearOff();

mixin _$PlanDefinitionParticipant {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
  PlanDefinitionParticipantType get type;
  CodeableConcept get role;

  Map<String, dynamic> toJson();
  $PlanDefinitionParticipantCopyWith<PlanDefinitionParticipant> get copyWith;
}

abstract class $PlanDefinitionParticipantCopyWith<$Res> {
  factory $PlanDefinitionParticipantCopyWith(PlanDefinitionParticipant value,
          $Res Function(PlanDefinitionParticipant) then) =
      _$PlanDefinitionParticipantCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
          PlanDefinitionParticipantType type,
      CodeableConcept role});

  $CodeableConceptCopyWith<$Res> get role;
}

class _$PlanDefinitionParticipantCopyWithImpl<$Res>
    implements $PlanDefinitionParticipantCopyWith<$Res> {
  _$PlanDefinitionParticipantCopyWithImpl(this._value, this._then);

  final PlanDefinitionParticipant _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionParticipant) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object role = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type:
          type == freezed ? _value.type : type as PlanDefinitionParticipantType,
      role: role == freezed ? _value.role : role as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get role {
    if (_value.role == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value));
    });
  }
}

abstract class _$PlanDefinitionParticipantCopyWith<$Res>
    implements $PlanDefinitionParticipantCopyWith<$Res> {
  factory _$PlanDefinitionParticipantCopyWith(_PlanDefinitionParticipant value,
          $Res Function(_PlanDefinitionParticipant) then) =
      __$PlanDefinitionParticipantCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
          PlanDefinitionParticipantType type,
      CodeableConcept role});

  @override
  $CodeableConceptCopyWith<$Res> get role;
}

class __$PlanDefinitionParticipantCopyWithImpl<$Res>
    extends _$PlanDefinitionParticipantCopyWithImpl<$Res>
    implements _$PlanDefinitionParticipantCopyWith<$Res> {
  __$PlanDefinitionParticipantCopyWithImpl(_PlanDefinitionParticipant _value,
      $Res Function(_PlanDefinitionParticipant) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionParticipant));

  @override
  _PlanDefinitionParticipant get _value =>
      super._value as _PlanDefinitionParticipant;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object role = freezed,
  }) {
    return _then(_PlanDefinitionParticipant(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type:
          type == freezed ? _value.type : type as PlanDefinitionParticipantType,
      role: role == freezed ? _value.role : role as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionParticipant implements _PlanDefinitionParticipant {
  const _$_PlanDefinitionParticipant(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
          this.type,
      this.role});

  factory _$_PlanDefinitionParticipant.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionParticipantFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
  final PlanDefinitionParticipantType type;
  @override
  final CodeableConcept role;

  @override
  String toString() {
    return 'PlanDefinitionParticipant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, role: $role)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionParticipant &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(role);

  @override
  _$PlanDefinitionParticipantCopyWith<_PlanDefinitionParticipant>
      get copyWith =>
          __$PlanDefinitionParticipantCopyWithImpl<_PlanDefinitionParticipant>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionParticipantToJson(this);
  }
}

abstract class _PlanDefinitionParticipant implements PlanDefinitionParticipant {
  const factory _PlanDefinitionParticipant(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
          PlanDefinitionParticipantType type,
      CodeableConcept role}) = _$_PlanDefinitionParticipant;

  factory _PlanDefinitionParticipant.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionParticipant.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: PlanDefinitionParticipantType.unknown)
  PlanDefinitionParticipantType get type;
  @override
  CodeableConcept get role;
  @override
  _$PlanDefinitionParticipantCopyWith<_PlanDefinitionParticipant> get copyWith;
}

PlanDefinitionDynamicValue _$PlanDefinitionDynamicValueFromJson(
    Map<String, dynamic> json) {
  return _PlanDefinitionDynamicValue.fromJson(json);
}

class _$PlanDefinitionDynamicValueTearOff {
  const _$PlanDefinitionDynamicValueTearOff();

  _PlanDefinitionDynamicValue call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      Expression expression}) {
    return _PlanDefinitionDynamicValue(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      path: path,
      expression: expression,
    );
  }
}

// ignore: unused_element
const $PlanDefinitionDynamicValue = _$PlanDefinitionDynamicValueTearOff();

mixin _$PlanDefinitionDynamicValue {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get path;
  Expression get expression;

  Map<String, dynamic> toJson();
  $PlanDefinitionDynamicValueCopyWith<PlanDefinitionDynamicValue> get copyWith;
}

abstract class $PlanDefinitionDynamicValueCopyWith<$Res> {
  factory $PlanDefinitionDynamicValueCopyWith(PlanDefinitionDynamicValue value,
          $Res Function(PlanDefinitionDynamicValue) then) =
      _$PlanDefinitionDynamicValueCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      Expression expression});

  $ExpressionCopyWith<$Res> get expression;
}

class _$PlanDefinitionDynamicValueCopyWithImpl<$Res>
    implements $PlanDefinitionDynamicValueCopyWith<$Res> {
  _$PlanDefinitionDynamicValueCopyWithImpl(this._value, this._then);

  final PlanDefinitionDynamicValue _value;
  // ignore: unused_field
  final $Res Function(PlanDefinitionDynamicValue) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object path = freezed,
    Object expression = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      path: path == freezed ? _value.path : path as String,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }

  @override
  $ExpressionCopyWith<$Res> get expression {
    if (_value.expression == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.expression, (value) {
      return _then(_value.copyWith(expression: value));
    });
  }
}

abstract class _$PlanDefinitionDynamicValueCopyWith<$Res>
    implements $PlanDefinitionDynamicValueCopyWith<$Res> {
  factory _$PlanDefinitionDynamicValueCopyWith(
          _PlanDefinitionDynamicValue value,
          $Res Function(_PlanDefinitionDynamicValue) then) =
      __$PlanDefinitionDynamicValueCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      Expression expression});

  @override
  $ExpressionCopyWith<$Res> get expression;
}

class __$PlanDefinitionDynamicValueCopyWithImpl<$Res>
    extends _$PlanDefinitionDynamicValueCopyWithImpl<$Res>
    implements _$PlanDefinitionDynamicValueCopyWith<$Res> {
  __$PlanDefinitionDynamicValueCopyWithImpl(_PlanDefinitionDynamicValue _value,
      $Res Function(_PlanDefinitionDynamicValue) _then)
      : super(_value, (v) => _then(v as _PlanDefinitionDynamicValue));

  @override
  _PlanDefinitionDynamicValue get _value =>
      super._value as _PlanDefinitionDynamicValue;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object path = freezed,
    Object expression = freezed,
  }) {
    return _then(_PlanDefinitionDynamicValue(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      path: path == freezed ? _value.path : path as String,
      expression:
          expression == freezed ? _value.expression : expression as Expression,
    ));
  }
}

@JsonSerializable()
class _$_PlanDefinitionDynamicValue implements _PlanDefinitionDynamicValue {
  const _$_PlanDefinitionDynamicValue(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.path,
      this.expression});

  factory _$_PlanDefinitionDynamicValue.fromJson(Map<String, dynamic> json) =>
      _$_$_PlanDefinitionDynamicValueFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String path;
  @override
  final Expression expression;

  @override
  String toString() {
    return 'PlanDefinitionDynamicValue(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, path: $path, expression: $expression)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PlanDefinitionDynamicValue &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.expression, expression) ||
                const DeepCollectionEquality()
                    .equals(other.expression, expression)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(expression);

  @override
  _$PlanDefinitionDynamicValueCopyWith<_PlanDefinitionDynamicValue>
      get copyWith => __$PlanDefinitionDynamicValueCopyWithImpl<
          _PlanDefinitionDynamicValue>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_PlanDefinitionDynamicValueToJson(this);
  }
}

abstract class _PlanDefinitionDynamicValue
    implements PlanDefinitionDynamicValue {
  const factory _PlanDefinitionDynamicValue(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String path,
      Expression expression}) = _$_PlanDefinitionDynamicValue;

  factory _PlanDefinitionDynamicValue.fromJson(Map<String, dynamic> json) =
      _$_PlanDefinitionDynamicValue.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get path;
  @override
  Expression get expression;
  @override
  _$PlanDefinitionDynamicValueCopyWith<_PlanDefinitionDynamicValue>
      get copyWith;
}

Questionnaire _$QuestionnaireFromJson(Map<String, dynamic> json) {
  return _Questionnaire.fromJson(json);
}

class _$QuestionnaireTearOff {
  const _$QuestionnaireTearOff();

  _Questionnaire call(
      {@required
      @JsonKey(required: true, defaultValue: 'Questionnaire')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      List<Canonical> derivedFrom,
      @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
          QuestionnaireStatus status,
      Boolean experimental,
      List<Code> subjectType,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<Coding> code,
      List<QuestionnaireItem> item}) {
    return _Questionnaire(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      derivedFrom: derivedFrom,
      status: status,
      experimental: experimental,
      subjectType: subjectType,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      code: code,
      item: item,
    );
  }
}

// ignore: unused_element
const $Questionnaire = _$QuestionnaireTearOff();

mixin _$Questionnaire {
  @JsonKey(required: true, defaultValue: 'Questionnaire')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  List<Canonical> get derivedFrom;
  @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
  QuestionnaireStatus get status;
  Boolean get experimental;
  List<Code> get subjectType;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<Coding> get code;
  List<QuestionnaireItem> get item;

  Map<String, dynamic> toJson();
  $QuestionnaireCopyWith<Questionnaire> get copyWith;
}

abstract class $QuestionnaireCopyWith<$Res> {
  factory $QuestionnaireCopyWith(
          Questionnaire value, $Res Function(Questionnaire) then) =
      _$QuestionnaireCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Questionnaire')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      List<Canonical> derivedFrom,
      @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
          QuestionnaireStatus status,
      Boolean experimental,
      List<Code> subjectType,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<Coding> code,
      List<QuestionnaireItem> item});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class _$QuestionnaireCopyWithImpl<$Res>
    implements $QuestionnaireCopyWith<$Res> {
  _$QuestionnaireCopyWithImpl(this._value, this._then);

  final Questionnaire _value;
  // ignore: unused_field
  final $Res Function(Questionnaire) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object derivedFrom = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectType = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object code = freezed,
    Object item = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      derivedFrom: derivedFrom == freezed
          ? _value.derivedFrom
          : derivedFrom as List<Canonical>,
      status: status == freezed ? _value.status : status as QuestionnaireStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectType: subjectType == freezed
          ? _value.subjectType
          : subjectType as List<Code>,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      code: code == freezed ? _value.code : code as List<Coding>,
      item: item == freezed ? _value.item : item as List<QuestionnaireItem>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }
}

abstract class _$QuestionnaireCopyWith<$Res>
    implements $QuestionnaireCopyWith<$Res> {
  factory _$QuestionnaireCopyWith(
          _Questionnaire value, $Res Function(_Questionnaire) then) =
      __$QuestionnaireCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'Questionnaire')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      List<Canonical> derivedFrom,
      @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
          QuestionnaireStatus status,
      Boolean experimental,
      List<Code> subjectType,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<Coding> code,
      List<QuestionnaireItem> item});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class __$QuestionnaireCopyWithImpl<$Res>
    extends _$QuestionnaireCopyWithImpl<$Res>
    implements _$QuestionnaireCopyWith<$Res> {
  __$QuestionnaireCopyWithImpl(
      _Questionnaire _value, $Res Function(_Questionnaire) _then)
      : super(_value, (v) => _then(v as _Questionnaire));

  @override
  _Questionnaire get _value => super._value as _Questionnaire;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object derivedFrom = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectType = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object code = freezed,
    Object item = freezed,
  }) {
    return _then(_Questionnaire(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      derivedFrom: derivedFrom == freezed
          ? _value.derivedFrom
          : derivedFrom as List<Canonical>,
      status: status == freezed ? _value.status : status as QuestionnaireStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectType: subjectType == freezed
          ? _value.subjectType
          : subjectType as List<Code>,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      code: code == freezed ? _value.code : code as List<Coding>,
      item: item == freezed ? _value.item : item as List<QuestionnaireItem>,
    ));
  }
}

@JsonSerializable()
class _$_Questionnaire implements _Questionnaire {
  const _$_Questionnaire(
      {@required
      @JsonKey(required: true, defaultValue: 'Questionnaire')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.derivedFrom,
      @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
          this.status,
      this.experimental,
      this.subjectType,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.code,
      this.item})
      : assert(resourceType != null);

  factory _$_Questionnaire.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'Questionnaire')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final List<Canonical> derivedFrom;
  @override
  @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
  final QuestionnaireStatus status;
  @override
  final Boolean experimental;
  @override
  final List<Code> subjectType;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<Coding> code;
  @override
  final List<QuestionnaireItem> item;

  @override
  String toString() {
    return 'Questionnaire(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, derivedFrom: $derivedFrom, status: $status, experimental: $experimental, subjectType: $subjectType, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, code: $code, item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Questionnaire &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.derivedFrom, derivedFrom) ||
                const DeepCollectionEquality()
                    .equals(other.derivedFrom, derivedFrom)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectType, subjectType) ||
                const DeepCollectionEquality()
                    .equals(other.subjectType, subjectType)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) ||
                const DeepCollectionEquality()
                    .equals(other.purpose, purpose)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.code, code) || const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.item, item) || const DeepCollectionEquality().equals(other.item, item)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(derivedFrom) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectType) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(item);

  @override
  _$QuestionnaireCopyWith<_Questionnaire> get copyWith =>
      __$QuestionnaireCopyWithImpl<_Questionnaire>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireToJson(this);
  }
}

abstract class _Questionnaire implements Questionnaire {
  const factory _Questionnaire(
      {@required
      @JsonKey(required: true, defaultValue: 'Questionnaire')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      List<Canonical> derivedFrom,
      @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
          QuestionnaireStatus status,
      Boolean experimental,
      List<Code> subjectType,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<Coding> code,
      List<QuestionnaireItem> item}) = _$_Questionnaire;

  factory _Questionnaire.fromJson(Map<String, dynamic> json) =
      _$_Questionnaire.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'Questionnaire')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  List<Canonical> get derivedFrom;
  @override
  @JsonKey(unknownEnumValue: QuestionnaireStatus.unknown)
  QuestionnaireStatus get status;
  @override
  Boolean get experimental;
  @override
  List<Code> get subjectType;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<Coding> get code;
  @override
  List<QuestionnaireItem> get item;
  @override
  _$QuestionnaireCopyWith<_Questionnaire> get copyWith;
}

QuestionnaireItem _$QuestionnaireItemFromJson(Map<String, dynamic> json) {
  return _QuestionnaireItem.fromJson(json);
}

class _$QuestionnaireItemTearOff {
  const _$QuestionnaireItemTearOff();

  _QuestionnaireItem call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String linkId,
      FhirUri definition,
      List<Coding> code,
      String prefix,
      String text,
      @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
          QuestionnaireItemType type,
      List<QuestionnaireEnableWhen> enableWhen,
      @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
          ItemEnableBehavior enableBehavior,
      Boolean required,
      Boolean repeats,
      Boolean readOnly,
      Integer maxLength,
      Canonical answerValueSet,
      List<QuestionnaireAnswerOption> answerOption,
      List<QuestionnaireInitial> initial,
      List<QuestionnaireItem> item}) {
    return _QuestionnaireItem(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      linkId: linkId,
      definition: definition,
      code: code,
      prefix: prefix,
      text: text,
      type: type,
      enableWhen: enableWhen,
      enableBehavior: enableBehavior,
      required: required,
      repeats: repeats,
      readOnly: readOnly,
      maxLength: maxLength,
      answerValueSet: answerValueSet,
      answerOption: answerOption,
      initial: initial,
      item: item,
    );
  }
}

// ignore: unused_element
const $QuestionnaireItem = _$QuestionnaireItemTearOff();

mixin _$QuestionnaireItem {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get linkId;
  FhirUri get definition;
  List<Coding> get code;
  String get prefix;
  String get text;
  @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
  QuestionnaireItemType get type;
  List<QuestionnaireEnableWhen> get enableWhen;
  @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
  ItemEnableBehavior get enableBehavior;
  Boolean get required;
  Boolean get repeats;
  Boolean get readOnly;
  Integer get maxLength;
  Canonical get answerValueSet;
  List<QuestionnaireAnswerOption> get answerOption;
  List<QuestionnaireInitial> get initial;
  List<QuestionnaireItem> get item;

  Map<String, dynamic> toJson();
  $QuestionnaireItemCopyWith<QuestionnaireItem> get copyWith;
}

abstract class $QuestionnaireItemCopyWith<$Res> {
  factory $QuestionnaireItemCopyWith(
          QuestionnaireItem value, $Res Function(QuestionnaireItem) then) =
      _$QuestionnaireItemCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String linkId,
      FhirUri definition,
      List<Coding> code,
      String prefix,
      String text,
      @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
          QuestionnaireItemType type,
      List<QuestionnaireEnableWhen> enableWhen,
      @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
          ItemEnableBehavior enableBehavior,
      Boolean required,
      Boolean repeats,
      Boolean readOnly,
      Integer maxLength,
      Canonical answerValueSet,
      List<QuestionnaireAnswerOption> answerOption,
      List<QuestionnaireInitial> initial,
      List<QuestionnaireItem> item});
}

class _$QuestionnaireItemCopyWithImpl<$Res>
    implements $QuestionnaireItemCopyWith<$Res> {
  _$QuestionnaireItemCopyWithImpl(this._value, this._then);

  final QuestionnaireItem _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireItem) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object linkId = freezed,
    Object definition = freezed,
    Object code = freezed,
    Object prefix = freezed,
    Object text = freezed,
    Object type = freezed,
    Object enableWhen = freezed,
    Object enableBehavior = freezed,
    Object required = freezed,
    Object repeats = freezed,
    Object readOnly = freezed,
    Object maxLength = freezed,
    Object answerValueSet = freezed,
    Object answerOption = freezed,
    Object initial = freezed,
    Object item = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      linkId: linkId == freezed ? _value.linkId : linkId as String,
      definition:
          definition == freezed ? _value.definition : definition as FhirUri,
      code: code == freezed ? _value.code : code as List<Coding>,
      prefix: prefix == freezed ? _value.prefix : prefix as String,
      text: text == freezed ? _value.text : text as String,
      type: type == freezed ? _value.type : type as QuestionnaireItemType,
      enableWhen: enableWhen == freezed
          ? _value.enableWhen
          : enableWhen as List<QuestionnaireEnableWhen>,
      enableBehavior: enableBehavior == freezed
          ? _value.enableBehavior
          : enableBehavior as ItemEnableBehavior,
      required: required == freezed ? _value.required : required as Boolean,
      repeats: repeats == freezed ? _value.repeats : repeats as Boolean,
      readOnly: readOnly == freezed ? _value.readOnly : readOnly as Boolean,
      maxLength: maxLength == freezed ? _value.maxLength : maxLength as Integer,
      answerValueSet: answerValueSet == freezed
          ? _value.answerValueSet
          : answerValueSet as Canonical,
      answerOption: answerOption == freezed
          ? _value.answerOption
          : answerOption as List<QuestionnaireAnswerOption>,
      initial: initial == freezed
          ? _value.initial
          : initial as List<QuestionnaireInitial>,
      item: item == freezed ? _value.item : item as List<QuestionnaireItem>,
    ));
  }
}

abstract class _$QuestionnaireItemCopyWith<$Res>
    implements $QuestionnaireItemCopyWith<$Res> {
  factory _$QuestionnaireItemCopyWith(
          _QuestionnaireItem value, $Res Function(_QuestionnaireItem) then) =
      __$QuestionnaireItemCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String linkId,
      FhirUri definition,
      List<Coding> code,
      String prefix,
      String text,
      @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
          QuestionnaireItemType type,
      List<QuestionnaireEnableWhen> enableWhen,
      @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
          ItemEnableBehavior enableBehavior,
      Boolean required,
      Boolean repeats,
      Boolean readOnly,
      Integer maxLength,
      Canonical answerValueSet,
      List<QuestionnaireAnswerOption> answerOption,
      List<QuestionnaireInitial> initial,
      List<QuestionnaireItem> item});
}

class __$QuestionnaireItemCopyWithImpl<$Res>
    extends _$QuestionnaireItemCopyWithImpl<$Res>
    implements _$QuestionnaireItemCopyWith<$Res> {
  __$QuestionnaireItemCopyWithImpl(
      _QuestionnaireItem _value, $Res Function(_QuestionnaireItem) _then)
      : super(_value, (v) => _then(v as _QuestionnaireItem));

  @override
  _QuestionnaireItem get _value => super._value as _QuestionnaireItem;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object linkId = freezed,
    Object definition = freezed,
    Object code = freezed,
    Object prefix = freezed,
    Object text = freezed,
    Object type = freezed,
    Object enableWhen = freezed,
    Object enableBehavior = freezed,
    Object required = freezed,
    Object repeats = freezed,
    Object readOnly = freezed,
    Object maxLength = freezed,
    Object answerValueSet = freezed,
    Object answerOption = freezed,
    Object initial = freezed,
    Object item = freezed,
  }) {
    return _then(_QuestionnaireItem(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      linkId: linkId == freezed ? _value.linkId : linkId as String,
      definition:
          definition == freezed ? _value.definition : definition as FhirUri,
      code: code == freezed ? _value.code : code as List<Coding>,
      prefix: prefix == freezed ? _value.prefix : prefix as String,
      text: text == freezed ? _value.text : text as String,
      type: type == freezed ? _value.type : type as QuestionnaireItemType,
      enableWhen: enableWhen == freezed
          ? _value.enableWhen
          : enableWhen as List<QuestionnaireEnableWhen>,
      enableBehavior: enableBehavior == freezed
          ? _value.enableBehavior
          : enableBehavior as ItemEnableBehavior,
      required: required == freezed ? _value.required : required as Boolean,
      repeats: repeats == freezed ? _value.repeats : repeats as Boolean,
      readOnly: readOnly == freezed ? _value.readOnly : readOnly as Boolean,
      maxLength: maxLength == freezed ? _value.maxLength : maxLength as Integer,
      answerValueSet: answerValueSet == freezed
          ? _value.answerValueSet
          : answerValueSet as Canonical,
      answerOption: answerOption == freezed
          ? _value.answerOption
          : answerOption as List<QuestionnaireAnswerOption>,
      initial: initial == freezed
          ? _value.initial
          : initial as List<QuestionnaireInitial>,
      item: item == freezed ? _value.item : item as List<QuestionnaireItem>,
    ));
  }
}

@JsonSerializable()
class _$_QuestionnaireItem implements _QuestionnaireItem {
  const _$_QuestionnaireItem(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.linkId,
      this.definition,
      this.code,
      this.prefix,
      this.text,
      @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
          this.type,
      this.enableWhen,
      @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
          this.enableBehavior,
      this.required,
      this.repeats,
      this.readOnly,
      this.maxLength,
      this.answerValueSet,
      this.answerOption,
      this.initial,
      this.item});

  factory _$_QuestionnaireItem.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireItemFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String linkId;
  @override
  final FhirUri definition;
  @override
  final List<Coding> code;
  @override
  final String prefix;
  @override
  final String text;
  @override
  @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
  final QuestionnaireItemType type;
  @override
  final List<QuestionnaireEnableWhen> enableWhen;
  @override
  @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
  final ItemEnableBehavior enableBehavior;
  @override
  final Boolean required;
  @override
  final Boolean repeats;
  @override
  final Boolean readOnly;
  @override
  final Integer maxLength;
  @override
  final Canonical answerValueSet;
  @override
  final List<QuestionnaireAnswerOption> answerOption;
  @override
  final List<QuestionnaireInitial> initial;
  @override
  final List<QuestionnaireItem> item;

  @override
  String toString() {
    return 'QuestionnaireItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, linkId: $linkId, definition: $definition, code: $code, prefix: $prefix, text: $text, type: $type, enableWhen: $enableWhen, enableBehavior: $enableBehavior, required: $required, repeats: $repeats, readOnly: $readOnly, maxLength: $maxLength, answerValueSet: $answerValueSet, answerOption: $answerOption, initial: $initial, item: $item)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.linkId, linkId) ||
                const DeepCollectionEquality().equals(other.linkId, linkId)) &&
            (identical(other.definition, definition) ||
                const DeepCollectionEquality()
                    .equals(other.definition, definition)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.enableWhen, enableWhen) ||
                const DeepCollectionEquality()
                    .equals(other.enableWhen, enableWhen)) &&
            (identical(other.enableBehavior, enableBehavior) ||
                const DeepCollectionEquality()
                    .equals(other.enableBehavior, enableBehavior)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality()
                    .equals(other.required, required)) &&
            (identical(other.repeats, repeats) ||
                const DeepCollectionEquality()
                    .equals(other.repeats, repeats)) &&
            (identical(other.readOnly, readOnly) ||
                const DeepCollectionEquality()
                    .equals(other.readOnly, readOnly)) &&
            (identical(other.maxLength, maxLength) ||
                const DeepCollectionEquality()
                    .equals(other.maxLength, maxLength)) &&
            (identical(other.answerValueSet, answerValueSet) ||
                const DeepCollectionEquality()
                    .equals(other.answerValueSet, answerValueSet)) &&
            (identical(other.answerOption, answerOption) ||
                const DeepCollectionEquality()
                    .equals(other.answerOption, answerOption)) &&
            (identical(other.initial, initial) ||
                const DeepCollectionEquality()
                    .equals(other.initial, initial)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(linkId) ^
      const DeepCollectionEquality().hash(definition) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(enableWhen) ^
      const DeepCollectionEquality().hash(enableBehavior) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(repeats) ^
      const DeepCollectionEquality().hash(readOnly) ^
      const DeepCollectionEquality().hash(maxLength) ^
      const DeepCollectionEquality().hash(answerValueSet) ^
      const DeepCollectionEquality().hash(answerOption) ^
      const DeepCollectionEquality().hash(initial) ^
      const DeepCollectionEquality().hash(item);

  @override
  _$QuestionnaireItemCopyWith<_QuestionnaireItem> get copyWith =>
      __$QuestionnaireItemCopyWithImpl<_QuestionnaireItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireItemToJson(this);
  }
}

abstract class _QuestionnaireItem implements QuestionnaireItem {
  const factory _QuestionnaireItem(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String linkId,
      FhirUri definition,
      List<Coding> code,
      String prefix,
      String text,
      @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
          QuestionnaireItemType type,
      List<QuestionnaireEnableWhen> enableWhen,
      @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
          ItemEnableBehavior enableBehavior,
      Boolean required,
      Boolean repeats,
      Boolean readOnly,
      Integer maxLength,
      Canonical answerValueSet,
      List<QuestionnaireAnswerOption> answerOption,
      List<QuestionnaireInitial> initial,
      List<QuestionnaireItem> item}) = _$_QuestionnaireItem;

  factory _QuestionnaireItem.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireItem.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get linkId;
  @override
  FhirUri get definition;
  @override
  List<Coding> get code;
  @override
  String get prefix;
  @override
  String get text;
  @override
  @JsonKey(unknownEnumValue: QuestionnaireItemType.unknown)
  QuestionnaireItemType get type;
  @override
  List<QuestionnaireEnableWhen> get enableWhen;
  @override
  @JsonKey(unknownEnumValue: ItemEnableBehavior.unknown)
  ItemEnableBehavior get enableBehavior;
  @override
  Boolean get required;
  @override
  Boolean get repeats;
  @override
  Boolean get readOnly;
  @override
  Integer get maxLength;
  @override
  Canonical get answerValueSet;
  @override
  List<QuestionnaireAnswerOption> get answerOption;
  @override
  List<QuestionnaireInitial> get initial;
  @override
  List<QuestionnaireItem> get item;
  @override
  _$QuestionnaireItemCopyWith<_QuestionnaireItem> get copyWith;
}

QuestionnaireEnableWhen _$QuestionnaireEnableWhenFromJson(
    Map<String, dynamic> json) {
  return _QuestionnaireEnableWhen.fromJson(json);
}

class _$QuestionnaireEnableWhenTearOff {
  const _$QuestionnaireEnableWhenTearOff();

  _QuestionnaireEnableWhen call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String question,
      @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
          EnableWhenOperator operator,
      Boolean answerBoolean,
      Decimal answerDecimal,
      Integer answerInteger,
      Date answerDate,
      FhirDateTime answerDateTime,
      Time answerTime,
      String answerString,
      Coding answerCoding,
      Quantity answerQuantity,
      Reference answerReference}) {
    return _QuestionnaireEnableWhen(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      question: question,
      operator: operator,
      answerBoolean: answerBoolean,
      answerDecimal: answerDecimal,
      answerInteger: answerInteger,
      answerDate: answerDate,
      answerDateTime: answerDateTime,
      answerTime: answerTime,
      answerString: answerString,
      answerCoding: answerCoding,
      answerQuantity: answerQuantity,
      answerReference: answerReference,
    );
  }
}

// ignore: unused_element
const $QuestionnaireEnableWhen = _$QuestionnaireEnableWhenTearOff();

mixin _$QuestionnaireEnableWhen {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get question;
  @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
  EnableWhenOperator get operator;
  Boolean get answerBoolean;
  Decimal get answerDecimal;
  Integer get answerInteger;
  Date get answerDate;
  FhirDateTime get answerDateTime;
  Time get answerTime;
  String get answerString;
  Coding get answerCoding;
  Quantity get answerQuantity;
  Reference get answerReference;

  Map<String, dynamic> toJson();
  $QuestionnaireEnableWhenCopyWith<QuestionnaireEnableWhen> get copyWith;
}

abstract class $QuestionnaireEnableWhenCopyWith<$Res> {
  factory $QuestionnaireEnableWhenCopyWith(QuestionnaireEnableWhen value,
          $Res Function(QuestionnaireEnableWhen) then) =
      _$QuestionnaireEnableWhenCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String question,
      @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
          EnableWhenOperator operator,
      Boolean answerBoolean,
      Decimal answerDecimal,
      Integer answerInteger,
      Date answerDate,
      FhirDateTime answerDateTime,
      Time answerTime,
      String answerString,
      Coding answerCoding,
      Quantity answerQuantity,
      Reference answerReference});

  $CodingCopyWith<$Res> get answerCoding;
  $QuantityCopyWith<$Res> get answerQuantity;
  $ReferenceCopyWith<$Res> get answerReference;
}

class _$QuestionnaireEnableWhenCopyWithImpl<$Res>
    implements $QuestionnaireEnableWhenCopyWith<$Res> {
  _$QuestionnaireEnableWhenCopyWithImpl(this._value, this._then);

  final QuestionnaireEnableWhen _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireEnableWhen) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object question = freezed,
    Object operator = freezed,
    Object answerBoolean = freezed,
    Object answerDecimal = freezed,
    Object answerInteger = freezed,
    Object answerDate = freezed,
    Object answerDateTime = freezed,
    Object answerTime = freezed,
    Object answerString = freezed,
    Object answerCoding = freezed,
    Object answerQuantity = freezed,
    Object answerReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      question: question == freezed ? _value.question : question as String,
      operator: operator == freezed
          ? _value.operator
          : operator as EnableWhenOperator,
      answerBoolean: answerBoolean == freezed
          ? _value.answerBoolean
          : answerBoolean as Boolean,
      answerDecimal: answerDecimal == freezed
          ? _value.answerDecimal
          : answerDecimal as Decimal,
      answerInteger: answerInteger == freezed
          ? _value.answerInteger
          : answerInteger as Integer,
      answerDate:
          answerDate == freezed ? _value.answerDate : answerDate as Date,
      answerDateTime: answerDateTime == freezed
          ? _value.answerDateTime
          : answerDateTime as FhirDateTime,
      answerTime:
          answerTime == freezed ? _value.answerTime : answerTime as Time,
      answerString: answerString == freezed
          ? _value.answerString
          : answerString as String,
      answerCoding: answerCoding == freezed
          ? _value.answerCoding
          : answerCoding as Coding,
      answerQuantity: answerQuantity == freezed
          ? _value.answerQuantity
          : answerQuantity as Quantity,
      answerReference: answerReference == freezed
          ? _value.answerReference
          : answerReference as Reference,
    ));
  }

  @override
  $CodingCopyWith<$Res> get answerCoding {
    if (_value.answerCoding == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.answerCoding, (value) {
      return _then(_value.copyWith(answerCoding: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get answerQuantity {
    if (_value.answerQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.answerQuantity, (value) {
      return _then(_value.copyWith(answerQuantity: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get answerReference {
    if (_value.answerReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.answerReference, (value) {
      return _then(_value.copyWith(answerReference: value));
    });
  }
}

abstract class _$QuestionnaireEnableWhenCopyWith<$Res>
    implements $QuestionnaireEnableWhenCopyWith<$Res> {
  factory _$QuestionnaireEnableWhenCopyWith(_QuestionnaireEnableWhen value,
          $Res Function(_QuestionnaireEnableWhen) then) =
      __$QuestionnaireEnableWhenCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String question,
      @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
          EnableWhenOperator operator,
      Boolean answerBoolean,
      Decimal answerDecimal,
      Integer answerInteger,
      Date answerDate,
      FhirDateTime answerDateTime,
      Time answerTime,
      String answerString,
      Coding answerCoding,
      Quantity answerQuantity,
      Reference answerReference});

  @override
  $CodingCopyWith<$Res> get answerCoding;
  @override
  $QuantityCopyWith<$Res> get answerQuantity;
  @override
  $ReferenceCopyWith<$Res> get answerReference;
}

class __$QuestionnaireEnableWhenCopyWithImpl<$Res>
    extends _$QuestionnaireEnableWhenCopyWithImpl<$Res>
    implements _$QuestionnaireEnableWhenCopyWith<$Res> {
  __$QuestionnaireEnableWhenCopyWithImpl(_QuestionnaireEnableWhen _value,
      $Res Function(_QuestionnaireEnableWhen) _then)
      : super(_value, (v) => _then(v as _QuestionnaireEnableWhen));

  @override
  _QuestionnaireEnableWhen get _value =>
      super._value as _QuestionnaireEnableWhen;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object question = freezed,
    Object operator = freezed,
    Object answerBoolean = freezed,
    Object answerDecimal = freezed,
    Object answerInteger = freezed,
    Object answerDate = freezed,
    Object answerDateTime = freezed,
    Object answerTime = freezed,
    Object answerString = freezed,
    Object answerCoding = freezed,
    Object answerQuantity = freezed,
    Object answerReference = freezed,
  }) {
    return _then(_QuestionnaireEnableWhen(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      question: question == freezed ? _value.question : question as String,
      operator: operator == freezed
          ? _value.operator
          : operator as EnableWhenOperator,
      answerBoolean: answerBoolean == freezed
          ? _value.answerBoolean
          : answerBoolean as Boolean,
      answerDecimal: answerDecimal == freezed
          ? _value.answerDecimal
          : answerDecimal as Decimal,
      answerInteger: answerInteger == freezed
          ? _value.answerInteger
          : answerInteger as Integer,
      answerDate:
          answerDate == freezed ? _value.answerDate : answerDate as Date,
      answerDateTime: answerDateTime == freezed
          ? _value.answerDateTime
          : answerDateTime as FhirDateTime,
      answerTime:
          answerTime == freezed ? _value.answerTime : answerTime as Time,
      answerString: answerString == freezed
          ? _value.answerString
          : answerString as String,
      answerCoding: answerCoding == freezed
          ? _value.answerCoding
          : answerCoding as Coding,
      answerQuantity: answerQuantity == freezed
          ? _value.answerQuantity
          : answerQuantity as Quantity,
      answerReference: answerReference == freezed
          ? _value.answerReference
          : answerReference as Reference,
    ));
  }
}

@JsonSerializable()
class _$_QuestionnaireEnableWhen implements _QuestionnaireEnableWhen {
  const _$_QuestionnaireEnableWhen(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.question,
      @JsonKey(unknownEnumValue: EnableWhenOperator.unknown) this.operator,
      this.answerBoolean,
      this.answerDecimal,
      this.answerInteger,
      this.answerDate,
      this.answerDateTime,
      this.answerTime,
      this.answerString,
      this.answerCoding,
      this.answerQuantity,
      this.answerReference});

  factory _$_QuestionnaireEnableWhen.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireEnableWhenFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String question;
  @override
  @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
  final EnableWhenOperator operator;
  @override
  final Boolean answerBoolean;
  @override
  final Decimal answerDecimal;
  @override
  final Integer answerInteger;
  @override
  final Date answerDate;
  @override
  final FhirDateTime answerDateTime;
  @override
  final Time answerTime;
  @override
  final String answerString;
  @override
  final Coding answerCoding;
  @override
  final Quantity answerQuantity;
  @override
  final Reference answerReference;

  @override
  String toString() {
    return 'QuestionnaireEnableWhen(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, question: $question, operator: $operator, answerBoolean: $answerBoolean, answerDecimal: $answerDecimal, answerInteger: $answerInteger, answerDate: $answerDate, answerDateTime: $answerDateTime, answerTime: $answerTime, answerString: $answerString, answerCoding: $answerCoding, answerQuantity: $answerQuantity, answerReference: $answerReference)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireEnableWhen &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.question, question) ||
                const DeepCollectionEquality()
                    .equals(other.question, question)) &&
            (identical(other.operator, operator) ||
                const DeepCollectionEquality()
                    .equals(other.operator, operator)) &&
            (identical(other.answerBoolean, answerBoolean) ||
                const DeepCollectionEquality()
                    .equals(other.answerBoolean, answerBoolean)) &&
            (identical(other.answerDecimal, answerDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.answerDecimal, answerDecimal)) &&
            (identical(other.answerInteger, answerInteger) ||
                const DeepCollectionEquality()
                    .equals(other.answerInteger, answerInteger)) &&
            (identical(other.answerDate, answerDate) ||
                const DeepCollectionEquality()
                    .equals(other.answerDate, answerDate)) &&
            (identical(other.answerDateTime, answerDateTime) ||
                const DeepCollectionEquality()
                    .equals(other.answerDateTime, answerDateTime)) &&
            (identical(other.answerTime, answerTime) ||
                const DeepCollectionEquality()
                    .equals(other.answerTime, answerTime)) &&
            (identical(other.answerString, answerString) ||
                const DeepCollectionEquality()
                    .equals(other.answerString, answerString)) &&
            (identical(other.answerCoding, answerCoding) ||
                const DeepCollectionEquality()
                    .equals(other.answerCoding, answerCoding)) &&
            (identical(other.answerQuantity, answerQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.answerQuantity, answerQuantity)) &&
            (identical(other.answerReference, answerReference) ||
                const DeepCollectionEquality()
                    .equals(other.answerReference, answerReference)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(question) ^
      const DeepCollectionEquality().hash(operator) ^
      const DeepCollectionEquality().hash(answerBoolean) ^
      const DeepCollectionEquality().hash(answerDecimal) ^
      const DeepCollectionEquality().hash(answerInteger) ^
      const DeepCollectionEquality().hash(answerDate) ^
      const DeepCollectionEquality().hash(answerDateTime) ^
      const DeepCollectionEquality().hash(answerTime) ^
      const DeepCollectionEquality().hash(answerString) ^
      const DeepCollectionEquality().hash(answerCoding) ^
      const DeepCollectionEquality().hash(answerQuantity) ^
      const DeepCollectionEquality().hash(answerReference);

  @override
  _$QuestionnaireEnableWhenCopyWith<_QuestionnaireEnableWhen> get copyWith =>
      __$QuestionnaireEnableWhenCopyWithImpl<_QuestionnaireEnableWhen>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireEnableWhenToJson(this);
  }
}

abstract class _QuestionnaireEnableWhen implements QuestionnaireEnableWhen {
  const factory _QuestionnaireEnableWhen(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String question,
      @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
          EnableWhenOperator operator,
      Boolean answerBoolean,
      Decimal answerDecimal,
      Integer answerInteger,
      Date answerDate,
      FhirDateTime answerDateTime,
      Time answerTime,
      String answerString,
      Coding answerCoding,
      Quantity answerQuantity,
      Reference answerReference}) = _$_QuestionnaireEnableWhen;

  factory _QuestionnaireEnableWhen.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireEnableWhen.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get question;
  @override
  @JsonKey(unknownEnumValue: EnableWhenOperator.unknown)
  EnableWhenOperator get operator;
  @override
  Boolean get answerBoolean;
  @override
  Decimal get answerDecimal;
  @override
  Integer get answerInteger;
  @override
  Date get answerDate;
  @override
  FhirDateTime get answerDateTime;
  @override
  Time get answerTime;
  @override
  String get answerString;
  @override
  Coding get answerCoding;
  @override
  Quantity get answerQuantity;
  @override
  Reference get answerReference;
  @override
  _$QuestionnaireEnableWhenCopyWith<_QuestionnaireEnableWhen> get copyWith;
}

QuestionnaireAnswerOption _$QuestionnaireAnswerOptionFromJson(
    Map<String, dynamic> json) {
  return _QuestionnaireAnswerOption.fromJson(json);
}

class _$QuestionnaireAnswerOptionTearOff {
  const _$QuestionnaireAnswerOptionTearOff();

  _QuestionnaireAnswerOption call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer valueInteger,
      Date valueDate,
      Time valueTime,
      String valueString,
      Coding valueCoding,
      Reference valueReference,
      Boolean initialSelected}) {
    return _QuestionnaireAnswerOption(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      valueInteger: valueInteger,
      valueDate: valueDate,
      valueTime: valueTime,
      valueString: valueString,
      valueCoding: valueCoding,
      valueReference: valueReference,
      initialSelected: initialSelected,
    );
  }
}

// ignore: unused_element
const $QuestionnaireAnswerOption = _$QuestionnaireAnswerOptionTearOff();

mixin _$QuestionnaireAnswerOption {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get valueInteger;
  Date get valueDate;
  Time get valueTime;
  String get valueString;
  Coding get valueCoding;
  Reference get valueReference;
  Boolean get initialSelected;

  Map<String, dynamic> toJson();
  $QuestionnaireAnswerOptionCopyWith<QuestionnaireAnswerOption> get copyWith;
}

abstract class $QuestionnaireAnswerOptionCopyWith<$Res> {
  factory $QuestionnaireAnswerOptionCopyWith(QuestionnaireAnswerOption value,
          $Res Function(QuestionnaireAnswerOption) then) =
      _$QuestionnaireAnswerOptionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer valueInteger,
      Date valueDate,
      Time valueTime,
      String valueString,
      Coding valueCoding,
      Reference valueReference,
      Boolean initialSelected});

  $CodingCopyWith<$Res> get valueCoding;
  $ReferenceCopyWith<$Res> get valueReference;
}

class _$QuestionnaireAnswerOptionCopyWithImpl<$Res>
    implements $QuestionnaireAnswerOptionCopyWith<$Res> {
  _$QuestionnaireAnswerOptionCopyWithImpl(this._value, this._then);

  final QuestionnaireAnswerOption _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireAnswerOption) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object valueInteger = freezed,
    Object valueDate = freezed,
    Object valueTime = freezed,
    Object valueString = freezed,
    Object valueCoding = freezed,
    Object valueReference = freezed,
    Object initialSelected = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      valueInteger: valueInteger == freezed
          ? _value.valueInteger
          : valueInteger as Integer,
      valueDate: valueDate == freezed ? _value.valueDate : valueDate as Date,
      valueTime: valueTime == freezed ? _value.valueTime : valueTime as Time,
      valueString:
          valueString == freezed ? _value.valueString : valueString as String,
      valueCoding:
          valueCoding == freezed ? _value.valueCoding : valueCoding as Coding,
      valueReference: valueReference == freezed
          ? _value.valueReference
          : valueReference as Reference,
      initialSelected: initialSelected == freezed
          ? _value.initialSelected
          : initialSelected as Boolean,
    ));
  }

  @override
  $CodingCopyWith<$Res> get valueCoding {
    if (_value.valueCoding == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.valueCoding, (value) {
      return _then(_value.copyWith(valueCoding: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get valueReference {
    if (_value.valueReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.valueReference, (value) {
      return _then(_value.copyWith(valueReference: value));
    });
  }
}

abstract class _$QuestionnaireAnswerOptionCopyWith<$Res>
    implements $QuestionnaireAnswerOptionCopyWith<$Res> {
  factory _$QuestionnaireAnswerOptionCopyWith(_QuestionnaireAnswerOption value,
          $Res Function(_QuestionnaireAnswerOption) then) =
      __$QuestionnaireAnswerOptionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer valueInteger,
      Date valueDate,
      Time valueTime,
      String valueString,
      Coding valueCoding,
      Reference valueReference,
      Boolean initialSelected});

  @override
  $CodingCopyWith<$Res> get valueCoding;
  @override
  $ReferenceCopyWith<$Res> get valueReference;
}

class __$QuestionnaireAnswerOptionCopyWithImpl<$Res>
    extends _$QuestionnaireAnswerOptionCopyWithImpl<$Res>
    implements _$QuestionnaireAnswerOptionCopyWith<$Res> {
  __$QuestionnaireAnswerOptionCopyWithImpl(_QuestionnaireAnswerOption _value,
      $Res Function(_QuestionnaireAnswerOption) _then)
      : super(_value, (v) => _then(v as _QuestionnaireAnswerOption));

  @override
  _QuestionnaireAnswerOption get _value =>
      super._value as _QuestionnaireAnswerOption;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object valueInteger = freezed,
    Object valueDate = freezed,
    Object valueTime = freezed,
    Object valueString = freezed,
    Object valueCoding = freezed,
    Object valueReference = freezed,
    Object initialSelected = freezed,
  }) {
    return _then(_QuestionnaireAnswerOption(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      valueInteger: valueInteger == freezed
          ? _value.valueInteger
          : valueInteger as Integer,
      valueDate: valueDate == freezed ? _value.valueDate : valueDate as Date,
      valueTime: valueTime == freezed ? _value.valueTime : valueTime as Time,
      valueString:
          valueString == freezed ? _value.valueString : valueString as String,
      valueCoding:
          valueCoding == freezed ? _value.valueCoding : valueCoding as Coding,
      valueReference: valueReference == freezed
          ? _value.valueReference
          : valueReference as Reference,
      initialSelected: initialSelected == freezed
          ? _value.initialSelected
          : initialSelected as Boolean,
    ));
  }
}

@JsonSerializable()
class _$_QuestionnaireAnswerOption implements _QuestionnaireAnswerOption {
  const _$_QuestionnaireAnswerOption(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.valueInteger,
      this.valueDate,
      this.valueTime,
      this.valueString,
      this.valueCoding,
      this.valueReference,
      this.initialSelected});

  factory _$_QuestionnaireAnswerOption.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireAnswerOptionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer valueInteger;
  @override
  final Date valueDate;
  @override
  final Time valueTime;
  @override
  final String valueString;
  @override
  final Coding valueCoding;
  @override
  final Reference valueReference;
  @override
  final Boolean initialSelected;

  @override
  String toString() {
    return 'QuestionnaireAnswerOption(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, valueInteger: $valueInteger, valueDate: $valueDate, valueTime: $valueTime, valueString: $valueString, valueCoding: $valueCoding, valueReference: $valueReference, initialSelected: $initialSelected)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireAnswerOption &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.valueInteger, valueInteger) ||
                const DeepCollectionEquality()
                    .equals(other.valueInteger, valueInteger)) &&
            (identical(other.valueDate, valueDate) ||
                const DeepCollectionEquality()
                    .equals(other.valueDate, valueDate)) &&
            (identical(other.valueTime, valueTime) ||
                const DeepCollectionEquality()
                    .equals(other.valueTime, valueTime)) &&
            (identical(other.valueString, valueString) ||
                const DeepCollectionEquality()
                    .equals(other.valueString, valueString)) &&
            (identical(other.valueCoding, valueCoding) ||
                const DeepCollectionEquality()
                    .equals(other.valueCoding, valueCoding)) &&
            (identical(other.valueReference, valueReference) ||
                const DeepCollectionEquality()
                    .equals(other.valueReference, valueReference)) &&
            (identical(other.initialSelected, initialSelected) ||
                const DeepCollectionEquality()
                    .equals(other.initialSelected, initialSelected)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(valueInteger) ^
      const DeepCollectionEquality().hash(valueDate) ^
      const DeepCollectionEquality().hash(valueTime) ^
      const DeepCollectionEquality().hash(valueString) ^
      const DeepCollectionEquality().hash(valueCoding) ^
      const DeepCollectionEquality().hash(valueReference) ^
      const DeepCollectionEquality().hash(initialSelected);

  @override
  _$QuestionnaireAnswerOptionCopyWith<_QuestionnaireAnswerOption>
      get copyWith =>
          __$QuestionnaireAnswerOptionCopyWithImpl<_QuestionnaireAnswerOption>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireAnswerOptionToJson(this);
  }
}

abstract class _QuestionnaireAnswerOption implements QuestionnaireAnswerOption {
  const factory _QuestionnaireAnswerOption(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer valueInteger,
      Date valueDate,
      Time valueTime,
      String valueString,
      Coding valueCoding,
      Reference valueReference,
      Boolean initialSelected}) = _$_QuestionnaireAnswerOption;

  factory _QuestionnaireAnswerOption.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireAnswerOption.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get valueInteger;
  @override
  Date get valueDate;
  @override
  Time get valueTime;
  @override
  String get valueString;
  @override
  Coding get valueCoding;
  @override
  Reference get valueReference;
  @override
  Boolean get initialSelected;
  @override
  _$QuestionnaireAnswerOptionCopyWith<_QuestionnaireAnswerOption> get copyWith;
}

QuestionnaireInitial _$QuestionnaireInitialFromJson(Map<String, dynamic> json) {
  return _QuestionnaireInitial.fromJson(json);
}

class _$QuestionnaireInitialTearOff {
  const _$QuestionnaireInitialTearOff();

  _QuestionnaireInitial call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean valueBoolean,
      Decimal valueDecimal,
      Integer valueInteger,
      Date valueDate,
      FhirDateTime valueDateTime,
      Time valueTime,
      String valueString,
      FhirUri valueUri,
      Attachment valueAttachment,
      Coding valueCoding,
      Quantity valueQuantity,
      Reference valueReference}) {
    return _QuestionnaireInitial(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      valueBoolean: valueBoolean,
      valueDecimal: valueDecimal,
      valueInteger: valueInteger,
      valueDate: valueDate,
      valueDateTime: valueDateTime,
      valueTime: valueTime,
      valueString: valueString,
      valueUri: valueUri,
      valueAttachment: valueAttachment,
      valueCoding: valueCoding,
      valueQuantity: valueQuantity,
      valueReference: valueReference,
    );
  }
}

// ignore: unused_element
const $QuestionnaireInitial = _$QuestionnaireInitialTearOff();

mixin _$QuestionnaireInitial {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Boolean get valueBoolean;
  Decimal get valueDecimal;
  Integer get valueInteger;
  Date get valueDate;
  FhirDateTime get valueDateTime;
  Time get valueTime;
  String get valueString;
  FhirUri get valueUri;
  Attachment get valueAttachment;
  Coding get valueCoding;
  Quantity get valueQuantity;
  Reference get valueReference;

  Map<String, dynamic> toJson();
  $QuestionnaireInitialCopyWith<QuestionnaireInitial> get copyWith;
}

abstract class $QuestionnaireInitialCopyWith<$Res> {
  factory $QuestionnaireInitialCopyWith(QuestionnaireInitial value,
          $Res Function(QuestionnaireInitial) then) =
      _$QuestionnaireInitialCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean valueBoolean,
      Decimal valueDecimal,
      Integer valueInteger,
      Date valueDate,
      FhirDateTime valueDateTime,
      Time valueTime,
      String valueString,
      FhirUri valueUri,
      Attachment valueAttachment,
      Coding valueCoding,
      Quantity valueQuantity,
      Reference valueReference});

  $AttachmentCopyWith<$Res> get valueAttachment;
  $CodingCopyWith<$Res> get valueCoding;
  $QuantityCopyWith<$Res> get valueQuantity;
  $ReferenceCopyWith<$Res> get valueReference;
}

class _$QuestionnaireInitialCopyWithImpl<$Res>
    implements $QuestionnaireInitialCopyWith<$Res> {
  _$QuestionnaireInitialCopyWithImpl(this._value, this._then);

  final QuestionnaireInitial _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireInitial) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object valueBoolean = freezed,
    Object valueDecimal = freezed,
    Object valueInteger = freezed,
    Object valueDate = freezed,
    Object valueDateTime = freezed,
    Object valueTime = freezed,
    Object valueString = freezed,
    Object valueUri = freezed,
    Object valueAttachment = freezed,
    Object valueCoding = freezed,
    Object valueQuantity = freezed,
    Object valueReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      valueBoolean: valueBoolean == freezed
          ? _value.valueBoolean
          : valueBoolean as Boolean,
      valueDecimal: valueDecimal == freezed
          ? _value.valueDecimal
          : valueDecimal as Decimal,
      valueInteger: valueInteger == freezed
          ? _value.valueInteger
          : valueInteger as Integer,
      valueDate: valueDate == freezed ? _value.valueDate : valueDate as Date,
      valueDateTime: valueDateTime == freezed
          ? _value.valueDateTime
          : valueDateTime as FhirDateTime,
      valueTime: valueTime == freezed ? _value.valueTime : valueTime as Time,
      valueString:
          valueString == freezed ? _value.valueString : valueString as String,
      valueUri: valueUri == freezed ? _value.valueUri : valueUri as FhirUri,
      valueAttachment: valueAttachment == freezed
          ? _value.valueAttachment
          : valueAttachment as Attachment,
      valueCoding:
          valueCoding == freezed ? _value.valueCoding : valueCoding as Coding,
      valueQuantity: valueQuantity == freezed
          ? _value.valueQuantity
          : valueQuantity as Quantity,
      valueReference: valueReference == freezed
          ? _value.valueReference
          : valueReference as Reference,
    ));
  }

  @override
  $AttachmentCopyWith<$Res> get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }
    return $AttachmentCopyWith<$Res>(_value.valueAttachment, (value) {
      return _then(_value.copyWith(valueAttachment: value));
    });
  }

  @override
  $CodingCopyWith<$Res> get valueCoding {
    if (_value.valueCoding == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.valueCoding, (value) {
      return _then(_value.copyWith(valueCoding: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.valueQuantity, (value) {
      return _then(_value.copyWith(valueQuantity: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get valueReference {
    if (_value.valueReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.valueReference, (value) {
      return _then(_value.copyWith(valueReference: value));
    });
  }
}

abstract class _$QuestionnaireInitialCopyWith<$Res>
    implements $QuestionnaireInitialCopyWith<$Res> {
  factory _$QuestionnaireInitialCopyWith(_QuestionnaireInitial value,
          $Res Function(_QuestionnaireInitial) then) =
      __$QuestionnaireInitialCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean valueBoolean,
      Decimal valueDecimal,
      Integer valueInteger,
      Date valueDate,
      FhirDateTime valueDateTime,
      Time valueTime,
      String valueString,
      FhirUri valueUri,
      Attachment valueAttachment,
      Coding valueCoding,
      Quantity valueQuantity,
      Reference valueReference});

  @override
  $AttachmentCopyWith<$Res> get valueAttachment;
  @override
  $CodingCopyWith<$Res> get valueCoding;
  @override
  $QuantityCopyWith<$Res> get valueQuantity;
  @override
  $ReferenceCopyWith<$Res> get valueReference;
}

class __$QuestionnaireInitialCopyWithImpl<$Res>
    extends _$QuestionnaireInitialCopyWithImpl<$Res>
    implements _$QuestionnaireInitialCopyWith<$Res> {
  __$QuestionnaireInitialCopyWithImpl(
      _QuestionnaireInitial _value, $Res Function(_QuestionnaireInitial) _then)
      : super(_value, (v) => _then(v as _QuestionnaireInitial));

  @override
  _QuestionnaireInitial get _value => super._value as _QuestionnaireInitial;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object valueBoolean = freezed,
    Object valueDecimal = freezed,
    Object valueInteger = freezed,
    Object valueDate = freezed,
    Object valueDateTime = freezed,
    Object valueTime = freezed,
    Object valueString = freezed,
    Object valueUri = freezed,
    Object valueAttachment = freezed,
    Object valueCoding = freezed,
    Object valueQuantity = freezed,
    Object valueReference = freezed,
  }) {
    return _then(_QuestionnaireInitial(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      valueBoolean: valueBoolean == freezed
          ? _value.valueBoolean
          : valueBoolean as Boolean,
      valueDecimal: valueDecimal == freezed
          ? _value.valueDecimal
          : valueDecimal as Decimal,
      valueInteger: valueInteger == freezed
          ? _value.valueInteger
          : valueInteger as Integer,
      valueDate: valueDate == freezed ? _value.valueDate : valueDate as Date,
      valueDateTime: valueDateTime == freezed
          ? _value.valueDateTime
          : valueDateTime as FhirDateTime,
      valueTime: valueTime == freezed ? _value.valueTime : valueTime as Time,
      valueString:
          valueString == freezed ? _value.valueString : valueString as String,
      valueUri: valueUri == freezed ? _value.valueUri : valueUri as FhirUri,
      valueAttachment: valueAttachment == freezed
          ? _value.valueAttachment
          : valueAttachment as Attachment,
      valueCoding:
          valueCoding == freezed ? _value.valueCoding : valueCoding as Coding,
      valueQuantity: valueQuantity == freezed
          ? _value.valueQuantity
          : valueQuantity as Quantity,
      valueReference: valueReference == freezed
          ? _value.valueReference
          : valueReference as Reference,
    ));
  }
}

@JsonSerializable()
class _$_QuestionnaireInitial implements _QuestionnaireInitial {
  const _$_QuestionnaireInitial(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.valueBoolean,
      this.valueDecimal,
      this.valueInteger,
      this.valueDate,
      this.valueDateTime,
      this.valueTime,
      this.valueString,
      this.valueUri,
      this.valueAttachment,
      this.valueCoding,
      this.valueQuantity,
      this.valueReference});

  factory _$_QuestionnaireInitial.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireInitialFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Boolean valueBoolean;
  @override
  final Decimal valueDecimal;
  @override
  final Integer valueInteger;
  @override
  final Date valueDate;
  @override
  final FhirDateTime valueDateTime;
  @override
  final Time valueTime;
  @override
  final String valueString;
  @override
  final FhirUri valueUri;
  @override
  final Attachment valueAttachment;
  @override
  final Coding valueCoding;
  @override
  final Quantity valueQuantity;
  @override
  final Reference valueReference;

  @override
  String toString() {
    return 'QuestionnaireInitial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, valueBoolean: $valueBoolean, valueDecimal: $valueDecimal, valueInteger: $valueInteger, valueDate: $valueDate, valueDateTime: $valueDateTime, valueTime: $valueTime, valueString: $valueString, valueUri: $valueUri, valueAttachment: $valueAttachment, valueCoding: $valueCoding, valueQuantity: $valueQuantity, valueReference: $valueReference)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireInitial &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.valueBoolean, valueBoolean) ||
                const DeepCollectionEquality()
                    .equals(other.valueBoolean, valueBoolean)) &&
            (identical(other.valueDecimal, valueDecimal) ||
                const DeepCollectionEquality()
                    .equals(other.valueDecimal, valueDecimal)) &&
            (identical(other.valueInteger, valueInteger) ||
                const DeepCollectionEquality()
                    .equals(other.valueInteger, valueInteger)) &&
            (identical(other.valueDate, valueDate) ||
                const DeepCollectionEquality()
                    .equals(other.valueDate, valueDate)) &&
            (identical(other.valueDateTime, valueDateTime) ||
                const DeepCollectionEquality()
                    .equals(other.valueDateTime, valueDateTime)) &&
            (identical(other.valueTime, valueTime) ||
                const DeepCollectionEquality()
                    .equals(other.valueTime, valueTime)) &&
            (identical(other.valueString, valueString) ||
                const DeepCollectionEquality()
                    .equals(other.valueString, valueString)) &&
            (identical(other.valueUri, valueUri) ||
                const DeepCollectionEquality()
                    .equals(other.valueUri, valueUri)) &&
            (identical(other.valueAttachment, valueAttachment) ||
                const DeepCollectionEquality()
                    .equals(other.valueAttachment, valueAttachment)) &&
            (identical(other.valueCoding, valueCoding) ||
                const DeepCollectionEquality()
                    .equals(other.valueCoding, valueCoding)) &&
            (identical(other.valueQuantity, valueQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.valueQuantity, valueQuantity)) &&
            (identical(other.valueReference, valueReference) ||
                const DeepCollectionEquality()
                    .equals(other.valueReference, valueReference)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(valueBoolean) ^
      const DeepCollectionEquality().hash(valueDecimal) ^
      const DeepCollectionEquality().hash(valueInteger) ^
      const DeepCollectionEquality().hash(valueDate) ^
      const DeepCollectionEquality().hash(valueDateTime) ^
      const DeepCollectionEquality().hash(valueTime) ^
      const DeepCollectionEquality().hash(valueString) ^
      const DeepCollectionEquality().hash(valueUri) ^
      const DeepCollectionEquality().hash(valueAttachment) ^
      const DeepCollectionEquality().hash(valueCoding) ^
      const DeepCollectionEquality().hash(valueQuantity) ^
      const DeepCollectionEquality().hash(valueReference);

  @override
  _$QuestionnaireInitialCopyWith<_QuestionnaireInitial> get copyWith =>
      __$QuestionnaireInitialCopyWithImpl<_QuestionnaireInitial>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireInitialToJson(this);
  }
}

abstract class _QuestionnaireInitial implements QuestionnaireInitial {
  const factory _QuestionnaireInitial(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean valueBoolean,
      Decimal valueDecimal,
      Integer valueInteger,
      Date valueDate,
      FhirDateTime valueDateTime,
      Time valueTime,
      String valueString,
      FhirUri valueUri,
      Attachment valueAttachment,
      Coding valueCoding,
      Quantity valueQuantity,
      Reference valueReference}) = _$_QuestionnaireInitial;

  factory _QuestionnaireInitial.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireInitial.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Boolean get valueBoolean;
  @override
  Decimal get valueDecimal;
  @override
  Integer get valueInteger;
  @override
  Date get valueDate;
  @override
  FhirDateTime get valueDateTime;
  @override
  Time get valueTime;
  @override
  String get valueString;
  @override
  FhirUri get valueUri;
  @override
  Attachment get valueAttachment;
  @override
  Coding get valueCoding;
  @override
  Quantity get valueQuantity;
  @override
  Reference get valueReference;
  @override
  _$QuestionnaireInitialCopyWith<_QuestionnaireInitial> get copyWith;
}

ResearchDefinition _$ResearchDefinitionFromJson(Map<String, dynamic> json) {
  return _ResearchDefinition.fromJson(json);
}

class _$ResearchDefinitionTearOff {
  const _$ResearchDefinitionTearOff();

  _ResearchDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
          ResearchDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @required
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      Reference exposureAlternative,
      Reference outcome}) {
    return _ResearchDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      shortTitle: shortTitle,
      subtitle: subtitle,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      comment: comment,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      library: library,
      population: population,
      exposure: exposure,
      exposureAlternative: exposureAlternative,
      outcome: outcome,
    );
  }
}

// ignore: unused_element
const $ResearchDefinition = _$ResearchDefinitionTearOff();

mixin _$ResearchDefinition {
  @JsonKey(required: true, defaultValue: 'ResearchDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get shortTitle;
  String get subtitle;
  @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
  ResearchDefinitionStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<String> get comment;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  List<Canonical> get library;
  @JsonKey(required: true)
  Reference get population;
  Reference get exposure;
  Reference get exposureAlternative;
  Reference get outcome;

  Map<String, dynamic> toJson();
  $ResearchDefinitionCopyWith<ResearchDefinition> get copyWith;
}

abstract class $ResearchDefinitionCopyWith<$Res> {
  factory $ResearchDefinitionCopyWith(
          ResearchDefinition value, $Res Function(ResearchDefinition) then) =
      _$ResearchDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
          ResearchDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      Reference exposureAlternative,
      Reference outcome});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $ReferenceCopyWith<$Res> get population;
  $ReferenceCopyWith<$Res> get exposure;
  $ReferenceCopyWith<$Res> get exposureAlternative;
  $ReferenceCopyWith<$Res> get outcome;
}

class _$ResearchDefinitionCopyWithImpl<$Res>
    implements $ResearchDefinitionCopyWith<$Res> {
  _$ResearchDefinitionCopyWithImpl(this._value, this._then);

  final ResearchDefinition _value;
  // ignore: unused_field
  final $Res Function(ResearchDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object comment = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object exposureAlternative = freezed,
    Object outcome = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ResearchDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      comment: comment == freezed ? _value.comment : comment as List<String>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      exposureAlternative: exposureAlternative == freezed
          ? _value.exposureAlternative
          : exposureAlternative as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get population {
    if (_value.population == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.population, (value) {
      return _then(_value.copyWith(population: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposure {
    if (_value.exposure == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposure, (value) {
      return _then(_value.copyWith(exposure: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposureAlternative {
    if (_value.exposureAlternative == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposureAlternative, (value) {
      return _then(_value.copyWith(exposureAlternative: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get outcome {
    if (_value.outcome == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.outcome, (value) {
      return _then(_value.copyWith(outcome: value));
    });
  }
}

abstract class _$ResearchDefinitionCopyWith<$Res>
    implements $ResearchDefinitionCopyWith<$Res> {
  factory _$ResearchDefinitionCopyWith(
          _ResearchDefinition value, $Res Function(_ResearchDefinition) then) =
      __$ResearchDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
          ResearchDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      Reference exposureAlternative,
      Reference outcome});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $ReferenceCopyWith<$Res> get population;
  @override
  $ReferenceCopyWith<$Res> get exposure;
  @override
  $ReferenceCopyWith<$Res> get exposureAlternative;
  @override
  $ReferenceCopyWith<$Res> get outcome;
}

class __$ResearchDefinitionCopyWithImpl<$Res>
    extends _$ResearchDefinitionCopyWithImpl<$Res>
    implements _$ResearchDefinitionCopyWith<$Res> {
  __$ResearchDefinitionCopyWithImpl(
      _ResearchDefinition _value, $Res Function(_ResearchDefinition) _then)
      : super(_value, (v) => _then(v as _ResearchDefinition));

  @override
  _ResearchDefinition get _value => super._value as _ResearchDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object comment = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object exposureAlternative = freezed,
    Object outcome = freezed,
  }) {
    return _then(_ResearchDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ResearchDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      comment: comment == freezed ? _value.comment : comment as List<String>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      exposureAlternative: exposureAlternative == freezed
          ? _value.exposureAlternative
          : exposureAlternative as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
    ));
  }
}

@JsonSerializable()
class _$_ResearchDefinition implements _ResearchDefinition {
  const _$_ResearchDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.shortTitle,
      this.subtitle,
      @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.comment,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.library,
      @required
      @JsonKey(required: true)
          this.population,
      this.exposure,
      this.exposureAlternative,
      this.outcome})
      : assert(resourceType != null),
        assert(population != null);

  factory _$_ResearchDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ResearchDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String shortTitle;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
  final ResearchDefinitionStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<String> comment;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<Canonical> library;
  @override
  @JsonKey(required: true)
  final Reference population;
  @override
  final Reference exposure;
  @override
  final Reference exposureAlternative;
  @override
  final Reference outcome;

  @override
  String toString() {
    return 'ResearchDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, shortTitle: $shortTitle, subtitle: $subtitle, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, comment: $comment, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, library: $library, population: $population, exposure: $exposure, exposureAlternative: $exposureAlternative, outcome: $outcome)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.shortTitle, shortTitle) ||
                const DeepCollectionEquality()
                    .equals(other.shortTitle, shortTitle)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.useContext, useContext) || const DeepCollectionEquality().equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) || const DeepCollectionEquality().equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.library, library) || const DeepCollectionEquality().equals(other.library, library)) &&
            (identical(other.population, population) || const DeepCollectionEquality().equals(other.population, population)) &&
            (identical(other.exposure, exposure) || const DeepCollectionEquality().equals(other.exposure, exposure)) &&
            (identical(other.exposureAlternative, exposureAlternative) || const DeepCollectionEquality().equals(other.exposureAlternative, exposureAlternative)) &&
            (identical(other.outcome, outcome) || const DeepCollectionEquality().equals(other.outcome, outcome)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(shortTitle) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(library) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(exposure) ^
      const DeepCollectionEquality().hash(exposureAlternative) ^
      const DeepCollectionEquality().hash(outcome);

  @override
  _$ResearchDefinitionCopyWith<_ResearchDefinition> get copyWith =>
      __$ResearchDefinitionCopyWithImpl<_ResearchDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchDefinitionToJson(this);
  }
}

abstract class _ResearchDefinition implements ResearchDefinition {
  const factory _ResearchDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
          ResearchDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @required
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      Reference exposureAlternative,
      Reference outcome}) = _$_ResearchDefinition;

  factory _ResearchDefinition.fromJson(Map<String, dynamic> json) =
      _$_ResearchDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ResearchDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get shortTitle;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: ResearchDefinitionStatus.unknown)
  ResearchDefinitionStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<String> get comment;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<Canonical> get library;
  @override
  @JsonKey(required: true)
  Reference get population;
  @override
  Reference get exposure;
  @override
  Reference get exposureAlternative;
  @override
  Reference get outcome;
  @override
  _$ResearchDefinitionCopyWith<_ResearchDefinition> get copyWith;
}

ResearchElementDefinition _$ResearchElementDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ResearchElementDefinition.fromJson(json);
}

class _$ResearchElementDefinitionTearOff {
  const _$ResearchElementDefinitionTearOff();

  _ResearchElementDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
          ResearchElementDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
          ResearchElementDefinitionType type,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
          ResearchElementDefinitionVariableType variableType,
      @required
      @JsonKey(required: true)
          List<ResearchElementDefinitionCharacteristic> characteristic}) {
    return _ResearchElementDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      shortTitle: shortTitle,
      subtitle: subtitle,
      status: status,
      experimental: experimental,
      subjectCodeableConcept: subjectCodeableConcept,
      subjectReference: subjectReference,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      comment: comment,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      usage: usage,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      library: library,
      type: type,
      variableType: variableType,
      characteristic: characteristic,
    );
  }
}

// ignore: unused_element
const $ResearchElementDefinition = _$ResearchElementDefinitionTearOff();

mixin _$ResearchElementDefinition {
  @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  String get shortTitle;
  String get subtitle;
  @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
  ResearchElementDefinitionStatus get status;
  Boolean get experimental;
  CodeableConcept get subjectCodeableConcept;
  Reference get subjectReference;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<String> get comment;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  String get usage;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  List<Canonical> get library;
  @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
  ResearchElementDefinitionType get type;
  @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
  ResearchElementDefinitionVariableType get variableType;
  @JsonKey(required: true)
  List<ResearchElementDefinitionCharacteristic> get characteristic;

  Map<String, dynamic> toJson();
  $ResearchElementDefinitionCopyWith<ResearchElementDefinition> get copyWith;
}

abstract class $ResearchElementDefinitionCopyWith<$Res> {
  factory $ResearchElementDefinitionCopyWith(ResearchElementDefinition value,
          $Res Function(ResearchElementDefinition) then) =
      _$ResearchElementDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
          ResearchElementDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
          ResearchElementDefinitionType type,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
          ResearchElementDefinitionVariableType variableType,
      @JsonKey(required: true)
          List<ResearchElementDefinitionCharacteristic> characteristic});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  $ReferenceCopyWith<$Res> get subjectReference;
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class _$ResearchElementDefinitionCopyWithImpl<$Res>
    implements $ResearchElementDefinitionCopyWith<$Res> {
  _$ResearchElementDefinitionCopyWithImpl(this._value, this._then);

  final ResearchElementDefinition _value;
  // ignore: unused_field
  final $Res Function(ResearchElementDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object comment = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object type = freezed,
    Object variableType = freezed,
    Object characteristic = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ResearchElementDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      comment: comment == freezed ? _value.comment : comment as List<String>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      type:
          type == freezed ? _value.type : type as ResearchElementDefinitionType,
      variableType: variableType == freezed
          ? _value.variableType
          : variableType as ResearchElementDefinitionVariableType,
      characteristic: characteristic == freezed
          ? _value.characteristic
          : characteristic as List<ResearchElementDefinitionCharacteristic>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept {
    if (_value.subjectCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.subjectCodeableConcept,
        (value) {
      return _then(_value.copyWith(subjectCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get subjectReference {
    if (_value.subjectReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.subjectReference, (value) {
      return _then(_value.copyWith(subjectReference: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }
}

abstract class _$ResearchElementDefinitionCopyWith<$Res>
    implements $ResearchElementDefinitionCopyWith<$Res> {
  factory _$ResearchElementDefinitionCopyWith(_ResearchElementDefinition value,
          $Res Function(_ResearchElementDefinition) then) =
      __$ResearchElementDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
          ResearchElementDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
          ResearchElementDefinitionType type,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
          ResearchElementDefinitionVariableType variableType,
      @JsonKey(required: true)
          List<ResearchElementDefinitionCharacteristic> characteristic});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get subjectCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get subjectReference;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
}

class __$ResearchElementDefinitionCopyWithImpl<$Res>
    extends _$ResearchElementDefinitionCopyWithImpl<$Res>
    implements _$ResearchElementDefinitionCopyWith<$Res> {
  __$ResearchElementDefinitionCopyWithImpl(_ResearchElementDefinition _value,
      $Res Function(_ResearchElementDefinition) _then)
      : super(_value, (v) => _then(v as _ResearchElementDefinition));

  @override
  _ResearchElementDefinition get _value =>
      super._value as _ResearchElementDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object shortTitle = freezed,
    Object subtitle = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object subjectCodeableConcept = freezed,
    Object subjectReference = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object comment = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object usage = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object library = freezed,
    Object type = freezed,
    Object variableType = freezed,
    Object characteristic = freezed,
  }) {
    return _then(_ResearchElementDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      shortTitle:
          shortTitle == freezed ? _value.shortTitle : shortTitle as String,
      subtitle: subtitle == freezed ? _value.subtitle : subtitle as String,
      status: status == freezed
          ? _value.status
          : status as ResearchElementDefinitionStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      subjectCodeableConcept: subjectCodeableConcept == freezed
          ? _value.subjectCodeableConcept
          : subjectCodeableConcept as CodeableConcept,
      subjectReference: subjectReference == freezed
          ? _value.subjectReference
          : subjectReference as Reference,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      comment: comment == freezed ? _value.comment : comment as List<String>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      usage: usage == freezed ? _value.usage : usage as String,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      library: library == freezed ? _value.library : library as List<Canonical>,
      type:
          type == freezed ? _value.type : type as ResearchElementDefinitionType,
      variableType: variableType == freezed
          ? _value.variableType
          : variableType as ResearchElementDefinitionVariableType,
      characteristic: characteristic == freezed
          ? _value.characteristic
          : characteristic as List<ResearchElementDefinitionCharacteristic>,
    ));
  }
}

@JsonSerializable()
class _$_ResearchElementDefinition implements _ResearchElementDefinition {
  const _$_ResearchElementDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      this.shortTitle,
      this.subtitle,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
          this.status,
      this.experimental,
      this.subjectCodeableConcept,
      this.subjectReference,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.comment,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.usage,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.library,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
          this.type,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
          this.variableType,
      @required
      @JsonKey(required: true)
          this.characteristic})
      : assert(resourceType != null),
        assert(characteristic != null);

  factory _$_ResearchElementDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchElementDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  final String shortTitle;
  @override
  final String subtitle;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
  final ResearchElementDefinitionStatus status;
  @override
  final Boolean experimental;
  @override
  final CodeableConcept subjectCodeableConcept;
  @override
  final Reference subjectReference;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<String> comment;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final String usage;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<Canonical> library;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
  final ResearchElementDefinitionType type;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
  final ResearchElementDefinitionVariableType variableType;
  @override
  @JsonKey(required: true)
  final List<ResearchElementDefinitionCharacteristic> characteristic;

  @override
  String toString() {
    return 'ResearchElementDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, shortTitle: $shortTitle, subtitle: $subtitle, status: $status, experimental: $experimental, subjectCodeableConcept: $subjectCodeableConcept, subjectReference: $subjectReference, date: $date, publisher: $publisher, contact: $contact, description: $description, comment: $comment, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, usage: $usage, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, library: $library, type: $type, variableType: $variableType, characteristic: $characteristic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchElementDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.shortTitle, shortTitle) ||
                const DeepCollectionEquality()
                    .equals(other.shortTitle, shortTitle)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.subjectCodeableConcept, subjectCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.subjectCodeableConcept, subjectCodeableConcept)) &&
            (identical(other.subjectReference, subjectReference) ||
                const DeepCollectionEquality()
                    .equals(other.subjectReference, subjectReference)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.useContext, useContext) || const DeepCollectionEquality().equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) || const DeepCollectionEquality().equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) || const DeepCollectionEquality().equals(other.purpose, purpose)) &&
            (identical(other.usage, usage) || const DeepCollectionEquality().equals(other.usage, usage)) &&
            (identical(other.copyright, copyright) || const DeepCollectionEquality().equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) || const DeepCollectionEquality().equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) || const DeepCollectionEquality().equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) || const DeepCollectionEquality().equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.library, library) || const DeepCollectionEquality().equals(other.library, library)) &&
            (identical(other.type, type) || const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.variableType, variableType) || const DeepCollectionEquality().equals(other.variableType, variableType)) &&
            (identical(other.characteristic, characteristic) || const DeepCollectionEquality().equals(other.characteristic, characteristic)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(shortTitle) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(subjectCodeableConcept) ^
      const DeepCollectionEquality().hash(subjectReference) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(usage) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(library) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(variableType) ^
      const DeepCollectionEquality().hash(characteristic);

  @override
  _$ResearchElementDefinitionCopyWith<_ResearchElementDefinition>
      get copyWith =>
          __$ResearchElementDefinitionCopyWithImpl<_ResearchElementDefinition>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchElementDefinitionToJson(this);
  }
}

abstract class _ResearchElementDefinition implements ResearchElementDefinition {
  const factory _ResearchElementDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      String shortTitle,
      String subtitle,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
          ResearchElementDefinitionStatus status,
      Boolean experimental,
      CodeableConcept subjectCodeableConcept,
      Reference subjectReference,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<String> comment,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      String usage,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      List<Canonical> library,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
          ResearchElementDefinitionType type,
      @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
          ResearchElementDefinitionVariableType variableType,
      @required
      @JsonKey(required: true)
          List<ResearchElementDefinitionCharacteristic>
              characteristic}) = _$_ResearchElementDefinition;

  factory _ResearchElementDefinition.fromJson(Map<String, dynamic> json) =
      _$_ResearchElementDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ResearchElementDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  String get shortTitle;
  @override
  String get subtitle;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionStatus.unknown)
  ResearchElementDefinitionStatus get status;
  @override
  Boolean get experimental;
  @override
  CodeableConcept get subjectCodeableConcept;
  @override
  Reference get subjectReference;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<String> get comment;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  String get usage;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<Canonical> get library;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionType.unknown)
  ResearchElementDefinitionType get type;
  @override
  @JsonKey(unknownEnumValue: ResearchElementDefinitionVariableType.unknown)
  ResearchElementDefinitionVariableType get variableType;
  @override
  @JsonKey(required: true)
  List<ResearchElementDefinitionCharacteristic> get characteristic;
  @override
  _$ResearchElementDefinitionCopyWith<_ResearchElementDefinition> get copyWith;
}

ResearchElementDefinitionCharacteristic
    _$ResearchElementDefinitionCharacteristicFromJson(
        Map<String, dynamic> json) {
  return _ResearchElementDefinitionCharacteristic.fromJson(json);
}

class _$ResearchElementDefinitionCharacteristicTearOff {
  const _$ResearchElementDefinitionCharacteristicTearOff();

  _ResearchElementDefinitionCharacteristic
      call(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept definitionCodeableConcept,
          Canonical definitionCanonical,
          Expression definitionExpression,
          DataRequirement definitionDataRequirement,
          List<UsageContext> usageContext,
          Boolean exclude,
          CodeableConcept unitOfMeasure,
          String studyEffectiveDescription,
          FhirDateTime studyEffectiveDateTime,
          Period studyEffectivePeriod,
          Duration studyEffectiveDuration,
          Timing studyEffectiveTiming,
          Duration studyEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicStudyEffectiveGroupMeasure.unknown)
              CharacteristicStudyEffectiveGroupMeasure
                  studyEffectiveGroupMeasure,
          String participantEffectiveDescription,
          FhirDateTime participantEffectiveDateTime,
          Period participantEffectivePeriod,
          Duration participantEffectiveDuration,
          Timing participantEffectiveTiming,
          Duration participantEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicParticipantEffectiveGroupMeasure.unknown)
              CharacteristicParticipantEffectiveGroupMeasure
                  participantEffectiveGroupMeasure}) {
    return _ResearchElementDefinitionCharacteristic(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      definitionCodeableConcept: definitionCodeableConcept,
      definitionCanonical: definitionCanonical,
      definitionExpression: definitionExpression,
      definitionDataRequirement: definitionDataRequirement,
      usageContext: usageContext,
      exclude: exclude,
      unitOfMeasure: unitOfMeasure,
      studyEffectiveDescription: studyEffectiveDescription,
      studyEffectiveDateTime: studyEffectiveDateTime,
      studyEffectivePeriod: studyEffectivePeriod,
      studyEffectiveDuration: studyEffectiveDuration,
      studyEffectiveTiming: studyEffectiveTiming,
      studyEffectiveTimeFromStart: studyEffectiveTimeFromStart,
      studyEffectiveGroupMeasure: studyEffectiveGroupMeasure,
      participantEffectiveDescription: participantEffectiveDescription,
      participantEffectiveDateTime: participantEffectiveDateTime,
      participantEffectivePeriod: participantEffectivePeriod,
      participantEffectiveDuration: participantEffectiveDuration,
      participantEffectiveTiming: participantEffectiveTiming,
      participantEffectiveTimeFromStart: participantEffectiveTimeFromStart,
      participantEffectiveGroupMeasure: participantEffectiveGroupMeasure,
    );
  }
}

// ignore: unused_element
const $ResearchElementDefinitionCharacteristic =
    _$ResearchElementDefinitionCharacteristicTearOff();

mixin _$ResearchElementDefinitionCharacteristic {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get definitionCodeableConcept;
  Canonical get definitionCanonical;
  Expression get definitionExpression;
  DataRequirement get definitionDataRequirement;
  List<UsageContext> get usageContext;
  Boolean get exclude;
  CodeableConcept get unitOfMeasure;
  String get studyEffectiveDescription;
  FhirDateTime get studyEffectiveDateTime;
  Period get studyEffectivePeriod;
  Duration get studyEffectiveDuration;
  Timing get studyEffectiveTiming;
  Duration get studyEffectiveTimeFromStart;
  @JsonKey(unknownEnumValue: CharacteristicStudyEffectiveGroupMeasure.unknown)
  CharacteristicStudyEffectiveGroupMeasure get studyEffectiveGroupMeasure;
  String get participantEffectiveDescription;
  FhirDateTime get participantEffectiveDateTime;
  Period get participantEffectivePeriod;
  Duration get participantEffectiveDuration;
  Timing get participantEffectiveTiming;
  Duration get participantEffectiveTimeFromStart;
  @JsonKey(
      unknownEnumValue: CharacteristicParticipantEffectiveGroupMeasure.unknown)
  CharacteristicParticipantEffectiveGroupMeasure
      get participantEffectiveGroupMeasure;

  Map<String, dynamic> toJson();
  $ResearchElementDefinitionCharacteristicCopyWith<
      ResearchElementDefinitionCharacteristic> get copyWith;
}

abstract class $ResearchElementDefinitionCharacteristicCopyWith<$Res> {
  factory $ResearchElementDefinitionCharacteristicCopyWith(
          ResearchElementDefinitionCharacteristic value,
          $Res Function(ResearchElementDefinitionCharacteristic) then) =
      _$ResearchElementDefinitionCharacteristicCopyWithImpl<$Res>;
  $Res
      call(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept definitionCodeableConcept,
          Canonical definitionCanonical,
          Expression definitionExpression,
          DataRequirement definitionDataRequirement,
          List<UsageContext> usageContext,
          Boolean exclude,
          CodeableConcept unitOfMeasure,
          String studyEffectiveDescription,
          FhirDateTime studyEffectiveDateTime,
          Period studyEffectivePeriod,
          Duration studyEffectiveDuration,
          Timing studyEffectiveTiming,
          Duration studyEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicStudyEffectiveGroupMeasure.unknown)
              CharacteristicStudyEffectiveGroupMeasure
                  studyEffectiveGroupMeasure,
          String participantEffectiveDescription,
          FhirDateTime participantEffectiveDateTime,
          Period participantEffectivePeriod,
          Duration participantEffectiveDuration,
          Timing participantEffectiveTiming,
          Duration participantEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicParticipantEffectiveGroupMeasure.unknown)
              CharacteristicParticipantEffectiveGroupMeasure
                  participantEffectiveGroupMeasure});

  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept;
  $ExpressionCopyWith<$Res> get definitionExpression;
  $DataRequirementCopyWith<$Res> get definitionDataRequirement;
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
  $PeriodCopyWith<$Res> get studyEffectivePeriod;
  $DurationCopyWith<$Res> get studyEffectiveDuration;
  $TimingCopyWith<$Res> get studyEffectiveTiming;
  $DurationCopyWith<$Res> get studyEffectiveTimeFromStart;
  $PeriodCopyWith<$Res> get participantEffectivePeriod;
  $DurationCopyWith<$Res> get participantEffectiveDuration;
  $TimingCopyWith<$Res> get participantEffectiveTiming;
  $DurationCopyWith<$Res> get participantEffectiveTimeFromStart;
}

class _$ResearchElementDefinitionCharacteristicCopyWithImpl<$Res>
    implements $ResearchElementDefinitionCharacteristicCopyWith<$Res> {
  _$ResearchElementDefinitionCharacteristicCopyWithImpl(
      this._value, this._then);

  final ResearchElementDefinitionCharacteristic _value;
  // ignore: unused_field
  final $Res Function(ResearchElementDefinitionCharacteristic) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object definitionCodeableConcept = freezed,
    Object definitionCanonical = freezed,
    Object definitionExpression = freezed,
    Object definitionDataRequirement = freezed,
    Object usageContext = freezed,
    Object exclude = freezed,
    Object unitOfMeasure = freezed,
    Object studyEffectiveDescription = freezed,
    Object studyEffectiveDateTime = freezed,
    Object studyEffectivePeriod = freezed,
    Object studyEffectiveDuration = freezed,
    Object studyEffectiveTiming = freezed,
    Object studyEffectiveTimeFromStart = freezed,
    Object studyEffectiveGroupMeasure = freezed,
    Object participantEffectiveDescription = freezed,
    Object participantEffectiveDateTime = freezed,
    Object participantEffectivePeriod = freezed,
    Object participantEffectiveDuration = freezed,
    Object participantEffectiveTiming = freezed,
    Object participantEffectiveTimeFromStart = freezed,
    Object participantEffectiveGroupMeasure = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      definitionCodeableConcept: definitionCodeableConcept == freezed
          ? _value.definitionCodeableConcept
          : definitionCodeableConcept as CodeableConcept,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionExpression: definitionExpression == freezed
          ? _value.definitionExpression
          : definitionExpression as Expression,
      definitionDataRequirement: definitionDataRequirement == freezed
          ? _value.definitionDataRequirement
          : definitionDataRequirement as DataRequirement,
      usageContext: usageContext == freezed
          ? _value.usageContext
          : usageContext as List<UsageContext>,
      exclude: exclude == freezed ? _value.exclude : exclude as Boolean,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      studyEffectiveDescription: studyEffectiveDescription == freezed
          ? _value.studyEffectiveDescription
          : studyEffectiveDescription as String,
      studyEffectiveDateTime: studyEffectiveDateTime == freezed
          ? _value.studyEffectiveDateTime
          : studyEffectiveDateTime as FhirDateTime,
      studyEffectivePeriod: studyEffectivePeriod == freezed
          ? _value.studyEffectivePeriod
          : studyEffectivePeriod as Period,
      studyEffectiveDuration: studyEffectiveDuration == freezed
          ? _value.studyEffectiveDuration
          : studyEffectiveDuration as Duration,
      studyEffectiveTiming: studyEffectiveTiming == freezed
          ? _value.studyEffectiveTiming
          : studyEffectiveTiming as Timing,
      studyEffectiveTimeFromStart: studyEffectiveTimeFromStart == freezed
          ? _value.studyEffectiveTimeFromStart
          : studyEffectiveTimeFromStart as Duration,
      studyEffectiveGroupMeasure: studyEffectiveGroupMeasure == freezed
          ? _value.studyEffectiveGroupMeasure
          : studyEffectiveGroupMeasure
              as CharacteristicStudyEffectiveGroupMeasure,
      participantEffectiveDescription:
          participantEffectiveDescription == freezed
              ? _value.participantEffectiveDescription
              : participantEffectiveDescription as String,
      participantEffectiveDateTime: participantEffectiveDateTime == freezed
          ? _value.participantEffectiveDateTime
          : participantEffectiveDateTime as FhirDateTime,
      participantEffectivePeriod: participantEffectivePeriod == freezed
          ? _value.participantEffectivePeriod
          : participantEffectivePeriod as Period,
      participantEffectiveDuration: participantEffectiveDuration == freezed
          ? _value.participantEffectiveDuration
          : participantEffectiveDuration as Duration,
      participantEffectiveTiming: participantEffectiveTiming == freezed
          ? _value.participantEffectiveTiming
          : participantEffectiveTiming as Timing,
      participantEffectiveTimeFromStart:
          participantEffectiveTimeFromStart == freezed
              ? _value.participantEffectiveTimeFromStart
              : participantEffectiveTimeFromStart as Duration,
      participantEffectiveGroupMeasure:
          participantEffectiveGroupMeasure == freezed
              ? _value.participantEffectiveGroupMeasure
              : participantEffectiveGroupMeasure
                  as CharacteristicParticipantEffectiveGroupMeasure,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept {
    if (_value.definitionCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.definitionCodeableConcept,
        (value) {
      return _then(_value.copyWith(definitionCodeableConcept: value));
    });
  }

  @override
  $ExpressionCopyWith<$Res> get definitionExpression {
    if (_value.definitionExpression == null) {
      return null;
    }
    return $ExpressionCopyWith<$Res>(_value.definitionExpression, (value) {
      return _then(_value.copyWith(definitionExpression: value));
    });
  }

  @override
  $DataRequirementCopyWith<$Res> get definitionDataRequirement {
    if (_value.definitionDataRequirement == null) {
      return null;
    }
    return $DataRequirementCopyWith<$Res>(_value.definitionDataRequirement,
        (value) {
      return _then(_value.copyWith(definitionDataRequirement: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure {
    if (_value.unitOfMeasure == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unitOfMeasure, (value) {
      return _then(_value.copyWith(unitOfMeasure: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get studyEffectivePeriod {
    if (_value.studyEffectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.studyEffectivePeriod, (value) {
      return _then(_value.copyWith(studyEffectivePeriod: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get studyEffectiveDuration {
    if (_value.studyEffectiveDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.studyEffectiveDuration, (value) {
      return _then(_value.copyWith(studyEffectiveDuration: value));
    });
  }

  @override
  $TimingCopyWith<$Res> get studyEffectiveTiming {
    if (_value.studyEffectiveTiming == null) {
      return null;
    }
    return $TimingCopyWith<$Res>(_value.studyEffectiveTiming, (value) {
      return _then(_value.copyWith(studyEffectiveTiming: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get studyEffectiveTimeFromStart {
    if (_value.studyEffectiveTimeFromStart == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.studyEffectiveTimeFromStart, (value) {
      return _then(_value.copyWith(studyEffectiveTimeFromStart: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get participantEffectivePeriod {
    if (_value.participantEffectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.participantEffectivePeriod, (value) {
      return _then(_value.copyWith(participantEffectivePeriod: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get participantEffectiveDuration {
    if (_value.participantEffectiveDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.participantEffectiveDuration,
        (value) {
      return _then(_value.copyWith(participantEffectiveDuration: value));
    });
  }

  @override
  $TimingCopyWith<$Res> get participantEffectiveTiming {
    if (_value.participantEffectiveTiming == null) {
      return null;
    }
    return $TimingCopyWith<$Res>(_value.participantEffectiveTiming, (value) {
      return _then(_value.copyWith(participantEffectiveTiming: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get participantEffectiveTimeFromStart {
    if (_value.participantEffectiveTimeFromStart == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.participantEffectiveTimeFromStart,
        (value) {
      return _then(_value.copyWith(participantEffectiveTimeFromStart: value));
    });
  }
}

abstract class _$ResearchElementDefinitionCharacteristicCopyWith<$Res>
    implements $ResearchElementDefinitionCharacteristicCopyWith<$Res> {
  factory _$ResearchElementDefinitionCharacteristicCopyWith(
          _ResearchElementDefinitionCharacteristic value,
          $Res Function(_ResearchElementDefinitionCharacteristic) then) =
      __$ResearchElementDefinitionCharacteristicCopyWithImpl<$Res>;
  @override
  $Res
      call(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept definitionCodeableConcept,
          Canonical definitionCanonical,
          Expression definitionExpression,
          DataRequirement definitionDataRequirement,
          List<UsageContext> usageContext,
          Boolean exclude,
          CodeableConcept unitOfMeasure,
          String studyEffectiveDescription,
          FhirDateTime studyEffectiveDateTime,
          Period studyEffectivePeriod,
          Duration studyEffectiveDuration,
          Timing studyEffectiveTiming,
          Duration studyEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicStudyEffectiveGroupMeasure.unknown)
              CharacteristicStudyEffectiveGroupMeasure
                  studyEffectiveGroupMeasure,
          String participantEffectiveDescription,
          FhirDateTime participantEffectiveDateTime,
          Period participantEffectivePeriod,
          Duration participantEffectiveDuration,
          Timing participantEffectiveTiming,
          Duration participantEffectiveTimeFromStart,
          @JsonKey(
              unknownEnumValue:
                  CharacteristicParticipantEffectiveGroupMeasure.unknown)
              CharacteristicParticipantEffectiveGroupMeasure
                  participantEffectiveGroupMeasure});

  @override
  $CodeableConceptCopyWith<$Res> get definitionCodeableConcept;
  @override
  $ExpressionCopyWith<$Res> get definitionExpression;
  @override
  $DataRequirementCopyWith<$Res> get definitionDataRequirement;
  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
  @override
  $PeriodCopyWith<$Res> get studyEffectivePeriod;
  @override
  $DurationCopyWith<$Res> get studyEffectiveDuration;
  @override
  $TimingCopyWith<$Res> get studyEffectiveTiming;
  @override
  $DurationCopyWith<$Res> get studyEffectiveTimeFromStart;
  @override
  $PeriodCopyWith<$Res> get participantEffectivePeriod;
  @override
  $DurationCopyWith<$Res> get participantEffectiveDuration;
  @override
  $TimingCopyWith<$Res> get participantEffectiveTiming;
  @override
  $DurationCopyWith<$Res> get participantEffectiveTimeFromStart;
}

class __$ResearchElementDefinitionCharacteristicCopyWithImpl<$Res>
    extends _$ResearchElementDefinitionCharacteristicCopyWithImpl<$Res>
    implements _$ResearchElementDefinitionCharacteristicCopyWith<$Res> {
  __$ResearchElementDefinitionCharacteristicCopyWithImpl(
      _ResearchElementDefinitionCharacteristic _value,
      $Res Function(_ResearchElementDefinitionCharacteristic) _then)
      : super(_value,
            (v) => _then(v as _ResearchElementDefinitionCharacteristic));

  @override
  _ResearchElementDefinitionCharacteristic get _value =>
      super._value as _ResearchElementDefinitionCharacteristic;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object definitionCodeableConcept = freezed,
    Object definitionCanonical = freezed,
    Object definitionExpression = freezed,
    Object definitionDataRequirement = freezed,
    Object usageContext = freezed,
    Object exclude = freezed,
    Object unitOfMeasure = freezed,
    Object studyEffectiveDescription = freezed,
    Object studyEffectiveDateTime = freezed,
    Object studyEffectivePeriod = freezed,
    Object studyEffectiveDuration = freezed,
    Object studyEffectiveTiming = freezed,
    Object studyEffectiveTimeFromStart = freezed,
    Object studyEffectiveGroupMeasure = freezed,
    Object participantEffectiveDescription = freezed,
    Object participantEffectiveDateTime = freezed,
    Object participantEffectivePeriod = freezed,
    Object participantEffectiveDuration = freezed,
    Object participantEffectiveTiming = freezed,
    Object participantEffectiveTimeFromStart = freezed,
    Object participantEffectiveGroupMeasure = freezed,
  }) {
    return _then(_ResearchElementDefinitionCharacteristic(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      definitionCodeableConcept: definitionCodeableConcept == freezed
          ? _value.definitionCodeableConcept
          : definitionCodeableConcept as CodeableConcept,
      definitionCanonical: definitionCanonical == freezed
          ? _value.definitionCanonical
          : definitionCanonical as Canonical,
      definitionExpression: definitionExpression == freezed
          ? _value.definitionExpression
          : definitionExpression as Expression,
      definitionDataRequirement: definitionDataRequirement == freezed
          ? _value.definitionDataRequirement
          : definitionDataRequirement as DataRequirement,
      usageContext: usageContext == freezed
          ? _value.usageContext
          : usageContext as List<UsageContext>,
      exclude: exclude == freezed ? _value.exclude : exclude as Boolean,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      studyEffectiveDescription: studyEffectiveDescription == freezed
          ? _value.studyEffectiveDescription
          : studyEffectiveDescription as String,
      studyEffectiveDateTime: studyEffectiveDateTime == freezed
          ? _value.studyEffectiveDateTime
          : studyEffectiveDateTime as FhirDateTime,
      studyEffectivePeriod: studyEffectivePeriod == freezed
          ? _value.studyEffectivePeriod
          : studyEffectivePeriod as Period,
      studyEffectiveDuration: studyEffectiveDuration == freezed
          ? _value.studyEffectiveDuration
          : studyEffectiveDuration as Duration,
      studyEffectiveTiming: studyEffectiveTiming == freezed
          ? _value.studyEffectiveTiming
          : studyEffectiveTiming as Timing,
      studyEffectiveTimeFromStart: studyEffectiveTimeFromStart == freezed
          ? _value.studyEffectiveTimeFromStart
          : studyEffectiveTimeFromStart as Duration,
      studyEffectiveGroupMeasure: studyEffectiveGroupMeasure == freezed
          ? _value.studyEffectiveGroupMeasure
          : studyEffectiveGroupMeasure
              as CharacteristicStudyEffectiveGroupMeasure,
      participantEffectiveDescription:
          participantEffectiveDescription == freezed
              ? _value.participantEffectiveDescription
              : participantEffectiveDescription as String,
      participantEffectiveDateTime: participantEffectiveDateTime == freezed
          ? _value.participantEffectiveDateTime
          : participantEffectiveDateTime as FhirDateTime,
      participantEffectivePeriod: participantEffectivePeriod == freezed
          ? _value.participantEffectivePeriod
          : participantEffectivePeriod as Period,
      participantEffectiveDuration: participantEffectiveDuration == freezed
          ? _value.participantEffectiveDuration
          : participantEffectiveDuration as Duration,
      participantEffectiveTiming: participantEffectiveTiming == freezed
          ? _value.participantEffectiveTiming
          : participantEffectiveTiming as Timing,
      participantEffectiveTimeFromStart:
          participantEffectiveTimeFromStart == freezed
              ? _value.participantEffectiveTimeFromStart
              : participantEffectiveTimeFromStart as Duration,
      participantEffectiveGroupMeasure:
          participantEffectiveGroupMeasure == freezed
              ? _value.participantEffectiveGroupMeasure
              : participantEffectiveGroupMeasure
                  as CharacteristicParticipantEffectiveGroupMeasure,
    ));
  }
}

@JsonSerializable()
class _$_ResearchElementDefinitionCharacteristic
    implements _ResearchElementDefinitionCharacteristic {
  const _$_ResearchElementDefinitionCharacteristic(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.definitionCodeableConcept,
      this.definitionCanonical,
      this.definitionExpression,
      this.definitionDataRequirement,
      this.usageContext,
      this.exclude,
      this.unitOfMeasure,
      this.studyEffectiveDescription,
      this.studyEffectiveDateTime,
      this.studyEffectivePeriod,
      this.studyEffectiveDuration,
      this.studyEffectiveTiming,
      this.studyEffectiveTimeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicStudyEffectiveGroupMeasure.unknown)
          this.studyEffectiveGroupMeasure,
      this.participantEffectiveDescription,
      this.participantEffectiveDateTime,
      this.participantEffectivePeriod,
      this.participantEffectiveDuration,
      this.participantEffectiveTiming,
      this.participantEffectiveTimeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicParticipantEffectiveGroupMeasure.unknown)
          this.participantEffectiveGroupMeasure});

  factory _$_ResearchElementDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =>
      _$_$_ResearchElementDefinitionCharacteristicFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept definitionCodeableConcept;
  @override
  final Canonical definitionCanonical;
  @override
  final Expression definitionExpression;
  @override
  final DataRequirement definitionDataRequirement;
  @override
  final List<UsageContext> usageContext;
  @override
  final Boolean exclude;
  @override
  final CodeableConcept unitOfMeasure;
  @override
  final String studyEffectiveDescription;
  @override
  final FhirDateTime studyEffectiveDateTime;
  @override
  final Period studyEffectivePeriod;
  @override
  final Duration studyEffectiveDuration;
  @override
  final Timing studyEffectiveTiming;
  @override
  final Duration studyEffectiveTimeFromStart;
  @override
  @JsonKey(unknownEnumValue: CharacteristicStudyEffectiveGroupMeasure.unknown)
  final CharacteristicStudyEffectiveGroupMeasure studyEffectiveGroupMeasure;
  @override
  final String participantEffectiveDescription;
  @override
  final FhirDateTime participantEffectiveDateTime;
  @override
  final Period participantEffectivePeriod;
  @override
  final Duration participantEffectiveDuration;
  @override
  final Timing participantEffectiveTiming;
  @override
  final Duration participantEffectiveTimeFromStart;
  @override
  @JsonKey(
      unknownEnumValue: CharacteristicParticipantEffectiveGroupMeasure.unknown)
  final CharacteristicParticipantEffectiveGroupMeasure
      participantEffectiveGroupMeasure;

  @override
  String toString() {
    return 'ResearchElementDefinitionCharacteristic(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, definitionCodeableConcept: $definitionCodeableConcept, definitionCanonical: $definitionCanonical, definitionExpression: $definitionExpression, definitionDataRequirement: $definitionDataRequirement, usageContext: $usageContext, exclude: $exclude, unitOfMeasure: $unitOfMeasure, studyEffectiveDescription: $studyEffectiveDescription, studyEffectiveDateTime: $studyEffectiveDateTime, studyEffectivePeriod: $studyEffectivePeriod, studyEffectiveDuration: $studyEffectiveDuration, studyEffectiveTiming: $studyEffectiveTiming, studyEffectiveTimeFromStart: $studyEffectiveTimeFromStart, studyEffectiveGroupMeasure: $studyEffectiveGroupMeasure, participantEffectiveDescription: $participantEffectiveDescription, participantEffectiveDateTime: $participantEffectiveDateTime, participantEffectivePeriod: $participantEffectivePeriod, participantEffectiveDuration: $participantEffectiveDuration, participantEffectiveTiming: $participantEffectiveTiming, participantEffectiveTimeFromStart: $participantEffectiveTimeFromStart, participantEffectiveGroupMeasure: $participantEffectiveGroupMeasure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchElementDefinitionCharacteristic &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.definitionCodeableConcept, definitionCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.definitionCodeableConcept,
                    definitionCodeableConcept)) &&
            (identical(other.definitionCanonical, definitionCanonical) ||
                const DeepCollectionEquality()
                    .equals(other.definitionCanonical, definitionCanonical)) &&
            (identical(other.definitionExpression, definitionExpression) ||
                const DeepCollectionEquality().equals(
                    other.definitionExpression, definitionExpression)) &&
            (identical(other.definitionDataRequirement, definitionDataRequirement) ||
                const DeepCollectionEquality().equals(
                    other.definitionDataRequirement,
                    definitionDataRequirement)) &&
            (identical(other.usageContext, usageContext) ||
                const DeepCollectionEquality()
                    .equals(other.usageContext, usageContext)) &&
            (identical(other.exclude, exclude) ||
                const DeepCollectionEquality()
                    .equals(other.exclude, exclude)) &&
            (identical(other.unitOfMeasure, unitOfMeasure) ||
                const DeepCollectionEquality()
                    .equals(other.unitOfMeasure, unitOfMeasure)) &&
            (identical(other.studyEffectiveDescription, studyEffectiveDescription) ||
                const DeepCollectionEquality().equals(
                    other.studyEffectiveDescription,
                    studyEffectiveDescription)) &&
            (identical(other.studyEffectiveDateTime, studyEffectiveDateTime) ||
                const DeepCollectionEquality().equals(
                    other.studyEffectiveDateTime, studyEffectiveDateTime)) &&
            (identical(other.studyEffectivePeriod, studyEffectivePeriod) ||
                const DeepCollectionEquality().equals(
                    other.studyEffectivePeriod, studyEffectivePeriod)) &&
            (identical(other.studyEffectiveDuration, studyEffectiveDuration) ||
                const DeepCollectionEquality().equals(
                    other.studyEffectiveDuration, studyEffectiveDuration)) &&
            (identical(other.studyEffectiveTiming, studyEffectiveTiming) || const DeepCollectionEquality().equals(other.studyEffectiveTiming, studyEffectiveTiming)) &&
            (identical(other.studyEffectiveTimeFromStart, studyEffectiveTimeFromStart) || const DeepCollectionEquality().equals(other.studyEffectiveTimeFromStart, studyEffectiveTimeFromStart)) &&
            (identical(other.studyEffectiveGroupMeasure, studyEffectiveGroupMeasure) || const DeepCollectionEquality().equals(other.studyEffectiveGroupMeasure, studyEffectiveGroupMeasure)) &&
            (identical(other.participantEffectiveDescription, participantEffectiveDescription) || const DeepCollectionEquality().equals(other.participantEffectiveDescription, participantEffectiveDescription)) &&
            (identical(other.participantEffectiveDateTime, participantEffectiveDateTime) || const DeepCollectionEquality().equals(other.participantEffectiveDateTime, participantEffectiveDateTime)) &&
            (identical(other.participantEffectivePeriod, participantEffectivePeriod) || const DeepCollectionEquality().equals(other.participantEffectivePeriod, participantEffectivePeriod)) &&
            (identical(other.participantEffectiveDuration, participantEffectiveDuration) || const DeepCollectionEquality().equals(other.participantEffectiveDuration, participantEffectiveDuration)) &&
            (identical(other.participantEffectiveTiming, participantEffectiveTiming) || const DeepCollectionEquality().equals(other.participantEffectiveTiming, participantEffectiveTiming)) &&
            (identical(other.participantEffectiveTimeFromStart, participantEffectiveTimeFromStart) || const DeepCollectionEquality().equals(other.participantEffectiveTimeFromStart, participantEffectiveTimeFromStart)) &&
            (identical(other.participantEffectiveGroupMeasure, participantEffectiveGroupMeasure) || const DeepCollectionEquality().equals(other.participantEffectiveGroupMeasure, participantEffectiveGroupMeasure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(definitionCodeableConcept) ^
      const DeepCollectionEquality().hash(definitionCanonical) ^
      const DeepCollectionEquality().hash(definitionExpression) ^
      const DeepCollectionEquality().hash(definitionDataRequirement) ^
      const DeepCollectionEquality().hash(usageContext) ^
      const DeepCollectionEquality().hash(exclude) ^
      const DeepCollectionEquality().hash(unitOfMeasure) ^
      const DeepCollectionEquality().hash(studyEffectiveDescription) ^
      const DeepCollectionEquality().hash(studyEffectiveDateTime) ^
      const DeepCollectionEquality().hash(studyEffectivePeriod) ^
      const DeepCollectionEquality().hash(studyEffectiveDuration) ^
      const DeepCollectionEquality().hash(studyEffectiveTiming) ^
      const DeepCollectionEquality().hash(studyEffectiveTimeFromStart) ^
      const DeepCollectionEquality().hash(studyEffectiveGroupMeasure) ^
      const DeepCollectionEquality().hash(participantEffectiveDescription) ^
      const DeepCollectionEquality().hash(participantEffectiveDateTime) ^
      const DeepCollectionEquality().hash(participantEffectivePeriod) ^
      const DeepCollectionEquality().hash(participantEffectiveDuration) ^
      const DeepCollectionEquality().hash(participantEffectiveTiming) ^
      const DeepCollectionEquality().hash(participantEffectiveTimeFromStart) ^
      const DeepCollectionEquality().hash(participantEffectiveGroupMeasure);

  @override
  _$ResearchElementDefinitionCharacteristicCopyWith<
          _ResearchElementDefinitionCharacteristic>
      get copyWith => __$ResearchElementDefinitionCharacteristicCopyWithImpl<
          _ResearchElementDefinitionCharacteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchElementDefinitionCharacteristicToJson(this);
  }
}

abstract class _ResearchElementDefinitionCharacteristic
    implements ResearchElementDefinitionCharacteristic {
  const factory _ResearchElementDefinitionCharacteristic(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept definitionCodeableConcept,
      Canonical definitionCanonical,
      Expression definitionExpression,
      DataRequirement definitionDataRequirement,
      List<UsageContext> usageContext,
      Boolean exclude,
      CodeableConcept unitOfMeasure,
      String studyEffectiveDescription,
      FhirDateTime studyEffectiveDateTime,
      Period studyEffectivePeriod,
      Duration studyEffectiveDuration,
      Timing studyEffectiveTiming,
      Duration studyEffectiveTimeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicStudyEffectiveGroupMeasure.unknown)
          CharacteristicStudyEffectiveGroupMeasure studyEffectiveGroupMeasure,
      String participantEffectiveDescription,
      FhirDateTime participantEffectiveDateTime,
      Period participantEffectivePeriod,
      Duration participantEffectiveDuration,
      Timing participantEffectiveTiming,
      Duration participantEffectiveTimeFromStart,
      @JsonKey(unknownEnumValue: CharacteristicParticipantEffectiveGroupMeasure.unknown)
          CharacteristicParticipantEffectiveGroupMeasure participantEffectiveGroupMeasure}) = _$_ResearchElementDefinitionCharacteristic;

  factory _ResearchElementDefinitionCharacteristic.fromJson(
          Map<String, dynamic> json) =
      _$_ResearchElementDefinitionCharacteristic.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get definitionCodeableConcept;
  @override
  Canonical get definitionCanonical;
  @override
  Expression get definitionExpression;
  @override
  DataRequirement get definitionDataRequirement;
  @override
  List<UsageContext> get usageContext;
  @override
  Boolean get exclude;
  @override
  CodeableConcept get unitOfMeasure;
  @override
  String get studyEffectiveDescription;
  @override
  FhirDateTime get studyEffectiveDateTime;
  @override
  Period get studyEffectivePeriod;
  @override
  Duration get studyEffectiveDuration;
  @override
  Timing get studyEffectiveTiming;
  @override
  Duration get studyEffectiveTimeFromStart;
  @override
  @JsonKey(unknownEnumValue: CharacteristicStudyEffectiveGroupMeasure.unknown)
  CharacteristicStudyEffectiveGroupMeasure get studyEffectiveGroupMeasure;
  @override
  String get participantEffectiveDescription;
  @override
  FhirDateTime get participantEffectiveDateTime;
  @override
  Period get participantEffectivePeriod;
  @override
  Duration get participantEffectiveDuration;
  @override
  Timing get participantEffectiveTiming;
  @override
  Duration get participantEffectiveTimeFromStart;
  @override
  @JsonKey(
      unknownEnumValue: CharacteristicParticipantEffectiveGroupMeasure.unknown)
  CharacteristicParticipantEffectiveGroupMeasure
      get participantEffectiveGroupMeasure;
  @override
  _$ResearchElementDefinitionCharacteristicCopyWith<
      _ResearchElementDefinitionCharacteristic> get copyWith;
}

ResearchStudy _$ResearchStudyFromJson(Map<String, dynamic> json) {
  return _ResearchStudy.fromJson(json);
}

class _$ResearchStudyTearOff {
  const _$ResearchStudyTearOff();

  _ResearchStudy call(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchStudy')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      String title,
      List<Reference> protocol,
      List<Reference> partOf,
      @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
          ResearchStudyStatus status,
      CodeableConcept primaryPurposeType,
      CodeableConcept phase,
      List<CodeableConcept> category,
      List<CodeableConcept> focus,
      List<CodeableConcept> condition,
      List<ContactDetail> contact,
      List<RelatedArtifact> relatedArtifact,
      List<CodeableConcept> keyword,
      List<CodeableConcept> location,
      Markdown description,
      List<Reference> enrollment,
      Period period,
      Reference sponsor,
      Reference principalInvestigator,
      List<Reference> site,
      CodeableConcept reasonStopped,
      List<Annotation> note,
      List<ResearchStudyArm> arm,
      List<ResearchStudyObjective> objective}) {
    return _ResearchStudy(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      title: title,
      protocol: protocol,
      partOf: partOf,
      status: status,
      primaryPurposeType: primaryPurposeType,
      phase: phase,
      category: category,
      focus: focus,
      condition: condition,
      contact: contact,
      relatedArtifact: relatedArtifact,
      keyword: keyword,
      location: location,
      description: description,
      enrollment: enrollment,
      period: period,
      sponsor: sponsor,
      principalInvestigator: principalInvestigator,
      site: site,
      reasonStopped: reasonStopped,
      note: note,
      arm: arm,
      objective: objective,
    );
  }
}

// ignore: unused_element
const $ResearchStudy = _$ResearchStudyTearOff();

mixin _$ResearchStudy {
  @JsonKey(required: true, defaultValue: 'ResearchStudy')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  String get title;
  List<Reference> get protocol;
  List<Reference> get partOf;
  @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
  ResearchStudyStatus get status;
  CodeableConcept get primaryPurposeType;
  CodeableConcept get phase;
  List<CodeableConcept> get category;
  List<CodeableConcept> get focus;
  List<CodeableConcept> get condition;
  List<ContactDetail> get contact;
  List<RelatedArtifact> get relatedArtifact;
  List<CodeableConcept> get keyword;
  List<CodeableConcept> get location;
  Markdown get description;
  List<Reference> get enrollment;
  Period get period;
  Reference get sponsor;
  Reference get principalInvestigator;
  List<Reference> get site;
  CodeableConcept get reasonStopped;
  List<Annotation> get note;
  List<ResearchStudyArm> get arm;
  List<ResearchStudyObjective> get objective;

  Map<String, dynamic> toJson();
  $ResearchStudyCopyWith<ResearchStudy> get copyWith;
}

abstract class $ResearchStudyCopyWith<$Res> {
  factory $ResearchStudyCopyWith(
          ResearchStudy value, $Res Function(ResearchStudy) then) =
      _$ResearchStudyCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchStudy')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      String title,
      List<Reference> protocol,
      List<Reference> partOf,
      @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
          ResearchStudyStatus status,
      CodeableConcept primaryPurposeType,
      CodeableConcept phase,
      List<CodeableConcept> category,
      List<CodeableConcept> focus,
      List<CodeableConcept> condition,
      List<ContactDetail> contact,
      List<RelatedArtifact> relatedArtifact,
      List<CodeableConcept> keyword,
      List<CodeableConcept> location,
      Markdown description,
      List<Reference> enrollment,
      Period period,
      Reference sponsor,
      Reference principalInvestigator,
      List<Reference> site,
      CodeableConcept reasonStopped,
      List<Annotation> note,
      List<ResearchStudyArm> arm,
      List<ResearchStudyObjective> objective});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get primaryPurposeType;
  $CodeableConceptCopyWith<$Res> get phase;
  $PeriodCopyWith<$Res> get period;
  $ReferenceCopyWith<$Res> get sponsor;
  $ReferenceCopyWith<$Res> get principalInvestigator;
  $CodeableConceptCopyWith<$Res> get reasonStopped;
}

class _$ResearchStudyCopyWithImpl<$Res>
    implements $ResearchStudyCopyWith<$Res> {
  _$ResearchStudyCopyWithImpl(this._value, this._then);

  final ResearchStudy _value;
  // ignore: unused_field
  final $Res Function(ResearchStudy) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object title = freezed,
    Object protocol = freezed,
    Object partOf = freezed,
    Object status = freezed,
    Object primaryPurposeType = freezed,
    Object phase = freezed,
    Object category = freezed,
    Object focus = freezed,
    Object condition = freezed,
    Object contact = freezed,
    Object relatedArtifact = freezed,
    Object keyword = freezed,
    Object location = freezed,
    Object description = freezed,
    Object enrollment = freezed,
    Object period = freezed,
    Object sponsor = freezed,
    Object principalInvestigator = freezed,
    Object site = freezed,
    Object reasonStopped = freezed,
    Object note = freezed,
    Object arm = freezed,
    Object objective = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      title: title == freezed ? _value.title : title as String,
      protocol:
          protocol == freezed ? _value.protocol : protocol as List<Reference>,
      partOf: partOf == freezed ? _value.partOf : partOf as List<Reference>,
      status: status == freezed ? _value.status : status as ResearchStudyStatus,
      primaryPurposeType: primaryPurposeType == freezed
          ? _value.primaryPurposeType
          : primaryPurposeType as CodeableConcept,
      phase: phase == freezed ? _value.phase : phase as CodeableConcept,
      category: category == freezed
          ? _value.category
          : category as List<CodeableConcept>,
      focus: focus == freezed ? _value.focus : focus as List<CodeableConcept>,
      condition: condition == freezed
          ? _value.condition
          : condition as List<CodeableConcept>,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      keyword: keyword == freezed
          ? _value.keyword
          : keyword as List<CodeableConcept>,
      location: location == freezed
          ? _value.location
          : location as List<CodeableConcept>,
      description:
          description == freezed ? _value.description : description as Markdown,
      enrollment: enrollment == freezed
          ? _value.enrollment
          : enrollment as List<Reference>,
      period: period == freezed ? _value.period : period as Period,
      sponsor: sponsor == freezed ? _value.sponsor : sponsor as Reference,
      principalInvestigator: principalInvestigator == freezed
          ? _value.principalInvestigator
          : principalInvestigator as Reference,
      site: site == freezed ? _value.site : site as List<Reference>,
      reasonStopped: reasonStopped == freezed
          ? _value.reasonStopped
          : reasonStopped as CodeableConcept,
      note: note == freezed ? _value.note : note as List<Annotation>,
      arm: arm == freezed ? _value.arm : arm as List<ResearchStudyArm>,
      objective: objective == freezed
          ? _value.objective
          : objective as List<ResearchStudyObjective>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get primaryPurposeType {
    if (_value.primaryPurposeType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.primaryPurposeType, (value) {
      return _then(_value.copyWith(primaryPurposeType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get phase {
    if (_value.phase == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.phase, (value) {
      return _then(_value.copyWith(phase: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get period {
    if (_value.period == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.period, (value) {
      return _then(_value.copyWith(period: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get sponsor {
    if (_value.sponsor == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.sponsor, (value) {
      return _then(_value.copyWith(sponsor: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get principalInvestigator {
    if (_value.principalInvestigator == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.principalInvestigator, (value) {
      return _then(_value.copyWith(principalInvestigator: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get reasonStopped {
    if (_value.reasonStopped == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.reasonStopped, (value) {
      return _then(_value.copyWith(reasonStopped: value));
    });
  }
}

abstract class _$ResearchStudyCopyWith<$Res>
    implements $ResearchStudyCopyWith<$Res> {
  factory _$ResearchStudyCopyWith(
          _ResearchStudy value, $Res Function(_ResearchStudy) then) =
      __$ResearchStudyCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchStudy')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      String title,
      List<Reference> protocol,
      List<Reference> partOf,
      @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
          ResearchStudyStatus status,
      CodeableConcept primaryPurposeType,
      CodeableConcept phase,
      List<CodeableConcept> category,
      List<CodeableConcept> focus,
      List<CodeableConcept> condition,
      List<ContactDetail> contact,
      List<RelatedArtifact> relatedArtifact,
      List<CodeableConcept> keyword,
      List<CodeableConcept> location,
      Markdown description,
      List<Reference> enrollment,
      Period period,
      Reference sponsor,
      Reference principalInvestigator,
      List<Reference> site,
      CodeableConcept reasonStopped,
      List<Annotation> note,
      List<ResearchStudyArm> arm,
      List<ResearchStudyObjective> objective});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get primaryPurposeType;
  @override
  $CodeableConceptCopyWith<$Res> get phase;
  @override
  $PeriodCopyWith<$Res> get period;
  @override
  $ReferenceCopyWith<$Res> get sponsor;
  @override
  $ReferenceCopyWith<$Res> get principalInvestigator;
  @override
  $CodeableConceptCopyWith<$Res> get reasonStopped;
}

class __$ResearchStudyCopyWithImpl<$Res>
    extends _$ResearchStudyCopyWithImpl<$Res>
    implements _$ResearchStudyCopyWith<$Res> {
  __$ResearchStudyCopyWithImpl(
      _ResearchStudy _value, $Res Function(_ResearchStudy) _then)
      : super(_value, (v) => _then(v as _ResearchStudy));

  @override
  _ResearchStudy get _value => super._value as _ResearchStudy;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object title = freezed,
    Object protocol = freezed,
    Object partOf = freezed,
    Object status = freezed,
    Object primaryPurposeType = freezed,
    Object phase = freezed,
    Object category = freezed,
    Object focus = freezed,
    Object condition = freezed,
    Object contact = freezed,
    Object relatedArtifact = freezed,
    Object keyword = freezed,
    Object location = freezed,
    Object description = freezed,
    Object enrollment = freezed,
    Object period = freezed,
    Object sponsor = freezed,
    Object principalInvestigator = freezed,
    Object site = freezed,
    Object reasonStopped = freezed,
    Object note = freezed,
    Object arm = freezed,
    Object objective = freezed,
  }) {
    return _then(_ResearchStudy(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      title: title == freezed ? _value.title : title as String,
      protocol:
          protocol == freezed ? _value.protocol : protocol as List<Reference>,
      partOf: partOf == freezed ? _value.partOf : partOf as List<Reference>,
      status: status == freezed ? _value.status : status as ResearchStudyStatus,
      primaryPurposeType: primaryPurposeType == freezed
          ? _value.primaryPurposeType
          : primaryPurposeType as CodeableConcept,
      phase: phase == freezed ? _value.phase : phase as CodeableConcept,
      category: category == freezed
          ? _value.category
          : category as List<CodeableConcept>,
      focus: focus == freezed ? _value.focus : focus as List<CodeableConcept>,
      condition: condition == freezed
          ? _value.condition
          : condition as List<CodeableConcept>,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      keyword: keyword == freezed
          ? _value.keyword
          : keyword as List<CodeableConcept>,
      location: location == freezed
          ? _value.location
          : location as List<CodeableConcept>,
      description:
          description == freezed ? _value.description : description as Markdown,
      enrollment: enrollment == freezed
          ? _value.enrollment
          : enrollment as List<Reference>,
      period: period == freezed ? _value.period : period as Period,
      sponsor: sponsor == freezed ? _value.sponsor : sponsor as Reference,
      principalInvestigator: principalInvestigator == freezed
          ? _value.principalInvestigator
          : principalInvestigator as Reference,
      site: site == freezed ? _value.site : site as List<Reference>,
      reasonStopped: reasonStopped == freezed
          ? _value.reasonStopped
          : reasonStopped as CodeableConcept,
      note: note == freezed ? _value.note : note as List<Annotation>,
      arm: arm == freezed ? _value.arm : arm as List<ResearchStudyArm>,
      objective: objective == freezed
          ? _value.objective
          : objective as List<ResearchStudyObjective>,
    ));
  }
}

@JsonSerializable()
class _$_ResearchStudy implements _ResearchStudy {
  const _$_ResearchStudy(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchStudy')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.title,
      this.protocol,
      this.partOf,
      @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
          this.status,
      this.primaryPurposeType,
      this.phase,
      this.category,
      this.focus,
      this.condition,
      this.contact,
      this.relatedArtifact,
      this.keyword,
      this.location,
      this.description,
      this.enrollment,
      this.period,
      this.sponsor,
      this.principalInvestigator,
      this.site,
      this.reasonStopped,
      this.note,
      this.arm,
      this.objective})
      : assert(resourceType != null);

  factory _$_ResearchStudy.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchStudyFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ResearchStudy')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  final String title;
  @override
  final List<Reference> protocol;
  @override
  final List<Reference> partOf;
  @override
  @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
  final ResearchStudyStatus status;
  @override
  final CodeableConcept primaryPurposeType;
  @override
  final CodeableConcept phase;
  @override
  final List<CodeableConcept> category;
  @override
  final List<CodeableConcept> focus;
  @override
  final List<CodeableConcept> condition;
  @override
  final List<ContactDetail> contact;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final List<CodeableConcept> keyword;
  @override
  final List<CodeableConcept> location;
  @override
  final Markdown description;
  @override
  final List<Reference> enrollment;
  @override
  final Period period;
  @override
  final Reference sponsor;
  @override
  final Reference principalInvestigator;
  @override
  final List<Reference> site;
  @override
  final CodeableConcept reasonStopped;
  @override
  final List<Annotation> note;
  @override
  final List<ResearchStudyArm> arm;
  @override
  final List<ResearchStudyObjective> objective;

  @override
  String toString() {
    return 'ResearchStudy(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, title: $title, protocol: $protocol, partOf: $partOf, status: $status, primaryPurposeType: $primaryPurposeType, phase: $phase, category: $category, focus: $focus, condition: $condition, contact: $contact, relatedArtifact: $relatedArtifact, keyword: $keyword, location: $location, description: $description, enrollment: $enrollment, period: $period, sponsor: $sponsor, principalInvestigator: $principalInvestigator, site: $site, reasonStopped: $reasonStopped, note: $note, arm: $arm, objective: $objective)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchStudy &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.protocol, protocol) ||
                const DeepCollectionEquality()
                    .equals(other.protocol, protocol)) &&
            (identical(other.partOf, partOf) ||
                const DeepCollectionEquality().equals(other.partOf, partOf)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.primaryPurposeType, primaryPurposeType) ||
                const DeepCollectionEquality()
                    .equals(other.primaryPurposeType, primaryPurposeType)) &&
            (identical(other.phase, phase) ||
                const DeepCollectionEquality().equals(other.phase, phase)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.focus, focus) ||
                const DeepCollectionEquality().equals(other.focus, focus)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.relatedArtifact, relatedArtifact) ||
                const DeepCollectionEquality()
                    .equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.keyword, keyword) ||
                const DeepCollectionEquality()
                    .equals(other.keyword, keyword)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.enrollment, enrollment) ||
                const DeepCollectionEquality()
                    .equals(other.enrollment, enrollment)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)) &&
            (identical(other.sponsor, sponsor) || const DeepCollectionEquality().equals(other.sponsor, sponsor)) &&
            (identical(other.principalInvestigator, principalInvestigator) || const DeepCollectionEquality().equals(other.principalInvestigator, principalInvestigator)) &&
            (identical(other.site, site) || const DeepCollectionEquality().equals(other.site, site)) &&
            (identical(other.reasonStopped, reasonStopped) || const DeepCollectionEquality().equals(other.reasonStopped, reasonStopped)) &&
            (identical(other.note, note) || const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.arm, arm) || const DeepCollectionEquality().equals(other.arm, arm)) &&
            (identical(other.objective, objective) || const DeepCollectionEquality().equals(other.objective, objective)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(protocol) ^
      const DeepCollectionEquality().hash(partOf) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(primaryPurposeType) ^
      const DeepCollectionEquality().hash(phase) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(focus) ^
      const DeepCollectionEquality().hash(condition) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(keyword) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(enrollment) ^
      const DeepCollectionEquality().hash(period) ^
      const DeepCollectionEquality().hash(sponsor) ^
      const DeepCollectionEquality().hash(principalInvestigator) ^
      const DeepCollectionEquality().hash(site) ^
      const DeepCollectionEquality().hash(reasonStopped) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(arm) ^
      const DeepCollectionEquality().hash(objective);

  @override
  _$ResearchStudyCopyWith<_ResearchStudy> get copyWith =>
      __$ResearchStudyCopyWithImpl<_ResearchStudy>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchStudyToJson(this);
  }
}

abstract class _ResearchStudy implements ResearchStudy {
  const factory _ResearchStudy(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchStudy')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      String title,
      List<Reference> protocol,
      List<Reference> partOf,
      @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
          ResearchStudyStatus status,
      CodeableConcept primaryPurposeType,
      CodeableConcept phase,
      List<CodeableConcept> category,
      List<CodeableConcept> focus,
      List<CodeableConcept> condition,
      List<ContactDetail> contact,
      List<RelatedArtifact> relatedArtifact,
      List<CodeableConcept> keyword,
      List<CodeableConcept> location,
      Markdown description,
      List<Reference> enrollment,
      Period period,
      Reference sponsor,
      Reference principalInvestigator,
      List<Reference> site,
      CodeableConcept reasonStopped,
      List<Annotation> note,
      List<ResearchStudyArm> arm,
      List<ResearchStudyObjective> objective}) = _$_ResearchStudy;

  factory _ResearchStudy.fromJson(Map<String, dynamic> json) =
      _$_ResearchStudy.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ResearchStudy')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  String get title;
  @override
  List<Reference> get protocol;
  @override
  List<Reference> get partOf;
  @override
  @JsonKey(unknownEnumValue: ResearchStudyStatus.unknown)
  ResearchStudyStatus get status;
  @override
  CodeableConcept get primaryPurposeType;
  @override
  CodeableConcept get phase;
  @override
  List<CodeableConcept> get category;
  @override
  List<CodeableConcept> get focus;
  @override
  List<CodeableConcept> get condition;
  @override
  List<ContactDetail> get contact;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  List<CodeableConcept> get keyword;
  @override
  List<CodeableConcept> get location;
  @override
  Markdown get description;
  @override
  List<Reference> get enrollment;
  @override
  Period get period;
  @override
  Reference get sponsor;
  @override
  Reference get principalInvestigator;
  @override
  List<Reference> get site;
  @override
  CodeableConcept get reasonStopped;
  @override
  List<Annotation> get note;
  @override
  List<ResearchStudyArm> get arm;
  @override
  List<ResearchStudyObjective> get objective;
  @override
  _$ResearchStudyCopyWith<_ResearchStudy> get copyWith;
}

ResearchStudyArm _$ResearchStudyArmFromJson(Map<String, dynamic> json) {
  return _ResearchStudyArm.fromJson(json);
}

class _$ResearchStudyArmTearOff {
  const _$ResearchStudyArmTearOff();

  _ResearchStudyArm call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      String description}) {
    return _ResearchStudyArm(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      type: type,
      description: description,
    );
  }
}

// ignore: unused_element
const $ResearchStudyArm = _$ResearchStudyArmTearOff();

mixin _$ResearchStudyArm {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  CodeableConcept get type;
  String get description;

  Map<String, dynamic> toJson();
  $ResearchStudyArmCopyWith<ResearchStudyArm> get copyWith;
}

abstract class $ResearchStudyArmCopyWith<$Res> {
  factory $ResearchStudyArmCopyWith(
          ResearchStudyArm value, $Res Function(ResearchStudyArm) then) =
      _$ResearchStudyArmCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      String description});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$ResearchStudyArmCopyWithImpl<$Res>
    implements $ResearchStudyArmCopyWith<$Res> {
  _$ResearchStudyArmCopyWithImpl(this._value, this._then);

  final ResearchStudyArm _value;
  // ignore: unused_field
  final $Res Function(ResearchStudyArm) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
    Object description = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$ResearchStudyArmCopyWith<$Res>
    implements $ResearchStudyArmCopyWith<$Res> {
  factory _$ResearchStudyArmCopyWith(
          _ResearchStudyArm value, $Res Function(_ResearchStudyArm) then) =
      __$ResearchStudyArmCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      String description});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$ResearchStudyArmCopyWithImpl<$Res>
    extends _$ResearchStudyArmCopyWithImpl<$Res>
    implements _$ResearchStudyArmCopyWith<$Res> {
  __$ResearchStudyArmCopyWithImpl(
      _ResearchStudyArm _value, $Res Function(_ResearchStudyArm) _then)
      : super(_value, (v) => _then(v as _ResearchStudyArm));

  @override
  _ResearchStudyArm get _value => super._value as _ResearchStudyArm;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
    Object description = freezed,
  }) {
    return _then(_ResearchStudyArm(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
    ));
  }
}

@JsonSerializable()
class _$_ResearchStudyArm implements _ResearchStudyArm {
  const _$_ResearchStudyArm(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.type,
      this.description});

  factory _$_ResearchStudyArm.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchStudyArmFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final CodeableConcept type;
  @override
  final String description;

  @override
  String toString() {
    return 'ResearchStudyArm(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, type: $type, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchStudyArm &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description);

  @override
  _$ResearchStudyArmCopyWith<_ResearchStudyArm> get copyWith =>
      __$ResearchStudyArmCopyWithImpl<_ResearchStudyArm>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchStudyArmToJson(this);
  }
}

abstract class _ResearchStudyArm implements ResearchStudyArm {
  const factory _ResearchStudyArm(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      String description}) = _$_ResearchStudyArm;

  factory _ResearchStudyArm.fromJson(Map<String, dynamic> json) =
      _$_ResearchStudyArm.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  CodeableConcept get type;
  @override
  String get description;
  @override
  _$ResearchStudyArmCopyWith<_ResearchStudyArm> get copyWith;
}

ResearchStudyObjective _$ResearchStudyObjectiveFromJson(
    Map<String, dynamic> json) {
  return _ResearchStudyObjective.fromJson(json);
}

class _$ResearchStudyObjectiveTearOff {
  const _$ResearchStudyObjectiveTearOff();

  _ResearchStudyObjective call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type}) {
    return _ResearchStudyObjective(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      type: type,
    );
  }
}

// ignore: unused_element
const $ResearchStudyObjective = _$ResearchStudyObjectiveTearOff();

mixin _$ResearchStudyObjective {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  CodeableConcept get type;

  Map<String, dynamic> toJson();
  $ResearchStudyObjectiveCopyWith<ResearchStudyObjective> get copyWith;
}

abstract class $ResearchStudyObjectiveCopyWith<$Res> {
  factory $ResearchStudyObjectiveCopyWith(ResearchStudyObjective value,
          $Res Function(ResearchStudyObjective) then) =
      _$ResearchStudyObjectiveCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$ResearchStudyObjectiveCopyWithImpl<$Res>
    implements $ResearchStudyObjectiveCopyWith<$Res> {
  _$ResearchStudyObjectiveCopyWithImpl(this._value, this._then);

  final ResearchStudyObjective _value;
  // ignore: unused_field
  final $Res Function(ResearchStudyObjective) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$ResearchStudyObjectiveCopyWith<$Res>
    implements $ResearchStudyObjectiveCopyWith<$Res> {
  factory _$ResearchStudyObjectiveCopyWith(_ResearchStudyObjective value,
          $Res Function(_ResearchStudyObjective) then) =
      __$ResearchStudyObjectiveCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$ResearchStudyObjectiveCopyWithImpl<$Res>
    extends _$ResearchStudyObjectiveCopyWithImpl<$Res>
    implements _$ResearchStudyObjectiveCopyWith<$Res> {
  __$ResearchStudyObjectiveCopyWithImpl(_ResearchStudyObjective _value,
      $Res Function(_ResearchStudyObjective) _then)
      : super(_value, (v) => _then(v as _ResearchStudyObjective));

  @override
  _ResearchStudyObjective get _value => super._value as _ResearchStudyObjective;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
  }) {
    return _then(_ResearchStudyObjective(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_ResearchStudyObjective implements _ResearchStudyObjective {
  const _$_ResearchStudyObjective(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.type});

  factory _$_ResearchStudyObjective.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchStudyObjectiveFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final CodeableConcept type;

  @override
  String toString() {
    return 'ResearchStudyObjective(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchStudyObjective &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type);

  @override
  _$ResearchStudyObjectiveCopyWith<_ResearchStudyObjective> get copyWith =>
      __$ResearchStudyObjectiveCopyWithImpl<_ResearchStudyObjective>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchStudyObjectiveToJson(this);
  }
}

abstract class _ResearchStudyObjective implements ResearchStudyObjective {
  const factory _ResearchStudyObjective(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type}) = _$_ResearchStudyObjective;

  factory _ResearchStudyObjective.fromJson(Map<String, dynamic> json) =
      _$_ResearchStudyObjective.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  CodeableConcept get type;
  @override
  _$ResearchStudyObjectiveCopyWith<_ResearchStudyObjective> get copyWith;
}

ResearchSubject _$ResearchSubjectFromJson(Map<String, dynamic> json) {
  return _ResearchSubject.fromJson(json);
}

class _$ResearchSubjectTearOff {
  const _$ResearchSubjectTearOff();

  _ResearchSubject call(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchSubject')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
          ResearchSubjectStatus status,
      Period period,
      @required
      @JsonKey(required: true)
          Reference study,
      @required
      @JsonKey(required: true)
          Reference individual,
      String assignedArm,
      String actualArm,
      Reference consent}) {
    return _ResearchSubject(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      status: status,
      period: period,
      study: study,
      individual: individual,
      assignedArm: assignedArm,
      actualArm: actualArm,
      consent: consent,
    );
  }
}

// ignore: unused_element
const $ResearchSubject = _$ResearchSubjectTearOff();

mixin _$ResearchSubject {
  @JsonKey(required: true, defaultValue: 'ResearchSubject')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<Identifier> get identifier;
  @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
  ResearchSubjectStatus get status;
  Period get period;
  @JsonKey(required: true)
  Reference get study;
  @JsonKey(required: true)
  Reference get individual;
  String get assignedArm;
  String get actualArm;
  Reference get consent;

  Map<String, dynamic> toJson();
  $ResearchSubjectCopyWith<ResearchSubject> get copyWith;
}

abstract class $ResearchSubjectCopyWith<$Res> {
  factory $ResearchSubjectCopyWith(
          ResearchSubject value, $Res Function(ResearchSubject) then) =
      _$ResearchSubjectCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchSubject')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
          ResearchSubjectStatus status,
      Period period,
      @JsonKey(required: true)
          Reference study,
      @JsonKey(required: true)
          Reference individual,
      String assignedArm,
      String actualArm,
      Reference consent});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get period;
  $ReferenceCopyWith<$Res> get study;
  $ReferenceCopyWith<$Res> get individual;
  $ReferenceCopyWith<$Res> get consent;
}

class _$ResearchSubjectCopyWithImpl<$Res>
    implements $ResearchSubjectCopyWith<$Res> {
  _$ResearchSubjectCopyWithImpl(this._value, this._then);

  final ResearchSubject _value;
  // ignore: unused_field
  final $Res Function(ResearchSubject) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object status = freezed,
    Object period = freezed,
    Object study = freezed,
    Object individual = freezed,
    Object assignedArm = freezed,
    Object actualArm = freezed,
    Object consent = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      status:
          status == freezed ? _value.status : status as ResearchSubjectStatus,
      period: period == freezed ? _value.period : period as Period,
      study: study == freezed ? _value.study : study as Reference,
      individual:
          individual == freezed ? _value.individual : individual as Reference,
      assignedArm:
          assignedArm == freezed ? _value.assignedArm : assignedArm as String,
      actualArm: actualArm == freezed ? _value.actualArm : actualArm as String,
      consent: consent == freezed ? _value.consent : consent as Reference,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get period {
    if (_value.period == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.period, (value) {
      return _then(_value.copyWith(period: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get study {
    if (_value.study == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.study, (value) {
      return _then(_value.copyWith(study: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get individual {
    if (_value.individual == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.individual, (value) {
      return _then(_value.copyWith(individual: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get consent {
    if (_value.consent == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.consent, (value) {
      return _then(_value.copyWith(consent: value));
    });
  }
}

abstract class _$ResearchSubjectCopyWith<$Res>
    implements $ResearchSubjectCopyWith<$Res> {
  factory _$ResearchSubjectCopyWith(
          _ResearchSubject value, $Res Function(_ResearchSubject) then) =
      __$ResearchSubjectCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'ResearchSubject')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
          ResearchSubjectStatus status,
      Period period,
      @JsonKey(required: true)
          Reference study,
      @JsonKey(required: true)
          Reference individual,
      String assignedArm,
      String actualArm,
      Reference consent});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get period;
  @override
  $ReferenceCopyWith<$Res> get study;
  @override
  $ReferenceCopyWith<$Res> get individual;
  @override
  $ReferenceCopyWith<$Res> get consent;
}

class __$ResearchSubjectCopyWithImpl<$Res>
    extends _$ResearchSubjectCopyWithImpl<$Res>
    implements _$ResearchSubjectCopyWith<$Res> {
  __$ResearchSubjectCopyWithImpl(
      _ResearchSubject _value, $Res Function(_ResearchSubject) _then)
      : super(_value, (v) => _then(v as _ResearchSubject));

  @override
  _ResearchSubject get _value => super._value as _ResearchSubject;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object status = freezed,
    Object period = freezed,
    Object study = freezed,
    Object individual = freezed,
    Object assignedArm = freezed,
    Object actualArm = freezed,
    Object consent = freezed,
  }) {
    return _then(_ResearchSubject(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      status:
          status == freezed ? _value.status : status as ResearchSubjectStatus,
      period: period == freezed ? _value.period : period as Period,
      study: study == freezed ? _value.study : study as Reference,
      individual:
          individual == freezed ? _value.individual : individual as Reference,
      assignedArm:
          assignedArm == freezed ? _value.assignedArm : assignedArm as String,
      actualArm: actualArm == freezed ? _value.actualArm : actualArm as String,
      consent: consent == freezed ? _value.consent : consent as Reference,
    ));
  }
}

@JsonSerializable()
class _$_ResearchSubject implements _ResearchSubject {
  const _$_ResearchSubject(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchSubject')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
          this.status,
      this.period,
      @required
      @JsonKey(required: true)
          this.study,
      @required
      @JsonKey(required: true)
          this.individual,
      this.assignedArm,
      this.actualArm,
      this.consent})
      : assert(resourceType != null),
        assert(study != null),
        assert(individual != null);

  factory _$_ResearchSubject.fromJson(Map<String, dynamic> json) =>
      _$_$_ResearchSubjectFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'ResearchSubject')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<Identifier> identifier;
  @override
  @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
  final ResearchSubjectStatus status;
  @override
  final Period period;
  @override
  @JsonKey(required: true)
  final Reference study;
  @override
  @JsonKey(required: true)
  final Reference individual;
  @override
  final String assignedArm;
  @override
  final String actualArm;
  @override
  final Reference consent;

  @override
  String toString() {
    return 'ResearchSubject(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, period: $period, study: $study, individual: $individual, assignedArm: $assignedArm, actualArm: $actualArm, consent: $consent)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ResearchSubject &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)) &&
            (identical(other.study, study) ||
                const DeepCollectionEquality().equals(other.study, study)) &&
            (identical(other.individual, individual) ||
                const DeepCollectionEquality()
                    .equals(other.individual, individual)) &&
            (identical(other.assignedArm, assignedArm) ||
                const DeepCollectionEquality()
                    .equals(other.assignedArm, assignedArm)) &&
            (identical(other.actualArm, actualArm) ||
                const DeepCollectionEquality()
                    .equals(other.actualArm, actualArm)) &&
            (identical(other.consent, consent) ||
                const DeepCollectionEquality().equals(other.consent, consent)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(period) ^
      const DeepCollectionEquality().hash(study) ^
      const DeepCollectionEquality().hash(individual) ^
      const DeepCollectionEquality().hash(assignedArm) ^
      const DeepCollectionEquality().hash(actualArm) ^
      const DeepCollectionEquality().hash(consent);

  @override
  _$ResearchSubjectCopyWith<_ResearchSubject> get copyWith =>
      __$ResearchSubjectCopyWithImpl<_ResearchSubject>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ResearchSubjectToJson(this);
  }
}

abstract class _ResearchSubject implements ResearchSubject {
  const factory _ResearchSubject(
      {@required
      @JsonKey(required: true, defaultValue: 'ResearchSubject')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<Identifier> identifier,
      @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
          ResearchSubjectStatus status,
      Period period,
      @required
      @JsonKey(required: true)
          Reference study,
      @required
      @JsonKey(required: true)
          Reference individual,
      String assignedArm,
      String actualArm,
      Reference consent}) = _$_ResearchSubject;

  factory _ResearchSubject.fromJson(Map<String, dynamic> json) =
      _$_ResearchSubject.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'ResearchSubject')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<Identifier> get identifier;
  @override
  @JsonKey(unknownEnumValue: ResearchSubjectStatus.unknown)
  ResearchSubjectStatus get status;
  @override
  Period get period;
  @override
  @JsonKey(required: true)
  Reference get study;
  @override
  @JsonKey(required: true)
  Reference get individual;
  @override
  String get assignedArm;
  @override
  String get actualArm;
  @override
  Reference get consent;
  @override
  _$ResearchSubjectCopyWith<_ResearchSubject> get copyWith;
}

RiskEvidenceSynthesis _$RiskEvidenceSynthesisFromJson(
    Map<String, dynamic> json) {
  return _RiskEvidenceSynthesis.fromJson(json);
}

class _$RiskEvidenceSynthesisTearOff {
  const _$RiskEvidenceSynthesisTearOff();

  _RiskEvidenceSynthesis call(
      {@required
      @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
          RiskEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @required
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      @required
      @JsonKey(required: true)
          Reference outcome,
      RiskEvidenceSynthesisSampleSize sampleSize,
      RiskEvidenceSynthesisRiskEstimate riskEstimate,
      List<RiskEvidenceSynthesisCertainty> certainty}) {
    return _RiskEvidenceSynthesis(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      status: status,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      note: note,
      useContext: useContext,
      jurisdiction: jurisdiction,
      copyright: copyright,
      approvalDate: approvalDate,
      lastReviewDate: lastReviewDate,
      effectivePeriod: effectivePeriod,
      topic: topic,
      author: author,
      editor: editor,
      reviewer: reviewer,
      endorser: endorser,
      relatedArtifact: relatedArtifact,
      synthesisType: synthesisType,
      studyType: studyType,
      population: population,
      exposure: exposure,
      outcome: outcome,
      sampleSize: sampleSize,
      riskEstimate: riskEstimate,
      certainty: certainty,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesis = _$RiskEvidenceSynthesisTearOff();

mixin _$RiskEvidenceSynthesis {
  @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  List<Identifier> get identifier;
  String get version;
  String get name;
  String get title;
  @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
  RiskEvidenceSynthesisStatus get status;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<Annotation> get note;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get copyright;
  Date get approvalDate;
  Date get lastReviewDate;
  Period get effectivePeriod;
  List<CodeableConcept> get topic;
  List<ContactDetail> get author;
  List<ContactDetail> get editor;
  List<ContactDetail> get reviewer;
  List<ContactDetail> get endorser;
  List<RelatedArtifact> get relatedArtifact;
  CodeableConcept get synthesisType;
  CodeableConcept get studyType;
  @JsonKey(required: true)
  Reference get population;
  Reference get exposure;
  @JsonKey(required: true)
  Reference get outcome;
  RiskEvidenceSynthesisSampleSize get sampleSize;
  RiskEvidenceSynthesisRiskEstimate get riskEstimate;
  List<RiskEvidenceSynthesisCertainty> get certainty;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisCopyWith<RiskEvidenceSynthesis> get copyWith;
}

abstract class $RiskEvidenceSynthesisCopyWith<$Res> {
  factory $RiskEvidenceSynthesisCopyWith(RiskEvidenceSynthesis value,
          $Res Function(RiskEvidenceSynthesis) then) =
      _$RiskEvidenceSynthesisCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
          RiskEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      @JsonKey(required: true)
          Reference outcome,
      RiskEvidenceSynthesisSampleSize sampleSize,
      RiskEvidenceSynthesisRiskEstimate riskEstimate,
      List<RiskEvidenceSynthesisCertainty> certainty});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $PeriodCopyWith<$Res> get effectivePeriod;
  $CodeableConceptCopyWith<$Res> get synthesisType;
  $CodeableConceptCopyWith<$Res> get studyType;
  $ReferenceCopyWith<$Res> get population;
  $ReferenceCopyWith<$Res> get exposure;
  $ReferenceCopyWith<$Res> get outcome;
  $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize;
  $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> get riskEstimate;
}

class _$RiskEvidenceSynthesisCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisCopyWith<$Res> {
  _$RiskEvidenceSynthesisCopyWithImpl(this._value, this._then);

  final RiskEvidenceSynthesis _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesis) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object synthesisType = freezed,
    Object studyType = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object outcome = freezed,
    Object sampleSize = freezed,
    Object riskEstimate = freezed,
    Object certainty = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed
          ? _value.status
          : status as RiskEvidenceSynthesisStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      synthesisType: synthesisType == freezed
          ? _value.synthesisType
          : synthesisType as CodeableConcept,
      studyType: studyType == freezed
          ? _value.studyType
          : studyType as CodeableConcept,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
      sampleSize: sampleSize == freezed
          ? _value.sampleSize
          : sampleSize as RiskEvidenceSynthesisSampleSize,
      riskEstimate: riskEstimate == freezed
          ? _value.riskEstimate
          : riskEstimate as RiskEvidenceSynthesisRiskEstimate,
      certainty: certainty == freezed
          ? _value.certainty
          : certainty as List<RiskEvidenceSynthesisCertainty>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $PeriodCopyWith<$Res> get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }
    return $PeriodCopyWith<$Res>(_value.effectivePeriod, (value) {
      return _then(_value.copyWith(effectivePeriod: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get synthesisType {
    if (_value.synthesisType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.synthesisType, (value) {
      return _then(_value.copyWith(synthesisType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get studyType {
    if (_value.studyType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.studyType, (value) {
      return _then(_value.copyWith(studyType: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get population {
    if (_value.population == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.population, (value) {
      return _then(_value.copyWith(population: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get exposure {
    if (_value.exposure == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.exposure, (value) {
      return _then(_value.copyWith(exposure: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get outcome {
    if (_value.outcome == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.outcome, (value) {
      return _then(_value.copyWith(outcome: value));
    });
  }

  @override
  $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize {
    if (_value.sampleSize == null) {
      return null;
    }
    return $RiskEvidenceSynthesisSampleSizeCopyWith<$Res>(_value.sampleSize,
        (value) {
      return _then(_value.copyWith(sampleSize: value));
    });
  }

  @override
  $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> get riskEstimate {
    if (_value.riskEstimate == null) {
      return null;
    }
    return $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res>(_value.riskEstimate,
        (value) {
      return _then(_value.copyWith(riskEstimate: value));
    });
  }
}

abstract class _$RiskEvidenceSynthesisCopyWith<$Res>
    implements $RiskEvidenceSynthesisCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisCopyWith(_RiskEvidenceSynthesis value,
          $Res Function(_RiskEvidenceSynthesis) then) =
      __$RiskEvidenceSynthesisCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      List<Identifier> identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
          RiskEvidenceSynthesisStatus status,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<Annotation> note,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown copyright,
      Date approvalDate,
      Date lastReviewDate,
      Period effectivePeriod,
      List<CodeableConcept> topic,
      List<ContactDetail> author,
      List<ContactDetail> editor,
      List<ContactDetail> reviewer,
      List<ContactDetail> endorser,
      List<RelatedArtifact> relatedArtifact,
      CodeableConcept synthesisType,
      CodeableConcept studyType,
      @JsonKey(required: true)
          Reference population,
      Reference exposure,
      @JsonKey(required: true)
          Reference outcome,
      RiskEvidenceSynthesisSampleSize sampleSize,
      RiskEvidenceSynthesisRiskEstimate riskEstimate,
      List<RiskEvidenceSynthesisCertainty> certainty});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $PeriodCopyWith<$Res> get effectivePeriod;
  @override
  $CodeableConceptCopyWith<$Res> get synthesisType;
  @override
  $CodeableConceptCopyWith<$Res> get studyType;
  @override
  $ReferenceCopyWith<$Res> get population;
  @override
  $ReferenceCopyWith<$Res> get exposure;
  @override
  $ReferenceCopyWith<$Res> get outcome;
  @override
  $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> get sampleSize;
  @override
  $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> get riskEstimate;
}

class __$RiskEvidenceSynthesisCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisCopyWith<$Res> {
  __$RiskEvidenceSynthesisCopyWithImpl(_RiskEvidenceSynthesis _value,
      $Res Function(_RiskEvidenceSynthesis) _then)
      : super(_value, (v) => _then(v as _RiskEvidenceSynthesis));

  @override
  _RiskEvidenceSynthesis get _value => super._value as _RiskEvidenceSynthesis;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object note = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object copyright = freezed,
    Object approvalDate = freezed,
    Object lastReviewDate = freezed,
    Object effectivePeriod = freezed,
    Object topic = freezed,
    Object author = freezed,
    Object editor = freezed,
    Object reviewer = freezed,
    Object endorser = freezed,
    Object relatedArtifact = freezed,
    Object synthesisType = freezed,
    Object studyType = freezed,
    Object population = freezed,
    Object exposure = freezed,
    Object outcome = freezed,
    Object sampleSize = freezed,
    Object riskEstimate = freezed,
    Object certainty = freezed,
  }) {
    return _then(_RiskEvidenceSynthesis(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<Identifier>,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed
          ? _value.status
          : status as RiskEvidenceSynthesisStatus,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      note: note == freezed ? _value.note : note as List<Annotation>,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      approvalDate:
          approvalDate == freezed ? _value.approvalDate : approvalDate as Date,
      lastReviewDate: lastReviewDate == freezed
          ? _value.lastReviewDate
          : lastReviewDate as Date,
      effectivePeriod: effectivePeriod == freezed
          ? _value.effectivePeriod
          : effectivePeriod as Period,
      topic: topic == freezed ? _value.topic : topic as List<CodeableConcept>,
      author: author == freezed ? _value.author : author as List<ContactDetail>,
      editor: editor == freezed ? _value.editor : editor as List<ContactDetail>,
      reviewer: reviewer == freezed
          ? _value.reviewer
          : reviewer as List<ContactDetail>,
      endorser: endorser == freezed
          ? _value.endorser
          : endorser as List<ContactDetail>,
      relatedArtifact: relatedArtifact == freezed
          ? _value.relatedArtifact
          : relatedArtifact as List<RelatedArtifact>,
      synthesisType: synthesisType == freezed
          ? _value.synthesisType
          : synthesisType as CodeableConcept,
      studyType: studyType == freezed
          ? _value.studyType
          : studyType as CodeableConcept,
      population:
          population == freezed ? _value.population : population as Reference,
      exposure: exposure == freezed ? _value.exposure : exposure as Reference,
      outcome: outcome == freezed ? _value.outcome : outcome as Reference,
      sampleSize: sampleSize == freezed
          ? _value.sampleSize
          : sampleSize as RiskEvidenceSynthesisSampleSize,
      riskEstimate: riskEstimate == freezed
          ? _value.riskEstimate
          : riskEstimate as RiskEvidenceSynthesisRiskEstimate,
      certainty: certainty == freezed
          ? _value.certainty
          : certainty as List<RiskEvidenceSynthesisCertainty>,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesis implements _RiskEvidenceSynthesis {
  const _$_RiskEvidenceSynthesis(
      {@required
      @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
          this.status,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.note,
      this.useContext,
      this.jurisdiction,
      this.copyright,
      this.approvalDate,
      this.lastReviewDate,
      this.effectivePeriod,
      this.topic,
      this.author,
      this.editor,
      this.reviewer,
      this.endorser,
      this.relatedArtifact,
      this.synthesisType,
      this.studyType,
      @required
      @JsonKey(required: true)
          this.population,
      this.exposure,
      @required
      @JsonKey(required: true)
          this.outcome,
      this.sampleSize,
      this.riskEstimate,
      this.certainty})
      : assert(resourceType != null),
        assert(population != null),
        assert(outcome != null);

  factory _$_RiskEvidenceSynthesis.fromJson(Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final List<Identifier> identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
  final RiskEvidenceSynthesisStatus status;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<Annotation> note;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown copyright;
  @override
  final Date approvalDate;
  @override
  final Date lastReviewDate;
  @override
  final Period effectivePeriod;
  @override
  final List<CodeableConcept> topic;
  @override
  final List<ContactDetail> author;
  @override
  final List<ContactDetail> editor;
  @override
  final List<ContactDetail> reviewer;
  @override
  final List<ContactDetail> endorser;
  @override
  final List<RelatedArtifact> relatedArtifact;
  @override
  final CodeableConcept synthesisType;
  @override
  final CodeableConcept studyType;
  @override
  @JsonKey(required: true)
  final Reference population;
  @override
  final Reference exposure;
  @override
  @JsonKey(required: true)
  final Reference outcome;
  @override
  final RiskEvidenceSynthesisSampleSize sampleSize;
  @override
  final RiskEvidenceSynthesisRiskEstimate riskEstimate;
  @override
  final List<RiskEvidenceSynthesisCertainty> certainty;

  @override
  String toString() {
    return 'RiskEvidenceSynthesis(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, status: $status, date: $date, publisher: $publisher, contact: $contact, description: $description, note: $note, useContext: $useContext, jurisdiction: $jurisdiction, copyright: $copyright, approvalDate: $approvalDate, lastReviewDate: $lastReviewDate, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, synthesisType: $synthesisType, studyType: $studyType, population: $population, exposure: $exposure, outcome: $outcome, sampleSize: $sampleSize, riskEstimate: $riskEstimate, certainty: $certainty)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesis &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality()
                    .equals(other.copyright, copyright)) &&
            (identical(other.approvalDate, approvalDate) ||
                const DeepCollectionEquality()
                    .equals(other.approvalDate, approvalDate)) &&
            (identical(other.lastReviewDate, lastReviewDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastReviewDate, lastReviewDate)) &&
            (identical(other.effectivePeriod, effectivePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.effectivePeriod, effectivePeriod)) &&
            (identical(other.topic, topic) || const DeepCollectionEquality().equals(other.topic, topic)) &&
            (identical(other.author, author) || const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.editor, editor) || const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.reviewer, reviewer) || const DeepCollectionEquality().equals(other.reviewer, reviewer)) &&
            (identical(other.endorser, endorser) || const DeepCollectionEquality().equals(other.endorser, endorser)) &&
            (identical(other.relatedArtifact, relatedArtifact) || const DeepCollectionEquality().equals(other.relatedArtifact, relatedArtifact)) &&
            (identical(other.synthesisType, synthesisType) || const DeepCollectionEquality().equals(other.synthesisType, synthesisType)) &&
            (identical(other.studyType, studyType) || const DeepCollectionEquality().equals(other.studyType, studyType)) &&
            (identical(other.population, population) || const DeepCollectionEquality().equals(other.population, population)) &&
            (identical(other.exposure, exposure) || const DeepCollectionEquality().equals(other.exposure, exposure)) &&
            (identical(other.outcome, outcome) || const DeepCollectionEquality().equals(other.outcome, outcome)) &&
            (identical(other.sampleSize, sampleSize) || const DeepCollectionEquality().equals(other.sampleSize, sampleSize)) &&
            (identical(other.riskEstimate, riskEstimate) || const DeepCollectionEquality().equals(other.riskEstimate, riskEstimate)) &&
            (identical(other.certainty, certainty) || const DeepCollectionEquality().equals(other.certainty, certainty)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(approvalDate) ^
      const DeepCollectionEquality().hash(lastReviewDate) ^
      const DeepCollectionEquality().hash(effectivePeriod) ^
      const DeepCollectionEquality().hash(topic) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(reviewer) ^
      const DeepCollectionEquality().hash(endorser) ^
      const DeepCollectionEquality().hash(relatedArtifact) ^
      const DeepCollectionEquality().hash(synthesisType) ^
      const DeepCollectionEquality().hash(studyType) ^
      const DeepCollectionEquality().hash(population) ^
      const DeepCollectionEquality().hash(exposure) ^
      const DeepCollectionEquality().hash(outcome) ^
      const DeepCollectionEquality().hash(sampleSize) ^
      const DeepCollectionEquality().hash(riskEstimate) ^
      const DeepCollectionEquality().hash(certainty);

  @override
  _$RiskEvidenceSynthesisCopyWith<_RiskEvidenceSynthesis> get copyWith =>
      __$RiskEvidenceSynthesisCopyWithImpl<_RiskEvidenceSynthesis>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisToJson(this);
  }
}

abstract class _RiskEvidenceSynthesis implements RiskEvidenceSynthesis {
  const factory _RiskEvidenceSynthesis(
          {@required
          @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          FhirUri url,
          List<Identifier> identifier,
          String version,
          String name,
          String title,
          @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
              RiskEvidenceSynthesisStatus status,
          FhirDateTime date,
          String publisher,
          List<ContactDetail> contact,
          Markdown description,
          List<Annotation> note,
          List<UsageContext> useContext,
          List<CodeableConcept> jurisdiction,
          Markdown copyright,
          Date approvalDate,
          Date lastReviewDate,
          Period effectivePeriod,
          List<CodeableConcept> topic,
          List<ContactDetail> author,
          List<ContactDetail> editor,
          List<ContactDetail> reviewer,
          List<ContactDetail> endorser,
          List<RelatedArtifact> relatedArtifact,
          CodeableConcept synthesisType,
          CodeableConcept studyType,
          @required
          @JsonKey(required: true)
              Reference population,
          Reference exposure,
          @required
          @JsonKey(required: true)
              Reference outcome,
          RiskEvidenceSynthesisSampleSize sampleSize,
          RiskEvidenceSynthesisRiskEstimate riskEstimate,
          List<RiskEvidenceSynthesisCertainty> certainty}) =
      _$_RiskEvidenceSynthesis;

  factory _RiskEvidenceSynthesis.fromJson(Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesis.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'RiskEvidenceSynthesis')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  List<Identifier> get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  @JsonKey(unknownEnumValue: RiskEvidenceSynthesisStatus.unknown)
  RiskEvidenceSynthesisStatus get status;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<Annotation> get note;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get copyright;
  @override
  Date get approvalDate;
  @override
  Date get lastReviewDate;
  @override
  Period get effectivePeriod;
  @override
  List<CodeableConcept> get topic;
  @override
  List<ContactDetail> get author;
  @override
  List<ContactDetail> get editor;
  @override
  List<ContactDetail> get reviewer;
  @override
  List<ContactDetail> get endorser;
  @override
  List<RelatedArtifact> get relatedArtifact;
  @override
  CodeableConcept get synthesisType;
  @override
  CodeableConcept get studyType;
  @override
  @JsonKey(required: true)
  Reference get population;
  @override
  Reference get exposure;
  @override
  @JsonKey(required: true)
  Reference get outcome;
  @override
  RiskEvidenceSynthesisSampleSize get sampleSize;
  @override
  RiskEvidenceSynthesisRiskEstimate get riskEstimate;
  @override
  List<RiskEvidenceSynthesisCertainty> get certainty;
  @override
  _$RiskEvidenceSynthesisCopyWith<_RiskEvidenceSynthesis> get copyWith;
}

RiskEvidenceSynthesisSampleSize _$RiskEvidenceSynthesisSampleSizeFromJson(
    Map<String, dynamic> json) {
  return _RiskEvidenceSynthesisSampleSize.fromJson(json);
}

class _$RiskEvidenceSynthesisSampleSizeTearOff {
  const _$RiskEvidenceSynthesisSampleSizeTearOff();

  _RiskEvidenceSynthesisSampleSize call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants}) {
    return _RiskEvidenceSynthesisSampleSize(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      numberOfStudies: numberOfStudies,
      numberOfParticipants: numberOfParticipants,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesisSampleSize =
    _$RiskEvidenceSynthesisSampleSizeTearOff();

mixin _$RiskEvidenceSynthesisSampleSize {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  Integer get numberOfStudies;
  Integer get numberOfParticipants;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisSampleSizeCopyWith<RiskEvidenceSynthesisSampleSize>
      get copyWith;
}

abstract class $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> {
  factory $RiskEvidenceSynthesisSampleSizeCopyWith(
          RiskEvidenceSynthesisSampleSize value,
          $Res Function(RiskEvidenceSynthesisSampleSize) then) =
      _$RiskEvidenceSynthesisSampleSizeCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants});
}

class _$RiskEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> {
  _$RiskEvidenceSynthesisSampleSizeCopyWithImpl(this._value, this._then);

  final RiskEvidenceSynthesisSampleSize _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesisSampleSize) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object numberOfStudies = freezed,
    Object numberOfParticipants = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      numberOfStudies: numberOfStudies == freezed
          ? _value.numberOfStudies
          : numberOfStudies as Integer,
      numberOfParticipants: numberOfParticipants == freezed
          ? _value.numberOfParticipants
          : numberOfParticipants as Integer,
    ));
  }
}

abstract class _$RiskEvidenceSynthesisSampleSizeCopyWith<$Res>
    implements $RiskEvidenceSynthesisSampleSizeCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisSampleSizeCopyWith(
          _RiskEvidenceSynthesisSampleSize value,
          $Res Function(_RiskEvidenceSynthesisSampleSize) then) =
      __$RiskEvidenceSynthesisSampleSizeCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants});
}

class __$RiskEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisSampleSizeCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisSampleSizeCopyWith<$Res> {
  __$RiskEvidenceSynthesisSampleSizeCopyWithImpl(
      _RiskEvidenceSynthesisSampleSize _value,
      $Res Function(_RiskEvidenceSynthesisSampleSize) _then)
      : super(_value, (v) => _then(v as _RiskEvidenceSynthesisSampleSize));

  @override
  _RiskEvidenceSynthesisSampleSize get _value =>
      super._value as _RiskEvidenceSynthesisSampleSize;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object numberOfStudies = freezed,
    Object numberOfParticipants = freezed,
  }) {
    return _then(_RiskEvidenceSynthesisSampleSize(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      numberOfStudies: numberOfStudies == freezed
          ? _value.numberOfStudies
          : numberOfStudies as Integer,
      numberOfParticipants: numberOfParticipants == freezed
          ? _value.numberOfParticipants
          : numberOfParticipants as Integer,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesisSampleSize
    implements _RiskEvidenceSynthesisSampleSize {
  const _$_RiskEvidenceSynthesisSampleSize(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.description,
      this.numberOfStudies,
      this.numberOfParticipants});

  factory _$_RiskEvidenceSynthesisSampleSize.fromJson(
          Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisSampleSizeFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  final Integer numberOfStudies;
  @override
  final Integer numberOfParticipants;

  @override
  String toString() {
    return 'RiskEvidenceSynthesisSampleSize(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, numberOfStudies: $numberOfStudies, numberOfParticipants: $numberOfParticipants)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesisSampleSize &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.numberOfStudies, numberOfStudies) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfStudies, numberOfStudies)) &&
            (identical(other.numberOfParticipants, numberOfParticipants) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfParticipants, numberOfParticipants)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(numberOfStudies) ^
      const DeepCollectionEquality().hash(numberOfParticipants);

  @override
  _$RiskEvidenceSynthesisSampleSizeCopyWith<_RiskEvidenceSynthesisSampleSize>
      get copyWith => __$RiskEvidenceSynthesisSampleSizeCopyWithImpl<
          _RiskEvidenceSynthesisSampleSize>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisSampleSizeToJson(this);
  }
}

abstract class _RiskEvidenceSynthesisSampleSize
    implements RiskEvidenceSynthesisSampleSize {
  const factory _RiskEvidenceSynthesisSampleSize(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      Integer numberOfStudies,
      Integer numberOfParticipants}) = _$_RiskEvidenceSynthesisSampleSize;

  factory _RiskEvidenceSynthesisSampleSize.fromJson(Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesisSampleSize.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  Integer get numberOfStudies;
  @override
  Integer get numberOfParticipants;
  @override
  _$RiskEvidenceSynthesisSampleSizeCopyWith<_RiskEvidenceSynthesisSampleSize>
      get copyWith;
}

RiskEvidenceSynthesisRiskEstimate _$RiskEvidenceSynthesisRiskEstimateFromJson(
    Map<String, dynamic> json) {
  return _RiskEvidenceSynthesisRiskEstimate.fromJson(json);
}

class _$RiskEvidenceSynthesisRiskEstimateTearOff {
  const _$RiskEvidenceSynthesisRiskEstimateTearOff();

  _RiskEvidenceSynthesisRiskEstimate call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      Decimal value,
      CodeableConcept unitOfMeasure,
      Integer denominatorCount,
      Integer numeratorCount,
      List<RiskEvidenceSynthesisPrecisionEstimate> precisionEstimate}) {
    return _RiskEvidenceSynthesisRiskEstimate(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      description: description,
      type: type,
      value: value,
      unitOfMeasure: unitOfMeasure,
      denominatorCount: denominatorCount,
      numeratorCount: numeratorCount,
      precisionEstimate: precisionEstimate,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesisRiskEstimate =
    _$RiskEvidenceSynthesisRiskEstimateTearOff();

mixin _$RiskEvidenceSynthesisRiskEstimate {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get description;
  CodeableConcept get type;
  Decimal get value;
  CodeableConcept get unitOfMeasure;
  Integer get denominatorCount;
  Integer get numeratorCount;
  List<RiskEvidenceSynthesisPrecisionEstimate> get precisionEstimate;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisRiskEstimateCopyWith<RiskEvidenceSynthesisRiskEstimate>
      get copyWith;
}

abstract class $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> {
  factory $RiskEvidenceSynthesisRiskEstimateCopyWith(
          RiskEvidenceSynthesisRiskEstimate value,
          $Res Function(RiskEvidenceSynthesisRiskEstimate) then) =
      _$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      Decimal value,
      CodeableConcept unitOfMeasure,
      Integer denominatorCount,
      Integer numeratorCount,
      List<RiskEvidenceSynthesisPrecisionEstimate> precisionEstimate});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
}

class _$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> {
  _$RiskEvidenceSynthesisRiskEstimateCopyWithImpl(this._value, this._then);

  final RiskEvidenceSynthesisRiskEstimate _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesisRiskEstimate) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object type = freezed,
    Object value = freezed,
    Object unitOfMeasure = freezed,
    Object denominatorCount = freezed,
    Object numeratorCount = freezed,
    Object precisionEstimate = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      value: value == freezed ? _value.value : value as Decimal,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      denominatorCount: denominatorCount == freezed
          ? _value.denominatorCount
          : denominatorCount as Integer,
      numeratorCount: numeratorCount == freezed
          ? _value.numeratorCount
          : numeratorCount as Integer,
      precisionEstimate: precisionEstimate == freezed
          ? _value.precisionEstimate
          : precisionEstimate as List<RiskEvidenceSynthesisPrecisionEstimate>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure {
    if (_value.unitOfMeasure == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.unitOfMeasure, (value) {
      return _then(_value.copyWith(unitOfMeasure: value));
    });
  }
}

abstract class _$RiskEvidenceSynthesisRiskEstimateCopyWith<$Res>
    implements $RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisRiskEstimateCopyWith(
          _RiskEvidenceSynthesisRiskEstimate value,
          $Res Function(_RiskEvidenceSynthesisRiskEstimate) then) =
      __$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String description,
      CodeableConcept type,
      Decimal value,
      CodeableConcept unitOfMeasure,
      Integer denominatorCount,
      Integer numeratorCount,
      List<RiskEvidenceSynthesisPrecisionEstimate> precisionEstimate});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get unitOfMeasure;
}

class __$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisRiskEstimateCopyWith<$Res> {
  __$RiskEvidenceSynthesisRiskEstimateCopyWithImpl(
      _RiskEvidenceSynthesisRiskEstimate _value,
      $Res Function(_RiskEvidenceSynthesisRiskEstimate) _then)
      : super(_value, (v) => _then(v as _RiskEvidenceSynthesisRiskEstimate));

  @override
  _RiskEvidenceSynthesisRiskEstimate get _value =>
      super._value as _RiskEvidenceSynthesisRiskEstimate;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object description = freezed,
    Object type = freezed,
    Object value = freezed,
    Object unitOfMeasure = freezed,
    Object denominatorCount = freezed,
    Object numeratorCount = freezed,
    Object precisionEstimate = freezed,
  }) {
    return _then(_RiskEvidenceSynthesisRiskEstimate(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      description:
          description == freezed ? _value.description : description as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      value: value == freezed ? _value.value : value as Decimal,
      unitOfMeasure: unitOfMeasure == freezed
          ? _value.unitOfMeasure
          : unitOfMeasure as CodeableConcept,
      denominatorCount: denominatorCount == freezed
          ? _value.denominatorCount
          : denominatorCount as Integer,
      numeratorCount: numeratorCount == freezed
          ? _value.numeratorCount
          : numeratorCount as Integer,
      precisionEstimate: precisionEstimate == freezed
          ? _value.precisionEstimate
          : precisionEstimate as List<RiskEvidenceSynthesisPrecisionEstimate>,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesisRiskEstimate
    implements _RiskEvidenceSynthesisRiskEstimate {
  const _$_RiskEvidenceSynthesisRiskEstimate(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.description,
      this.type,
      this.value,
      this.unitOfMeasure,
      this.denominatorCount,
      this.numeratorCount,
      this.precisionEstimate});

  factory _$_RiskEvidenceSynthesisRiskEstimate.fromJson(
          Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisRiskEstimateFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String description;
  @override
  final CodeableConcept type;
  @override
  final Decimal value;
  @override
  final CodeableConcept unitOfMeasure;
  @override
  final Integer denominatorCount;
  @override
  final Integer numeratorCount;
  @override
  final List<RiskEvidenceSynthesisPrecisionEstimate> precisionEstimate;

  @override
  String toString() {
    return 'RiskEvidenceSynthesisRiskEstimate(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, description: $description, type: $type, value: $value, unitOfMeasure: $unitOfMeasure, denominatorCount: $denominatorCount, numeratorCount: $numeratorCount, precisionEstimate: $precisionEstimate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesisRiskEstimate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.unitOfMeasure, unitOfMeasure) ||
                const DeepCollectionEquality()
                    .equals(other.unitOfMeasure, unitOfMeasure)) &&
            (identical(other.denominatorCount, denominatorCount) ||
                const DeepCollectionEquality()
                    .equals(other.denominatorCount, denominatorCount)) &&
            (identical(other.numeratorCount, numeratorCount) ||
                const DeepCollectionEquality()
                    .equals(other.numeratorCount, numeratorCount)) &&
            (identical(other.precisionEstimate, precisionEstimate) ||
                const DeepCollectionEquality()
                    .equals(other.precisionEstimate, precisionEstimate)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(unitOfMeasure) ^
      const DeepCollectionEquality().hash(denominatorCount) ^
      const DeepCollectionEquality().hash(numeratorCount) ^
      const DeepCollectionEquality().hash(precisionEstimate);

  @override
  _$RiskEvidenceSynthesisRiskEstimateCopyWith<
          _RiskEvidenceSynthesisRiskEstimate>
      get copyWith => __$RiskEvidenceSynthesisRiskEstimateCopyWithImpl<
          _RiskEvidenceSynthesisRiskEstimate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisRiskEstimateToJson(this);
  }
}

abstract class _RiskEvidenceSynthesisRiskEstimate
    implements RiskEvidenceSynthesisRiskEstimate {
  const factory _RiskEvidenceSynthesisRiskEstimate(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String description,
          CodeableConcept type,
          Decimal value,
          CodeableConcept unitOfMeasure,
          Integer denominatorCount,
          Integer numeratorCount,
          List<RiskEvidenceSynthesisPrecisionEstimate> precisionEstimate}) =
      _$_RiskEvidenceSynthesisRiskEstimate;

  factory _RiskEvidenceSynthesisRiskEstimate.fromJson(
          Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesisRiskEstimate.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get description;
  @override
  CodeableConcept get type;
  @override
  Decimal get value;
  @override
  CodeableConcept get unitOfMeasure;
  @override
  Integer get denominatorCount;
  @override
  Integer get numeratorCount;
  @override
  List<RiskEvidenceSynthesisPrecisionEstimate> get precisionEstimate;
  @override
  _$RiskEvidenceSynthesisRiskEstimateCopyWith<
      _RiskEvidenceSynthesisRiskEstimate> get copyWith;
}

RiskEvidenceSynthesisPrecisionEstimate
    _$RiskEvidenceSynthesisPrecisionEstimateFromJson(
        Map<String, dynamic> json) {
  return _RiskEvidenceSynthesisPrecisionEstimate.fromJson(json);
}

class _$RiskEvidenceSynthesisPrecisionEstimateTearOff {
  const _$RiskEvidenceSynthesisPrecisionEstimateTearOff();

  _RiskEvidenceSynthesisPrecisionEstimate call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to}) {
    return _RiskEvidenceSynthesisPrecisionEstimate(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      level: level,
      from: from,
      to: to,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesisPrecisionEstimate =
    _$RiskEvidenceSynthesisPrecisionEstimateTearOff();

mixin _$RiskEvidenceSynthesisPrecisionEstimate {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  Decimal get level;
  Decimal get from;
  Decimal get to;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisPrecisionEstimateCopyWith<
      RiskEvidenceSynthesisPrecisionEstimate> get copyWith;
}

abstract class $RiskEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  factory $RiskEvidenceSynthesisPrecisionEstimateCopyWith(
          RiskEvidenceSynthesisPrecisionEstimate value,
          $Res Function(RiskEvidenceSynthesisPrecisionEstimate) then) =
      _$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  _$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl(this._value, this._then);

  final RiskEvidenceSynthesisPrecisionEstimate _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesisPrecisionEstimate) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object level = freezed,
    Object from = freezed,
    Object to = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      level: level == freezed ? _value.level : level as Decimal,
      from: from == freezed ? _value.from : from as Decimal,
      to: to == freezed ? _value.to : to as Decimal,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$RiskEvidenceSynthesisPrecisionEstimateCopyWith<$Res>
    implements $RiskEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisPrecisionEstimateCopyWith(
          _RiskEvidenceSynthesisPrecisionEstimate value,
          $Res Function(_RiskEvidenceSynthesisPrecisionEstimate) then) =
      __$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisPrecisionEstimateCopyWith<$Res> {
  __$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl(
      _RiskEvidenceSynthesisPrecisionEstimate _value,
      $Res Function(_RiskEvidenceSynthesisPrecisionEstimate) _then)
      : super(
            _value, (v) => _then(v as _RiskEvidenceSynthesisPrecisionEstimate));

  @override
  _RiskEvidenceSynthesisPrecisionEstimate get _value =>
      super._value as _RiskEvidenceSynthesisPrecisionEstimate;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object level = freezed,
    Object from = freezed,
    Object to = freezed,
  }) {
    return _then(_RiskEvidenceSynthesisPrecisionEstimate(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      level: level == freezed ? _value.level : level as Decimal,
      from: from == freezed ? _value.from : from as Decimal,
      to: to == freezed ? _value.to : to as Decimal,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesisPrecisionEstimate
    implements _RiskEvidenceSynthesisPrecisionEstimate {
  const _$_RiskEvidenceSynthesisPrecisionEstimate(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.level,
      this.from,
      this.to});

  factory _$_RiskEvidenceSynthesisPrecisionEstimate.fromJson(
          Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisPrecisionEstimateFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final Decimal level;
  @override
  final Decimal from;
  @override
  final Decimal to;

  @override
  String toString() {
    return 'RiskEvidenceSynthesisPrecisionEstimate(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, level: $level, from: $from, to: $to)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesisPrecisionEstimate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.level, level) ||
                const DeepCollectionEquality().equals(other.level, level)) &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(level) ^
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to);

  @override
  _$RiskEvidenceSynthesisPrecisionEstimateCopyWith<
          _RiskEvidenceSynthesisPrecisionEstimate>
      get copyWith => __$RiskEvidenceSynthesisPrecisionEstimateCopyWithImpl<
          _RiskEvidenceSynthesisPrecisionEstimate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisPrecisionEstimateToJson(this);
  }
}

abstract class _RiskEvidenceSynthesisPrecisionEstimate
    implements RiskEvidenceSynthesisPrecisionEstimate {
  const factory _RiskEvidenceSynthesisPrecisionEstimate(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Decimal level,
      Decimal from,
      Decimal to}) = _$_RiskEvidenceSynthesisPrecisionEstimate;

  factory _RiskEvidenceSynthesisPrecisionEstimate.fromJson(
          Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesisPrecisionEstimate.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  Decimal get level;
  @override
  Decimal get from;
  @override
  Decimal get to;
  @override
  _$RiskEvidenceSynthesisPrecisionEstimateCopyWith<
      _RiskEvidenceSynthesisPrecisionEstimate> get copyWith;
}

RiskEvidenceSynthesisCertainty _$RiskEvidenceSynthesisCertaintyFromJson(
    Map<String, dynamic> json) {
  return _RiskEvidenceSynthesisCertainty.fromJson(json);
}

class _$RiskEvidenceSynthesisCertaintyTearOff {
  const _$RiskEvidenceSynthesisCertaintyTearOff();

  _RiskEvidenceSynthesisCertainty call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<RiskEvidenceSynthesisCertaintySubcomponent> certaintySubcomponent}) {
    return _RiskEvidenceSynthesisCertainty(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      rating: rating,
      note: note,
      certaintySubcomponent: certaintySubcomponent,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesisCertainty =
    _$RiskEvidenceSynthesisCertaintyTearOff();

mixin _$RiskEvidenceSynthesisCertainty {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<CodeableConcept> get rating;
  List<Annotation> get note;
  List<RiskEvidenceSynthesisCertaintySubcomponent> get certaintySubcomponent;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisCertaintyCopyWith<RiskEvidenceSynthesisCertainty>
      get copyWith;
}

abstract class $RiskEvidenceSynthesisCertaintyCopyWith<$Res> {
  factory $RiskEvidenceSynthesisCertaintyCopyWith(
          RiskEvidenceSynthesisCertainty value,
          $Res Function(RiskEvidenceSynthesisCertainty) then) =
      _$RiskEvidenceSynthesisCertaintyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<RiskEvidenceSynthesisCertaintySubcomponent> certaintySubcomponent});
}

class _$RiskEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisCertaintyCopyWith<$Res> {
  _$RiskEvidenceSynthesisCertaintyCopyWithImpl(this._value, this._then);

  final RiskEvidenceSynthesisCertainty _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesisCertainty) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object rating = freezed,
    Object note = freezed,
    Object certaintySubcomponent = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
      certaintySubcomponent: certaintySubcomponent == freezed
          ? _value.certaintySubcomponent
          : certaintySubcomponent
              as List<RiskEvidenceSynthesisCertaintySubcomponent>,
    ));
  }
}

abstract class _$RiskEvidenceSynthesisCertaintyCopyWith<$Res>
    implements $RiskEvidenceSynthesisCertaintyCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisCertaintyCopyWith(
          _RiskEvidenceSynthesisCertainty value,
          $Res Function(_RiskEvidenceSynthesisCertainty) then) =
      __$RiskEvidenceSynthesisCertaintyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<RiskEvidenceSynthesisCertaintySubcomponent> certaintySubcomponent});
}

class __$RiskEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisCertaintyCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisCertaintyCopyWith<$Res> {
  __$RiskEvidenceSynthesisCertaintyCopyWithImpl(
      _RiskEvidenceSynthesisCertainty _value,
      $Res Function(_RiskEvidenceSynthesisCertainty) _then)
      : super(_value, (v) => _then(v as _RiskEvidenceSynthesisCertainty));

  @override
  _RiskEvidenceSynthesisCertainty get _value =>
      super._value as _RiskEvidenceSynthesisCertainty;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object rating = freezed,
    Object note = freezed,
    Object certaintySubcomponent = freezed,
  }) {
    return _then(_RiskEvidenceSynthesisCertainty(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
      certaintySubcomponent: certaintySubcomponent == freezed
          ? _value.certaintySubcomponent
          : certaintySubcomponent
              as List<RiskEvidenceSynthesisCertaintySubcomponent>,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesisCertainty
    implements _RiskEvidenceSynthesisCertainty {
  const _$_RiskEvidenceSynthesisCertainty(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.rating,
      this.note,
      this.certaintySubcomponent});

  factory _$_RiskEvidenceSynthesisCertainty.fromJson(
          Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisCertaintyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<CodeableConcept> rating;
  @override
  final List<Annotation> note;
  @override
  final List<RiskEvidenceSynthesisCertaintySubcomponent> certaintySubcomponent;

  @override
  String toString() {
    return 'RiskEvidenceSynthesisCertainty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, rating: $rating, note: $note, certaintySubcomponent: $certaintySubcomponent)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesisCertainty &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)) &&
            (identical(other.certaintySubcomponent, certaintySubcomponent) ||
                const DeepCollectionEquality().equals(
                    other.certaintySubcomponent, certaintySubcomponent)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(note) ^
      const DeepCollectionEquality().hash(certaintySubcomponent);

  @override
  _$RiskEvidenceSynthesisCertaintyCopyWith<_RiskEvidenceSynthesisCertainty>
      get copyWith => __$RiskEvidenceSynthesisCertaintyCopyWithImpl<
          _RiskEvidenceSynthesisCertainty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisCertaintyToJson(this);
  }
}

abstract class _RiskEvidenceSynthesisCertainty
    implements RiskEvidenceSynthesisCertainty {
  const factory _RiskEvidenceSynthesisCertainty(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<CodeableConcept> rating,
      List<Annotation> note,
      List<RiskEvidenceSynthesisCertaintySubcomponent>
          certaintySubcomponent}) = _$_RiskEvidenceSynthesisCertainty;

  factory _RiskEvidenceSynthesisCertainty.fromJson(Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesisCertainty.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<CodeableConcept> get rating;
  @override
  List<Annotation> get note;
  @override
  List<RiskEvidenceSynthesisCertaintySubcomponent> get certaintySubcomponent;
  @override
  _$RiskEvidenceSynthesisCertaintyCopyWith<_RiskEvidenceSynthesisCertainty>
      get copyWith;
}

RiskEvidenceSynthesisCertaintySubcomponent
    _$RiskEvidenceSynthesisCertaintySubcomponentFromJson(
        Map<String, dynamic> json) {
  return _RiskEvidenceSynthesisCertaintySubcomponent.fromJson(json);
}

class _$RiskEvidenceSynthesisCertaintySubcomponentTearOff {
  const _$RiskEvidenceSynthesisCertaintySubcomponentTearOff();

  _RiskEvidenceSynthesisCertaintySubcomponent call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note}) {
    return _RiskEvidenceSynthesisCertaintySubcomponent(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      rating: rating,
      note: note,
    );
  }
}

// ignore: unused_element
const $RiskEvidenceSynthesisCertaintySubcomponent =
    _$RiskEvidenceSynthesisCertaintySubcomponentTearOff();

mixin _$RiskEvidenceSynthesisCertaintySubcomponent {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  List<CodeableConcept> get rating;
  List<Annotation> get note;

  Map<String, dynamic> toJson();
  $RiskEvidenceSynthesisCertaintySubcomponentCopyWith<
      RiskEvidenceSynthesisCertaintySubcomponent> get copyWith;
}

abstract class $RiskEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  factory $RiskEvidenceSynthesisCertaintySubcomponentCopyWith(
          RiskEvidenceSynthesisCertaintySubcomponent value,
          $Res Function(RiskEvidenceSynthesisCertaintySubcomponent) then) =
      _$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note});

  $CodeableConceptCopyWith<$Res> get type;
}

class _$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    implements $RiskEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  _$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl(
      this._value, this._then);

  final RiskEvidenceSynthesisCertaintySubcomponent _value;
  // ignore: unused_field
  final $Res Function(RiskEvidenceSynthesisCertaintySubcomponent) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object rating = freezed,
    Object note = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$RiskEvidenceSynthesisCertaintySubcomponentCopyWith<$Res>
    implements $RiskEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  factory _$RiskEvidenceSynthesisCertaintySubcomponentCopyWith(
          _RiskEvidenceSynthesisCertaintySubcomponent value,
          $Res Function(_RiskEvidenceSynthesisCertaintySubcomponent) then) =
      __$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

class __$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    extends _$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<$Res>
    implements _$RiskEvidenceSynthesisCertaintySubcomponentCopyWith<$Res> {
  __$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl(
      _RiskEvidenceSynthesisCertaintySubcomponent _value,
      $Res Function(_RiskEvidenceSynthesisCertaintySubcomponent) _then)
      : super(_value,
            (v) => _then(v as _RiskEvidenceSynthesisCertaintySubcomponent));

  @override
  _RiskEvidenceSynthesisCertaintySubcomponent get _value =>
      super._value as _RiskEvidenceSynthesisCertaintySubcomponent;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object rating = freezed,
    Object note = freezed,
  }) {
    return _then(_RiskEvidenceSynthesisCertaintySubcomponent(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      rating:
          rating == freezed ? _value.rating : rating as List<CodeableConcept>,
      note: note == freezed ? _value.note : note as List<Annotation>,
    ));
  }
}

@JsonSerializable()
class _$_RiskEvidenceSynthesisCertaintySubcomponent
    implements _RiskEvidenceSynthesisCertaintySubcomponent {
  const _$_RiskEvidenceSynthesisCertaintySubcomponent(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.rating,
      this.note});

  factory _$_RiskEvidenceSynthesisCertaintySubcomponent.fromJson(
          Map<String, dynamic> json) =>
      _$_$_RiskEvidenceSynthesisCertaintySubcomponentFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final List<CodeableConcept> rating;
  @override
  final List<Annotation> note;

  @override
  String toString() {
    return 'RiskEvidenceSynthesisCertaintySubcomponent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, rating: $rating, note: $note)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RiskEvidenceSynthesisCertaintySubcomponent &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.note, note) ||
                const DeepCollectionEquality().equals(other.note, note)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(note);

  @override
  _$RiskEvidenceSynthesisCertaintySubcomponentCopyWith<
          _RiskEvidenceSynthesisCertaintySubcomponent>
      get copyWith => __$RiskEvidenceSynthesisCertaintySubcomponentCopyWithImpl<
          _RiskEvidenceSynthesisCertaintySubcomponent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_RiskEvidenceSynthesisCertaintySubcomponentToJson(this);
  }
}

abstract class _RiskEvidenceSynthesisCertaintySubcomponent
    implements RiskEvidenceSynthesisCertaintySubcomponent {
  const factory _RiskEvidenceSynthesisCertaintySubcomponent(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      List<CodeableConcept> rating,
      List<Annotation> note}) = _$_RiskEvidenceSynthesisCertaintySubcomponent;

  factory _RiskEvidenceSynthesisCertaintySubcomponent.fromJson(
          Map<String, dynamic> json) =
      _$_RiskEvidenceSynthesisCertaintySubcomponent.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  List<CodeableConcept> get rating;
  @override
  List<Annotation> get note;
  @override
  _$RiskEvidenceSynthesisCertaintySubcomponentCopyWith<
      _RiskEvidenceSynthesisCertaintySubcomponent> get copyWith;
}

SpecimenDefinition _$SpecimenDefinitionFromJson(Map<String, dynamic> json) {
  return _SpecimenDefinition.fromJson(json);
}

class _$SpecimenDefinitionTearOff {
  const _$SpecimenDefinitionTearOff();

  _SpecimenDefinition call(
      {@required
      @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept typeCollected,
      List<CodeableConcept> patientPreparation,
      String timeAspect,
      List<CodeableConcept> collection,
      List<SpecimenDefinitionTypeTested> typeTested}) {
    return _SpecimenDefinition(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      typeCollected: typeCollected,
      patientPreparation: patientPreparation,
      timeAspect: timeAspect,
      collection: collection,
      typeTested: typeTested,
    );
  }
}

// ignore: unused_element
const $SpecimenDefinition = _$SpecimenDefinitionTearOff();

mixin _$SpecimenDefinition {
  @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  CodeableConcept get typeCollected;
  List<CodeableConcept> get patientPreparation;
  String get timeAspect;
  List<CodeableConcept> get collection;
  List<SpecimenDefinitionTypeTested> get typeTested;

  Map<String, dynamic> toJson();
  $SpecimenDefinitionCopyWith<SpecimenDefinition> get copyWith;
}

abstract class $SpecimenDefinitionCopyWith<$Res> {
  factory $SpecimenDefinitionCopyWith(
          SpecimenDefinition value, $Res Function(SpecimenDefinition) then) =
      _$SpecimenDefinitionCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SpecimenDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept typeCollected,
      List<CodeableConcept> patientPreparation,
      String timeAspect,
      List<CodeableConcept> collection,
      List<SpecimenDefinitionTypeTested> typeTested});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get typeCollected;
}

class _$SpecimenDefinitionCopyWithImpl<$Res>
    implements $SpecimenDefinitionCopyWith<$Res> {
  _$SpecimenDefinitionCopyWithImpl(this._value, this._then);

  final SpecimenDefinition _value;
  // ignore: unused_field
  final $Res Function(SpecimenDefinition) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object typeCollected = freezed,
    Object patientPreparation = freezed,
    Object timeAspect = freezed,
    Object collection = freezed,
    Object typeTested = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      typeCollected: typeCollected == freezed
          ? _value.typeCollected
          : typeCollected as CodeableConcept,
      patientPreparation: patientPreparation == freezed
          ? _value.patientPreparation
          : patientPreparation as List<CodeableConcept>,
      timeAspect:
          timeAspect == freezed ? _value.timeAspect : timeAspect as String,
      collection: collection == freezed
          ? _value.collection
          : collection as List<CodeableConcept>,
      typeTested: typeTested == freezed
          ? _value.typeTested
          : typeTested as List<SpecimenDefinitionTypeTested>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get typeCollected {
    if (_value.typeCollected == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.typeCollected, (value) {
      return _then(_value.copyWith(typeCollected: value));
    });
  }
}

abstract class _$SpecimenDefinitionCopyWith<$Res>
    implements $SpecimenDefinitionCopyWith<$Res> {
  factory _$SpecimenDefinitionCopyWith(
          _SpecimenDefinition value, $Res Function(_SpecimenDefinition) then) =
      __$SpecimenDefinitionCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SpecimenDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept typeCollected,
      List<CodeableConcept> patientPreparation,
      String timeAspect,
      List<CodeableConcept> collection,
      List<SpecimenDefinitionTypeTested> typeTested});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get typeCollected;
}

class __$SpecimenDefinitionCopyWithImpl<$Res>
    extends _$SpecimenDefinitionCopyWithImpl<$Res>
    implements _$SpecimenDefinitionCopyWith<$Res> {
  __$SpecimenDefinitionCopyWithImpl(
      _SpecimenDefinition _value, $Res Function(_SpecimenDefinition) _then)
      : super(_value, (v) => _then(v as _SpecimenDefinition));

  @override
  _SpecimenDefinition get _value => super._value as _SpecimenDefinition;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object typeCollected = freezed,
    Object patientPreparation = freezed,
    Object timeAspect = freezed,
    Object collection = freezed,
    Object typeTested = freezed,
  }) {
    return _then(_SpecimenDefinition(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      typeCollected: typeCollected == freezed
          ? _value.typeCollected
          : typeCollected as CodeableConcept,
      patientPreparation: patientPreparation == freezed
          ? _value.patientPreparation
          : patientPreparation as List<CodeableConcept>,
      timeAspect:
          timeAspect == freezed ? _value.timeAspect : timeAspect as String,
      collection: collection == freezed
          ? _value.collection
          : collection as List<CodeableConcept>,
      typeTested: typeTested == freezed
          ? _value.typeTested
          : typeTested as List<SpecimenDefinitionTypeTested>,
    ));
  }
}

@JsonSerializable()
class _$_SpecimenDefinition implements _SpecimenDefinition {
  const _$_SpecimenDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.typeCollected,
      this.patientPreparation,
      this.timeAspect,
      this.collection,
      this.typeTested})
      : assert(resourceType != null);

  factory _$_SpecimenDefinition.fromJson(Map<String, dynamic> json) =>
      _$_$_SpecimenDefinitionFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  final CodeableConcept typeCollected;
  @override
  final List<CodeableConcept> patientPreparation;
  @override
  final String timeAspect;
  @override
  final List<CodeableConcept> collection;
  @override
  final List<SpecimenDefinitionTypeTested> typeTested;

  @override
  String toString() {
    return 'SpecimenDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, typeCollected: $typeCollected, patientPreparation: $patientPreparation, timeAspect: $timeAspect, collection: $collection, typeTested: $typeTested)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenDefinition &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.typeCollected, typeCollected) ||
                const DeepCollectionEquality()
                    .equals(other.typeCollected, typeCollected)) &&
            (identical(other.patientPreparation, patientPreparation) ||
                const DeepCollectionEquality()
                    .equals(other.patientPreparation, patientPreparation)) &&
            (identical(other.timeAspect, timeAspect) ||
                const DeepCollectionEquality()
                    .equals(other.timeAspect, timeAspect)) &&
            (identical(other.collection, collection) ||
                const DeepCollectionEquality()
                    .equals(other.collection, collection)) &&
            (identical(other.typeTested, typeTested) ||
                const DeepCollectionEquality()
                    .equals(other.typeTested, typeTested)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(typeCollected) ^
      const DeepCollectionEquality().hash(patientPreparation) ^
      const DeepCollectionEquality().hash(timeAspect) ^
      const DeepCollectionEquality().hash(collection) ^
      const DeepCollectionEquality().hash(typeTested);

  @override
  _$SpecimenDefinitionCopyWith<_SpecimenDefinition> get copyWith =>
      __$SpecimenDefinitionCopyWithImpl<_SpecimenDefinition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SpecimenDefinitionToJson(this);
  }
}

abstract class _SpecimenDefinition implements SpecimenDefinition {
  const factory _SpecimenDefinition(
      {@required
      @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept typeCollected,
      List<CodeableConcept> patientPreparation,
      String timeAspect,
      List<CodeableConcept> collection,
      List<SpecimenDefinitionTypeTested> typeTested}) = _$_SpecimenDefinition;

  factory _SpecimenDefinition.fromJson(Map<String, dynamic> json) =
      _$_SpecimenDefinition.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SpecimenDefinition')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  CodeableConcept get typeCollected;
  @override
  List<CodeableConcept> get patientPreparation;
  @override
  String get timeAspect;
  @override
  List<CodeableConcept> get collection;
  @override
  List<SpecimenDefinitionTypeTested> get typeTested;
  @override
  _$SpecimenDefinitionCopyWith<_SpecimenDefinition> get copyWith;
}

SpecimenDefinitionTypeTested _$SpecimenDefinitionTypeTestedFromJson(
    Map<String, dynamic> json) {
  return _SpecimenDefinitionTypeTested.fromJson(json);
}

class _$SpecimenDefinitionTypeTestedTearOff {
  const _$SpecimenDefinitionTypeTestedTearOff();

  _SpecimenDefinitionTypeTested call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean isDerived,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
          TypeTestedPreference preference,
      SpecimenDefinitionContainer container,
      String requirement,
      Duration retentionTime,
      List<CodeableConcept> rejectionCriterion,
      List<SpecimenDefinitionHandling> handling}) {
    return _SpecimenDefinitionTypeTested(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      isDerived: isDerived,
      type: type,
      preference: preference,
      container: container,
      requirement: requirement,
      retentionTime: retentionTime,
      rejectionCriterion: rejectionCriterion,
      handling: handling,
    );
  }
}

// ignore: unused_element
const $SpecimenDefinitionTypeTested = _$SpecimenDefinitionTypeTestedTearOff();

mixin _$SpecimenDefinitionTypeTested {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Boolean get isDerived;
  CodeableConcept get type;
  @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
  TypeTestedPreference get preference;
  SpecimenDefinitionContainer get container;
  String get requirement;
  Duration get retentionTime;
  List<CodeableConcept> get rejectionCriterion;
  List<SpecimenDefinitionHandling> get handling;

  Map<String, dynamic> toJson();
  $SpecimenDefinitionTypeTestedCopyWith<SpecimenDefinitionTypeTested>
      get copyWith;
}

abstract class $SpecimenDefinitionTypeTestedCopyWith<$Res> {
  factory $SpecimenDefinitionTypeTestedCopyWith(
          SpecimenDefinitionTypeTested value,
          $Res Function(SpecimenDefinitionTypeTested) then) =
      _$SpecimenDefinitionTypeTestedCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean isDerived,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
          TypeTestedPreference preference,
      SpecimenDefinitionContainer container,
      String requirement,
      Duration retentionTime,
      List<CodeableConcept> rejectionCriterion,
      List<SpecimenDefinitionHandling> handling});

  $CodeableConceptCopyWith<$Res> get type;
  $SpecimenDefinitionContainerCopyWith<$Res> get container;
  $DurationCopyWith<$Res> get retentionTime;
}

class _$SpecimenDefinitionTypeTestedCopyWithImpl<$Res>
    implements $SpecimenDefinitionTypeTestedCopyWith<$Res> {
  _$SpecimenDefinitionTypeTestedCopyWithImpl(this._value, this._then);

  final SpecimenDefinitionTypeTested _value;
  // ignore: unused_field
  final $Res Function(SpecimenDefinitionTypeTested) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object isDerived = freezed,
    Object type = freezed,
    Object preference = freezed,
    Object container = freezed,
    Object requirement = freezed,
    Object retentionTime = freezed,
    Object rejectionCriterion = freezed,
    Object handling = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      isDerived: isDerived == freezed ? _value.isDerived : isDerived as Boolean,
      type: type == freezed ? _value.type : type as CodeableConcept,
      preference: preference == freezed
          ? _value.preference
          : preference as TypeTestedPreference,
      container: container == freezed
          ? _value.container
          : container as SpecimenDefinitionContainer,
      requirement:
          requirement == freezed ? _value.requirement : requirement as String,
      retentionTime: retentionTime == freezed
          ? _value.retentionTime
          : retentionTime as Duration,
      rejectionCriterion: rejectionCriterion == freezed
          ? _value.rejectionCriterion
          : rejectionCriterion as List<CodeableConcept>,
      handling: handling == freezed
          ? _value.handling
          : handling as List<SpecimenDefinitionHandling>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $SpecimenDefinitionContainerCopyWith<$Res> get container {
    if (_value.container == null) {
      return null;
    }
    return $SpecimenDefinitionContainerCopyWith<$Res>(_value.container,
        (value) {
      return _then(_value.copyWith(container: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get retentionTime {
    if (_value.retentionTime == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.retentionTime, (value) {
      return _then(_value.copyWith(retentionTime: value));
    });
  }
}

abstract class _$SpecimenDefinitionTypeTestedCopyWith<$Res>
    implements $SpecimenDefinitionTypeTestedCopyWith<$Res> {
  factory _$SpecimenDefinitionTypeTestedCopyWith(
          _SpecimenDefinitionTypeTested value,
          $Res Function(_SpecimenDefinitionTypeTested) then) =
      __$SpecimenDefinitionTypeTestedCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean isDerived,
      CodeableConcept type,
      @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
          TypeTestedPreference preference,
      SpecimenDefinitionContainer container,
      String requirement,
      Duration retentionTime,
      List<CodeableConcept> rejectionCriterion,
      List<SpecimenDefinitionHandling> handling});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $SpecimenDefinitionContainerCopyWith<$Res> get container;
  @override
  $DurationCopyWith<$Res> get retentionTime;
}

class __$SpecimenDefinitionTypeTestedCopyWithImpl<$Res>
    extends _$SpecimenDefinitionTypeTestedCopyWithImpl<$Res>
    implements _$SpecimenDefinitionTypeTestedCopyWith<$Res> {
  __$SpecimenDefinitionTypeTestedCopyWithImpl(
      _SpecimenDefinitionTypeTested _value,
      $Res Function(_SpecimenDefinitionTypeTested) _then)
      : super(_value, (v) => _then(v as _SpecimenDefinitionTypeTested));

  @override
  _SpecimenDefinitionTypeTested get _value =>
      super._value as _SpecimenDefinitionTypeTested;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object isDerived = freezed,
    Object type = freezed,
    Object preference = freezed,
    Object container = freezed,
    Object requirement = freezed,
    Object retentionTime = freezed,
    Object rejectionCriterion = freezed,
    Object handling = freezed,
  }) {
    return _then(_SpecimenDefinitionTypeTested(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      isDerived: isDerived == freezed ? _value.isDerived : isDerived as Boolean,
      type: type == freezed ? _value.type : type as CodeableConcept,
      preference: preference == freezed
          ? _value.preference
          : preference as TypeTestedPreference,
      container: container == freezed
          ? _value.container
          : container as SpecimenDefinitionContainer,
      requirement:
          requirement == freezed ? _value.requirement : requirement as String,
      retentionTime: retentionTime == freezed
          ? _value.retentionTime
          : retentionTime as Duration,
      rejectionCriterion: rejectionCriterion == freezed
          ? _value.rejectionCriterion
          : rejectionCriterion as List<CodeableConcept>,
      handling: handling == freezed
          ? _value.handling
          : handling as List<SpecimenDefinitionHandling>,
    ));
  }
}

@JsonSerializable()
class _$_SpecimenDefinitionTypeTested implements _SpecimenDefinitionTypeTested {
  const _$_SpecimenDefinitionTypeTested(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.isDerived,
      this.type,
      @JsonKey(unknownEnumValue: TypeTestedPreference.unknown) this.preference,
      this.container,
      this.requirement,
      this.retentionTime,
      this.rejectionCriterion,
      this.handling});

  factory _$_SpecimenDefinitionTypeTested.fromJson(Map<String, dynamic> json) =>
      _$_$_SpecimenDefinitionTypeTestedFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Boolean isDerived;
  @override
  final CodeableConcept type;
  @override
  @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
  final TypeTestedPreference preference;
  @override
  final SpecimenDefinitionContainer container;
  @override
  final String requirement;
  @override
  final Duration retentionTime;
  @override
  final List<CodeableConcept> rejectionCriterion;
  @override
  final List<SpecimenDefinitionHandling> handling;

  @override
  String toString() {
    return 'SpecimenDefinitionTypeTested(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, isDerived: $isDerived, type: $type, preference: $preference, container: $container, requirement: $requirement, retentionTime: $retentionTime, rejectionCriterion: $rejectionCriterion, handling: $handling)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenDefinitionTypeTested &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.isDerived, isDerived) ||
                const DeepCollectionEquality()
                    .equals(other.isDerived, isDerived)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.preference, preference) ||
                const DeepCollectionEquality()
                    .equals(other.preference, preference)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.requirement, requirement) ||
                const DeepCollectionEquality()
                    .equals(other.requirement, requirement)) &&
            (identical(other.retentionTime, retentionTime) ||
                const DeepCollectionEquality()
                    .equals(other.retentionTime, retentionTime)) &&
            (identical(other.rejectionCriterion, rejectionCriterion) ||
                const DeepCollectionEquality()
                    .equals(other.rejectionCriterion, rejectionCriterion)) &&
            (identical(other.handling, handling) ||
                const DeepCollectionEquality()
                    .equals(other.handling, handling)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(isDerived) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(preference) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(requirement) ^
      const DeepCollectionEquality().hash(retentionTime) ^
      const DeepCollectionEquality().hash(rejectionCriterion) ^
      const DeepCollectionEquality().hash(handling);

  @override
  _$SpecimenDefinitionTypeTestedCopyWith<_SpecimenDefinitionTypeTested>
      get copyWith => __$SpecimenDefinitionTypeTestedCopyWithImpl<
          _SpecimenDefinitionTypeTested>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SpecimenDefinitionTypeTestedToJson(this);
  }
}

abstract class _SpecimenDefinitionTypeTested
    implements SpecimenDefinitionTypeTested {
  const factory _SpecimenDefinitionTypeTested(
          {String id,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Boolean isDerived,
          CodeableConcept type,
          @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
              TypeTestedPreference preference,
          SpecimenDefinitionContainer container,
          String requirement,
          Duration retentionTime,
          List<CodeableConcept> rejectionCriterion,
          List<SpecimenDefinitionHandling> handling}) =
      _$_SpecimenDefinitionTypeTested;

  factory _SpecimenDefinitionTypeTested.fromJson(Map<String, dynamic> json) =
      _$_SpecimenDefinitionTypeTested.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Boolean get isDerived;
  @override
  CodeableConcept get type;
  @override
  @JsonKey(unknownEnumValue: TypeTestedPreference.unknown)
  TypeTestedPreference get preference;
  @override
  SpecimenDefinitionContainer get container;
  @override
  String get requirement;
  @override
  Duration get retentionTime;
  @override
  List<CodeableConcept> get rejectionCriterion;
  @override
  List<SpecimenDefinitionHandling> get handling;
  @override
  _$SpecimenDefinitionTypeTestedCopyWith<_SpecimenDefinitionTypeTested>
      get copyWith;
}

SpecimenDefinitionContainer _$SpecimenDefinitionContainerFromJson(
    Map<String, dynamic> json) {
  return _SpecimenDefinitionContainer.fromJson(json);
}

class _$SpecimenDefinitionContainerTearOff {
  const _$SpecimenDefinitionContainerTearOff();

  _SpecimenDefinitionContainer call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      CodeableConcept cap,
      String description,
      Quantity capacity,
      Quantity minimumVolumeQuantity,
      String minimumVolumeString,
      List<SpecimenDefinitionAdditive> additive,
      String preparation}) {
    return _SpecimenDefinitionContainer(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      material: material,
      type: type,
      cap: cap,
      description: description,
      capacity: capacity,
      minimumVolumeQuantity: minimumVolumeQuantity,
      minimumVolumeString: minimumVolumeString,
      additive: additive,
      preparation: preparation,
    );
  }
}

// ignore: unused_element
const $SpecimenDefinitionContainer = _$SpecimenDefinitionContainerTearOff();

mixin _$SpecimenDefinitionContainer {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get material;
  CodeableConcept get type;
  CodeableConcept get cap;
  String get description;
  Quantity get capacity;
  Quantity get minimumVolumeQuantity;
  String get minimumVolumeString;
  List<SpecimenDefinitionAdditive> get additive;
  String get preparation;

  Map<String, dynamic> toJson();
  $SpecimenDefinitionContainerCopyWith<SpecimenDefinitionContainer>
      get copyWith;
}

abstract class $SpecimenDefinitionContainerCopyWith<$Res> {
  factory $SpecimenDefinitionContainerCopyWith(
          SpecimenDefinitionContainer value,
          $Res Function(SpecimenDefinitionContainer) then) =
      _$SpecimenDefinitionContainerCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      CodeableConcept cap,
      String description,
      Quantity capacity,
      Quantity minimumVolumeQuantity,
      String minimumVolumeString,
      List<SpecimenDefinitionAdditive> additive,
      String preparation});

  $CodeableConceptCopyWith<$Res> get material;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get cap;
  $QuantityCopyWith<$Res> get capacity;
  $QuantityCopyWith<$Res> get minimumVolumeQuantity;
}

class _$SpecimenDefinitionContainerCopyWithImpl<$Res>
    implements $SpecimenDefinitionContainerCopyWith<$Res> {
  _$SpecimenDefinitionContainerCopyWithImpl(this._value, this._then);

  final SpecimenDefinitionContainer _value;
  // ignore: unused_field
  final $Res Function(SpecimenDefinitionContainer) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object material = freezed,
    Object type = freezed,
    Object cap = freezed,
    Object description = freezed,
    Object capacity = freezed,
    Object minimumVolumeQuantity = freezed,
    Object minimumVolumeString = freezed,
    Object additive = freezed,
    Object preparation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      material:
          material == freezed ? _value.material : material as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      cap: cap == freezed ? _value.cap : cap as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      capacity: capacity == freezed ? _value.capacity : capacity as Quantity,
      minimumVolumeQuantity: minimumVolumeQuantity == freezed
          ? _value.minimumVolumeQuantity
          : minimumVolumeQuantity as Quantity,
      minimumVolumeString: minimumVolumeString == freezed
          ? _value.minimumVolumeString
          : minimumVolumeString as String,
      additive: additive == freezed
          ? _value.additive
          : additive as List<SpecimenDefinitionAdditive>,
      preparation:
          preparation == freezed ? _value.preparation : preparation as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get material {
    if (_value.material == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.material, (value) {
      return _then(_value.copyWith(material: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get cap {
    if (_value.cap == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.cap, (value) {
      return _then(_value.copyWith(cap: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get capacity {
    if (_value.capacity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.capacity, (value) {
      return _then(_value.copyWith(capacity: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get minimumVolumeQuantity {
    if (_value.minimumVolumeQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.minimumVolumeQuantity, (value) {
      return _then(_value.copyWith(minimumVolumeQuantity: value));
    });
  }
}

abstract class _$SpecimenDefinitionContainerCopyWith<$Res>
    implements $SpecimenDefinitionContainerCopyWith<$Res> {
  factory _$SpecimenDefinitionContainerCopyWith(
          _SpecimenDefinitionContainer value,
          $Res Function(_SpecimenDefinitionContainer) then) =
      __$SpecimenDefinitionContainerCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      CodeableConcept cap,
      String description,
      Quantity capacity,
      Quantity minimumVolumeQuantity,
      String minimumVolumeString,
      List<SpecimenDefinitionAdditive> additive,
      String preparation});

  @override
  $CodeableConceptCopyWith<$Res> get material;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get cap;
  @override
  $QuantityCopyWith<$Res> get capacity;
  @override
  $QuantityCopyWith<$Res> get minimumVolumeQuantity;
}

class __$SpecimenDefinitionContainerCopyWithImpl<$Res>
    extends _$SpecimenDefinitionContainerCopyWithImpl<$Res>
    implements _$SpecimenDefinitionContainerCopyWith<$Res> {
  __$SpecimenDefinitionContainerCopyWithImpl(
      _SpecimenDefinitionContainer _value,
      $Res Function(_SpecimenDefinitionContainer) _then)
      : super(_value, (v) => _then(v as _SpecimenDefinitionContainer));

  @override
  _SpecimenDefinitionContainer get _value =>
      super._value as _SpecimenDefinitionContainer;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object material = freezed,
    Object type = freezed,
    Object cap = freezed,
    Object description = freezed,
    Object capacity = freezed,
    Object minimumVolumeQuantity = freezed,
    Object minimumVolumeString = freezed,
    Object additive = freezed,
    Object preparation = freezed,
  }) {
    return _then(_SpecimenDefinitionContainer(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      material:
          material == freezed ? _value.material : material as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      cap: cap == freezed ? _value.cap : cap as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      capacity: capacity == freezed ? _value.capacity : capacity as Quantity,
      minimumVolumeQuantity: minimumVolumeQuantity == freezed
          ? _value.minimumVolumeQuantity
          : minimumVolumeQuantity as Quantity,
      minimumVolumeString: minimumVolumeString == freezed
          ? _value.minimumVolumeString
          : minimumVolumeString as String,
      additive: additive == freezed
          ? _value.additive
          : additive as List<SpecimenDefinitionAdditive>,
      preparation:
          preparation == freezed ? _value.preparation : preparation as String,
    ));
  }
}

@JsonSerializable()
class _$_SpecimenDefinitionContainer implements _SpecimenDefinitionContainer {
  const _$_SpecimenDefinitionContainer(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.material,
      this.type,
      this.cap,
      this.description,
      this.capacity,
      this.minimumVolumeQuantity,
      this.minimumVolumeString,
      this.additive,
      this.preparation});

  factory _$_SpecimenDefinitionContainer.fromJson(Map<String, dynamic> json) =>
      _$_$_SpecimenDefinitionContainerFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept material;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept cap;
  @override
  final String description;
  @override
  final Quantity capacity;
  @override
  final Quantity minimumVolumeQuantity;
  @override
  final String minimumVolumeString;
  @override
  final List<SpecimenDefinitionAdditive> additive;
  @override
  final String preparation;

  @override
  String toString() {
    return 'SpecimenDefinitionContainer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, material: $material, type: $type, cap: $cap, description: $description, capacity: $capacity, minimumVolumeQuantity: $minimumVolumeQuantity, minimumVolumeString: $minimumVolumeString, additive: $additive, preparation: $preparation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenDefinitionContainer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.material, material) ||
                const DeepCollectionEquality()
                    .equals(other.material, material)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.cap, cap) ||
                const DeepCollectionEquality().equals(other.cap, cap)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.capacity, capacity) ||
                const DeepCollectionEquality()
                    .equals(other.capacity, capacity)) &&
            (identical(other.minimumVolumeQuantity, minimumVolumeQuantity) ||
                const DeepCollectionEquality().equals(
                    other.minimumVolumeQuantity, minimumVolumeQuantity)) &&
            (identical(other.minimumVolumeString, minimumVolumeString) ||
                const DeepCollectionEquality()
                    .equals(other.minimumVolumeString, minimumVolumeString)) &&
            (identical(other.additive, additive) ||
                const DeepCollectionEquality()
                    .equals(other.additive, additive)) &&
            (identical(other.preparation, preparation) ||
                const DeepCollectionEquality()
                    .equals(other.preparation, preparation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(material) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(cap) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(capacity) ^
      const DeepCollectionEquality().hash(minimumVolumeQuantity) ^
      const DeepCollectionEquality().hash(minimumVolumeString) ^
      const DeepCollectionEquality().hash(additive) ^
      const DeepCollectionEquality().hash(preparation);

  @override
  _$SpecimenDefinitionContainerCopyWith<_SpecimenDefinitionContainer>
      get copyWith => __$SpecimenDefinitionContainerCopyWithImpl<
          _SpecimenDefinitionContainer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SpecimenDefinitionContainerToJson(this);
  }
}

abstract class _SpecimenDefinitionContainer
    implements SpecimenDefinitionContainer {
  const factory _SpecimenDefinitionContainer(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      CodeableConcept cap,
      String description,
      Quantity capacity,
      Quantity minimumVolumeQuantity,
      String minimumVolumeString,
      List<SpecimenDefinitionAdditive> additive,
      String preparation}) = _$_SpecimenDefinitionContainer;

  factory _SpecimenDefinitionContainer.fromJson(Map<String, dynamic> json) =
      _$_SpecimenDefinitionContainer.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get material;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get cap;
  @override
  String get description;
  @override
  Quantity get capacity;
  @override
  Quantity get minimumVolumeQuantity;
  @override
  String get minimumVolumeString;
  @override
  List<SpecimenDefinitionAdditive> get additive;
  @override
  String get preparation;
  @override
  _$SpecimenDefinitionContainerCopyWith<_SpecimenDefinitionContainer>
      get copyWith;
}

SpecimenDefinitionAdditive _$SpecimenDefinitionAdditiveFromJson(
    Map<String, dynamic> json) {
  return _SpecimenDefinitionAdditive.fromJson(json);
}

class _$SpecimenDefinitionAdditiveTearOff {
  const _$SpecimenDefinitionAdditiveTearOff();

  _SpecimenDefinitionAdditive call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept additiveCodeableConcept,
      Reference additiveReference}) {
    return _SpecimenDefinitionAdditive(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      additiveCodeableConcept: additiveCodeableConcept,
      additiveReference: additiveReference,
    );
  }
}

// ignore: unused_element
const $SpecimenDefinitionAdditive = _$SpecimenDefinitionAdditiveTearOff();

mixin _$SpecimenDefinitionAdditive {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get additiveCodeableConcept;
  Reference get additiveReference;

  Map<String, dynamic> toJson();
  $SpecimenDefinitionAdditiveCopyWith<SpecimenDefinitionAdditive> get copyWith;
}

abstract class $SpecimenDefinitionAdditiveCopyWith<$Res> {
  factory $SpecimenDefinitionAdditiveCopyWith(SpecimenDefinitionAdditive value,
          $Res Function(SpecimenDefinitionAdditive) then) =
      _$SpecimenDefinitionAdditiveCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept additiveCodeableConcept,
      Reference additiveReference});

  $CodeableConceptCopyWith<$Res> get additiveCodeableConcept;
  $ReferenceCopyWith<$Res> get additiveReference;
}

class _$SpecimenDefinitionAdditiveCopyWithImpl<$Res>
    implements $SpecimenDefinitionAdditiveCopyWith<$Res> {
  _$SpecimenDefinitionAdditiveCopyWithImpl(this._value, this._then);

  final SpecimenDefinitionAdditive _value;
  // ignore: unused_field
  final $Res Function(SpecimenDefinitionAdditive) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object additiveCodeableConcept = freezed,
    Object additiveReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      additiveCodeableConcept: additiveCodeableConcept == freezed
          ? _value.additiveCodeableConcept
          : additiveCodeableConcept as CodeableConcept,
      additiveReference: additiveReference == freezed
          ? _value.additiveReference
          : additiveReference as Reference,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get additiveCodeableConcept {
    if (_value.additiveCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.additiveCodeableConcept,
        (value) {
      return _then(_value.copyWith(additiveCodeableConcept: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get additiveReference {
    if (_value.additiveReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.additiveReference, (value) {
      return _then(_value.copyWith(additiveReference: value));
    });
  }
}

abstract class _$SpecimenDefinitionAdditiveCopyWith<$Res>
    implements $SpecimenDefinitionAdditiveCopyWith<$Res> {
  factory _$SpecimenDefinitionAdditiveCopyWith(
          _SpecimenDefinitionAdditive value,
          $Res Function(_SpecimenDefinitionAdditive) then) =
      __$SpecimenDefinitionAdditiveCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept additiveCodeableConcept,
      Reference additiveReference});

  @override
  $CodeableConceptCopyWith<$Res> get additiveCodeableConcept;
  @override
  $ReferenceCopyWith<$Res> get additiveReference;
}

class __$SpecimenDefinitionAdditiveCopyWithImpl<$Res>
    extends _$SpecimenDefinitionAdditiveCopyWithImpl<$Res>
    implements _$SpecimenDefinitionAdditiveCopyWith<$Res> {
  __$SpecimenDefinitionAdditiveCopyWithImpl(_SpecimenDefinitionAdditive _value,
      $Res Function(_SpecimenDefinitionAdditive) _then)
      : super(_value, (v) => _then(v as _SpecimenDefinitionAdditive));

  @override
  _SpecimenDefinitionAdditive get _value =>
      super._value as _SpecimenDefinitionAdditive;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object additiveCodeableConcept = freezed,
    Object additiveReference = freezed,
  }) {
    return _then(_SpecimenDefinitionAdditive(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      additiveCodeableConcept: additiveCodeableConcept == freezed
          ? _value.additiveCodeableConcept
          : additiveCodeableConcept as CodeableConcept,
      additiveReference: additiveReference == freezed
          ? _value.additiveReference
          : additiveReference as Reference,
    ));
  }
}

@JsonSerializable()
class _$_SpecimenDefinitionAdditive implements _SpecimenDefinitionAdditive {
  const _$_SpecimenDefinitionAdditive(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.additiveCodeableConcept,
      this.additiveReference});

  factory _$_SpecimenDefinitionAdditive.fromJson(Map<String, dynamic> json) =>
      _$_$_SpecimenDefinitionAdditiveFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept additiveCodeableConcept;
  @override
  final Reference additiveReference;

  @override
  String toString() {
    return 'SpecimenDefinitionAdditive(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, additiveCodeableConcept: $additiveCodeableConcept, additiveReference: $additiveReference)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenDefinitionAdditive &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(
                    other.additiveCodeableConcept, additiveCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.additiveCodeableConcept, additiveCodeableConcept)) &&
            (identical(other.additiveReference, additiveReference) ||
                const DeepCollectionEquality()
                    .equals(other.additiveReference, additiveReference)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(additiveCodeableConcept) ^
      const DeepCollectionEquality().hash(additiveReference);

  @override
  _$SpecimenDefinitionAdditiveCopyWith<_SpecimenDefinitionAdditive>
      get copyWith => __$SpecimenDefinitionAdditiveCopyWithImpl<
          _SpecimenDefinitionAdditive>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SpecimenDefinitionAdditiveToJson(this);
  }
}

abstract class _SpecimenDefinitionAdditive
    implements SpecimenDefinitionAdditive {
  const factory _SpecimenDefinitionAdditive(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept additiveCodeableConcept,
      Reference additiveReference}) = _$_SpecimenDefinitionAdditive;

  factory _SpecimenDefinitionAdditive.fromJson(Map<String, dynamic> json) =
      _$_SpecimenDefinitionAdditive.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get additiveCodeableConcept;
  @override
  Reference get additiveReference;
  @override
  _$SpecimenDefinitionAdditiveCopyWith<_SpecimenDefinitionAdditive>
      get copyWith;
}

SpecimenDefinitionHandling _$SpecimenDefinitionHandlingFromJson(
    Map<String, dynamic> json) {
  return _SpecimenDefinitionHandling.fromJson(json);
}

class _$SpecimenDefinitionHandlingTearOff {
  const _$SpecimenDefinitionHandlingTearOff();

  _SpecimenDefinitionHandling call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept temperatureQualifier,
      Range temperatureRange,
      Duration maxDuration,
      String instruction}) {
    return _SpecimenDefinitionHandling(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      temperatureQualifier: temperatureQualifier,
      temperatureRange: temperatureRange,
      maxDuration: maxDuration,
      instruction: instruction,
    );
  }
}

// ignore: unused_element
const $SpecimenDefinitionHandling = _$SpecimenDefinitionHandlingTearOff();

mixin _$SpecimenDefinitionHandling {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get temperatureQualifier;
  Range get temperatureRange;
  Duration get maxDuration;
  String get instruction;

  Map<String, dynamic> toJson();
  $SpecimenDefinitionHandlingCopyWith<SpecimenDefinitionHandling> get copyWith;
}

abstract class $SpecimenDefinitionHandlingCopyWith<$Res> {
  factory $SpecimenDefinitionHandlingCopyWith(SpecimenDefinitionHandling value,
          $Res Function(SpecimenDefinitionHandling) then) =
      _$SpecimenDefinitionHandlingCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept temperatureQualifier,
      Range temperatureRange,
      Duration maxDuration,
      String instruction});

  $CodeableConceptCopyWith<$Res> get temperatureQualifier;
  $RangeCopyWith<$Res> get temperatureRange;
  $DurationCopyWith<$Res> get maxDuration;
}

class _$SpecimenDefinitionHandlingCopyWithImpl<$Res>
    implements $SpecimenDefinitionHandlingCopyWith<$Res> {
  _$SpecimenDefinitionHandlingCopyWithImpl(this._value, this._then);

  final SpecimenDefinitionHandling _value;
  // ignore: unused_field
  final $Res Function(SpecimenDefinitionHandling) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object temperatureQualifier = freezed,
    Object temperatureRange = freezed,
    Object maxDuration = freezed,
    Object instruction = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      temperatureQualifier: temperatureQualifier == freezed
          ? _value.temperatureQualifier
          : temperatureQualifier as CodeableConcept,
      temperatureRange: temperatureRange == freezed
          ? _value.temperatureRange
          : temperatureRange as Range,
      maxDuration:
          maxDuration == freezed ? _value.maxDuration : maxDuration as Duration,
      instruction:
          instruction == freezed ? _value.instruction : instruction as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get temperatureQualifier {
    if (_value.temperatureQualifier == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.temperatureQualifier, (value) {
      return _then(_value.copyWith(temperatureQualifier: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get temperatureRange {
    if (_value.temperatureRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.temperatureRange, (value) {
      return _then(_value.copyWith(temperatureRange: value));
    });
  }

  @override
  $DurationCopyWith<$Res> get maxDuration {
    if (_value.maxDuration == null) {
      return null;
    }
    return $DurationCopyWith<$Res>(_value.maxDuration, (value) {
      return _then(_value.copyWith(maxDuration: value));
    });
  }
}

abstract class _$SpecimenDefinitionHandlingCopyWith<$Res>
    implements $SpecimenDefinitionHandlingCopyWith<$Res> {
  factory _$SpecimenDefinitionHandlingCopyWith(
          _SpecimenDefinitionHandling value,
          $Res Function(_SpecimenDefinitionHandling) then) =
      __$SpecimenDefinitionHandlingCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept temperatureQualifier,
      Range temperatureRange,
      Duration maxDuration,
      String instruction});

  @override
  $CodeableConceptCopyWith<$Res> get temperatureQualifier;
  @override
  $RangeCopyWith<$Res> get temperatureRange;
  @override
  $DurationCopyWith<$Res> get maxDuration;
}

class __$SpecimenDefinitionHandlingCopyWithImpl<$Res>
    extends _$SpecimenDefinitionHandlingCopyWithImpl<$Res>
    implements _$SpecimenDefinitionHandlingCopyWith<$Res> {
  __$SpecimenDefinitionHandlingCopyWithImpl(_SpecimenDefinitionHandling _value,
      $Res Function(_SpecimenDefinitionHandling) _then)
      : super(_value, (v) => _then(v as _SpecimenDefinitionHandling));

  @override
  _SpecimenDefinitionHandling get _value =>
      super._value as _SpecimenDefinitionHandling;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object temperatureQualifier = freezed,
    Object temperatureRange = freezed,
    Object maxDuration = freezed,
    Object instruction = freezed,
  }) {
    return _then(_SpecimenDefinitionHandling(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      temperatureQualifier: temperatureQualifier == freezed
          ? _value.temperatureQualifier
          : temperatureQualifier as CodeableConcept,
      temperatureRange: temperatureRange == freezed
          ? _value.temperatureRange
          : temperatureRange as Range,
      maxDuration:
          maxDuration == freezed ? _value.maxDuration : maxDuration as Duration,
      instruction:
          instruction == freezed ? _value.instruction : instruction as String,
    ));
  }
}

@JsonSerializable()
class _$_SpecimenDefinitionHandling implements _SpecimenDefinitionHandling {
  const _$_SpecimenDefinitionHandling(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.temperatureQualifier,
      this.temperatureRange,
      this.maxDuration,
      this.instruction});

  factory _$_SpecimenDefinitionHandling.fromJson(Map<String, dynamic> json) =>
      _$_$_SpecimenDefinitionHandlingFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept temperatureQualifier;
  @override
  final Range temperatureRange;
  @override
  final Duration maxDuration;
  @override
  final String instruction;

  @override
  String toString() {
    return 'SpecimenDefinitionHandling(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, temperatureQualifier: $temperatureQualifier, temperatureRange: $temperatureRange, maxDuration: $maxDuration, instruction: $instruction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenDefinitionHandling &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.temperatureQualifier, temperatureQualifier) ||
                const DeepCollectionEquality().equals(
                    other.temperatureQualifier, temperatureQualifier)) &&
            (identical(other.temperatureRange, temperatureRange) ||
                const DeepCollectionEquality()
                    .equals(other.temperatureRange, temperatureRange)) &&
            (identical(other.maxDuration, maxDuration) ||
                const DeepCollectionEquality()
                    .equals(other.maxDuration, maxDuration)) &&
            (identical(other.instruction, instruction) ||
                const DeepCollectionEquality()
                    .equals(other.instruction, instruction)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(temperatureQualifier) ^
      const DeepCollectionEquality().hash(temperatureRange) ^
      const DeepCollectionEquality().hash(maxDuration) ^
      const DeepCollectionEquality().hash(instruction);

  @override
  _$SpecimenDefinitionHandlingCopyWith<_SpecimenDefinitionHandling>
      get copyWith => __$SpecimenDefinitionHandlingCopyWithImpl<
          _SpecimenDefinitionHandling>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SpecimenDefinitionHandlingToJson(this);
  }
}

abstract class _SpecimenDefinitionHandling
    implements SpecimenDefinitionHandling {
  const factory _SpecimenDefinitionHandling(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept temperatureQualifier,
      Range temperatureRange,
      Duration maxDuration,
      String instruction}) = _$_SpecimenDefinitionHandling;

  factory _SpecimenDefinitionHandling.fromJson(Map<String, dynamic> json) =
      _$_SpecimenDefinitionHandling.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get temperatureQualifier;
  @override
  Range get temperatureRange;
  @override
  Duration get maxDuration;
  @override
  String get instruction;
  @override
  _$SpecimenDefinitionHandlingCopyWith<_SpecimenDefinitionHandling>
      get copyWith;
}

SubstanceNucleicAcid _$SubstanceNucleicAcidFromJson(Map<String, dynamic> json) {
  return _SubstanceNucleicAcid.fromJson(json);
}

class _$SubstanceNucleicAcidTearOff {
  const _$SubstanceNucleicAcidTearOff();

  _SubstanceNucleicAcid call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      String areaOfHybridisation,
      CodeableConcept oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit> subunit}) {
    return _SubstanceNucleicAcid(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      sequenceType: sequenceType,
      numberOfSubunits: numberOfSubunits,
      areaOfHybridisation: areaOfHybridisation,
      oligoNucleotideType: oligoNucleotideType,
      subunit: subunit,
    );
  }
}

// ignore: unused_element
const $SubstanceNucleicAcid = _$SubstanceNucleicAcidTearOff();

mixin _$SubstanceNucleicAcid {
  @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get sequenceType;
  Integer get numberOfSubunits;
  String get areaOfHybridisation;
  CodeableConcept get oligoNucleotideType;
  List<SubstanceNucleicAcidSubunit> get subunit;

  Map<String, dynamic> toJson();
  $SubstanceNucleicAcidCopyWith<SubstanceNucleicAcid> get copyWith;
}

abstract class $SubstanceNucleicAcidCopyWith<$Res> {
  factory $SubstanceNucleicAcidCopyWith(SubstanceNucleicAcid value,
          $Res Function(SubstanceNucleicAcid) then) =
      _$SubstanceNucleicAcidCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      String areaOfHybridisation,
      CodeableConcept oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit> subunit});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get sequenceType;
  $CodeableConceptCopyWith<$Res> get oligoNucleotideType;
}

class _$SubstanceNucleicAcidCopyWithImpl<$Res>
    implements $SubstanceNucleicAcidCopyWith<$Res> {
  _$SubstanceNucleicAcidCopyWithImpl(this._value, this._then);

  final SubstanceNucleicAcid _value;
  // ignore: unused_field
  final $Res Function(SubstanceNucleicAcid) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sequenceType = freezed,
    Object numberOfSubunits = freezed,
    Object areaOfHybridisation = freezed,
    Object oligoNucleotideType = freezed,
    Object subunit = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sequenceType: sequenceType == freezed
          ? _value.sequenceType
          : sequenceType as CodeableConcept,
      numberOfSubunits: numberOfSubunits == freezed
          ? _value.numberOfSubunits
          : numberOfSubunits as Integer,
      areaOfHybridisation: areaOfHybridisation == freezed
          ? _value.areaOfHybridisation
          : areaOfHybridisation as String,
      oligoNucleotideType: oligoNucleotideType == freezed
          ? _value.oligoNucleotideType
          : oligoNucleotideType as CodeableConcept,
      subunit: subunit == freezed
          ? _value.subunit
          : subunit as List<SubstanceNucleicAcidSubunit>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get sequenceType {
    if (_value.sequenceType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.sequenceType, (value) {
      return _then(_value.copyWith(sequenceType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get oligoNucleotideType {
    if (_value.oligoNucleotideType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.oligoNucleotideType, (value) {
      return _then(_value.copyWith(oligoNucleotideType: value));
    });
  }
}

abstract class _$SubstanceNucleicAcidCopyWith<$Res>
    implements $SubstanceNucleicAcidCopyWith<$Res> {
  factory _$SubstanceNucleicAcidCopyWith(_SubstanceNucleicAcid value,
          $Res Function(_SubstanceNucleicAcid) then) =
      __$SubstanceNucleicAcidCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      String areaOfHybridisation,
      CodeableConcept oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit> subunit});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get sequenceType;
  @override
  $CodeableConceptCopyWith<$Res> get oligoNucleotideType;
}

class __$SubstanceNucleicAcidCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidCopyWithImpl<$Res>
    implements _$SubstanceNucleicAcidCopyWith<$Res> {
  __$SubstanceNucleicAcidCopyWithImpl(
      _SubstanceNucleicAcid _value, $Res Function(_SubstanceNucleicAcid) _then)
      : super(_value, (v) => _then(v as _SubstanceNucleicAcid));

  @override
  _SubstanceNucleicAcid get _value => super._value as _SubstanceNucleicAcid;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sequenceType = freezed,
    Object numberOfSubunits = freezed,
    Object areaOfHybridisation = freezed,
    Object oligoNucleotideType = freezed,
    Object subunit = freezed,
  }) {
    return _then(_SubstanceNucleicAcid(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sequenceType: sequenceType == freezed
          ? _value.sequenceType
          : sequenceType as CodeableConcept,
      numberOfSubunits: numberOfSubunits == freezed
          ? _value.numberOfSubunits
          : numberOfSubunits as Integer,
      areaOfHybridisation: areaOfHybridisation == freezed
          ? _value.areaOfHybridisation
          : areaOfHybridisation as String,
      oligoNucleotideType: oligoNucleotideType == freezed
          ? _value.oligoNucleotideType
          : oligoNucleotideType as CodeableConcept,
      subunit: subunit == freezed
          ? _value.subunit
          : subunit as List<SubstanceNucleicAcidSubunit>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceNucleicAcid implements _SubstanceNucleicAcid {
  const _$_SubstanceNucleicAcid(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.sequenceType,
      this.numberOfSubunits,
      this.areaOfHybridisation,
      this.oligoNucleotideType,
      this.subunit})
      : assert(resourceType != null);

  factory _$_SubstanceNucleicAcid.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceNucleicAcidFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept sequenceType;
  @override
  final Integer numberOfSubunits;
  @override
  final String areaOfHybridisation;
  @override
  final CodeableConcept oligoNucleotideType;
  @override
  final List<SubstanceNucleicAcidSubunit> subunit;

  @override
  String toString() {
    return 'SubstanceNucleicAcid(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sequenceType: $sequenceType, numberOfSubunits: $numberOfSubunits, areaOfHybridisation: $areaOfHybridisation, oligoNucleotideType: $oligoNucleotideType, subunit: $subunit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceNucleicAcid &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.sequenceType, sequenceType) ||
                const DeepCollectionEquality()
                    .equals(other.sequenceType, sequenceType)) &&
            (identical(other.numberOfSubunits, numberOfSubunits) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfSubunits, numberOfSubunits)) &&
            (identical(other.areaOfHybridisation, areaOfHybridisation) ||
                const DeepCollectionEquality()
                    .equals(other.areaOfHybridisation, areaOfHybridisation)) &&
            (identical(other.oligoNucleotideType, oligoNucleotideType) ||
                const DeepCollectionEquality()
                    .equals(other.oligoNucleotideType, oligoNucleotideType)) &&
            (identical(other.subunit, subunit) ||
                const DeepCollectionEquality().equals(other.subunit, subunit)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(sequenceType) ^
      const DeepCollectionEquality().hash(numberOfSubunits) ^
      const DeepCollectionEquality().hash(areaOfHybridisation) ^
      const DeepCollectionEquality().hash(oligoNucleotideType) ^
      const DeepCollectionEquality().hash(subunit);

  @override
  _$SubstanceNucleicAcidCopyWith<_SubstanceNucleicAcid> get copyWith =>
      __$SubstanceNucleicAcidCopyWithImpl<_SubstanceNucleicAcid>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceNucleicAcidToJson(this);
  }
}

abstract class _SubstanceNucleicAcid implements SubstanceNucleicAcid {
  const factory _SubstanceNucleicAcid(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      String areaOfHybridisation,
      CodeableConcept oligoNucleotideType,
      List<SubstanceNucleicAcidSubunit> subunit}) = _$_SubstanceNucleicAcid;

  factory _SubstanceNucleicAcid.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcid.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceNucleicAcid')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get sequenceType;
  @override
  Integer get numberOfSubunits;
  @override
  String get areaOfHybridisation;
  @override
  CodeableConcept get oligoNucleotideType;
  @override
  List<SubstanceNucleicAcidSubunit> get subunit;
  @override
  _$SubstanceNucleicAcidCopyWith<_SubstanceNucleicAcid> get copyWith;
}

SubstanceNucleicAcidSubunit _$SubstanceNucleicAcidSubunitFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidSubunit.fromJson(json);
}

class _$SubstanceNucleicAcidSubunitTearOff {
  const _$SubstanceNucleicAcidSubunitTearOff();

  _SubstanceNucleicAcidSubunit call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      CodeableConcept fivePrime,
      CodeableConcept threePrime,
      List<SubstanceNucleicAcidLinkage> linkage,
      List<SubstanceNucleicAcidSugar> sugar}) {
    return _SubstanceNucleicAcidSubunit(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subunit: subunit,
      sequence: sequence,
      length: length,
      sequenceAttachment: sequenceAttachment,
      fivePrime: fivePrime,
      threePrime: threePrime,
      linkage: linkage,
      sugar: sugar,
    );
  }
}

// ignore: unused_element
const $SubstanceNucleicAcidSubunit = _$SubstanceNucleicAcidSubunitTearOff();

mixin _$SubstanceNucleicAcidSubunit {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get subunit;
  String get sequence;
  Integer get length;
  Attachment get sequenceAttachment;
  CodeableConcept get fivePrime;
  CodeableConcept get threePrime;
  List<SubstanceNucleicAcidLinkage> get linkage;
  List<SubstanceNucleicAcidSugar> get sugar;

  Map<String, dynamic> toJson();
  $SubstanceNucleicAcidSubunitCopyWith<SubstanceNucleicAcidSubunit>
      get copyWith;
}

abstract class $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  factory $SubstanceNucleicAcidSubunitCopyWith(
          SubstanceNucleicAcidSubunit value,
          $Res Function(SubstanceNucleicAcidSubunit) then) =
      _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      CodeableConcept fivePrime,
      CodeableConcept threePrime,
      List<SubstanceNucleicAcidLinkage> linkage,
      List<SubstanceNucleicAcidSugar> sugar});

  $AttachmentCopyWith<$Res> get sequenceAttachment;
  $CodeableConceptCopyWith<$Res> get fivePrime;
  $CodeableConceptCopyWith<$Res> get threePrime;
}

class _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res>
    implements $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  _$SubstanceNucleicAcidSubunitCopyWithImpl(this._value, this._then);

  final SubstanceNucleicAcidSubunit _value;
  // ignore: unused_field
  final $Res Function(SubstanceNucleicAcidSubunit) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subunit = freezed,
    Object sequence = freezed,
    Object length = freezed,
    Object sequenceAttachment = freezed,
    Object fivePrime = freezed,
    Object threePrime = freezed,
    Object linkage = freezed,
    Object sugar = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subunit: subunit == freezed ? _value.subunit : subunit as Integer,
      sequence: sequence == freezed ? _value.sequence : sequence as String,
      length: length == freezed ? _value.length : length as Integer,
      sequenceAttachment: sequenceAttachment == freezed
          ? _value.sequenceAttachment
          : sequenceAttachment as Attachment,
      fivePrime: fivePrime == freezed
          ? _value.fivePrime
          : fivePrime as CodeableConcept,
      threePrime: threePrime == freezed
          ? _value.threePrime
          : threePrime as CodeableConcept,
      linkage: linkage == freezed
          ? _value.linkage
          : linkage as List<SubstanceNucleicAcidLinkage>,
      sugar: sugar == freezed
          ? _value.sugar
          : sugar as List<SubstanceNucleicAcidSugar>,
    ));
  }

  @override
  $AttachmentCopyWith<$Res> get sequenceAttachment {
    if (_value.sequenceAttachment == null) {
      return null;
    }
    return $AttachmentCopyWith<$Res>(_value.sequenceAttachment, (value) {
      return _then(_value.copyWith(sequenceAttachment: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get fivePrime {
    if (_value.fivePrime == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.fivePrime, (value) {
      return _then(_value.copyWith(fivePrime: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get threePrime {
    if (_value.threePrime == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.threePrime, (value) {
      return _then(_value.copyWith(threePrime: value));
    });
  }
}

abstract class _$SubstanceNucleicAcidSubunitCopyWith<$Res>
    implements $SubstanceNucleicAcidSubunitCopyWith<$Res> {
  factory _$SubstanceNucleicAcidSubunitCopyWith(
          _SubstanceNucleicAcidSubunit value,
          $Res Function(_SubstanceNucleicAcidSubunit) then) =
      __$SubstanceNucleicAcidSubunitCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      CodeableConcept fivePrime,
      CodeableConcept threePrime,
      List<SubstanceNucleicAcidLinkage> linkage,
      List<SubstanceNucleicAcidSugar> sugar});

  @override
  $AttachmentCopyWith<$Res> get sequenceAttachment;
  @override
  $CodeableConceptCopyWith<$Res> get fivePrime;
  @override
  $CodeableConceptCopyWith<$Res> get threePrime;
}

class __$SubstanceNucleicAcidSubunitCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidSubunitCopyWithImpl<$Res>
    implements _$SubstanceNucleicAcidSubunitCopyWith<$Res> {
  __$SubstanceNucleicAcidSubunitCopyWithImpl(
      _SubstanceNucleicAcidSubunit _value,
      $Res Function(_SubstanceNucleicAcidSubunit) _then)
      : super(_value, (v) => _then(v as _SubstanceNucleicAcidSubunit));

  @override
  _SubstanceNucleicAcidSubunit get _value =>
      super._value as _SubstanceNucleicAcidSubunit;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subunit = freezed,
    Object sequence = freezed,
    Object length = freezed,
    Object sequenceAttachment = freezed,
    Object fivePrime = freezed,
    Object threePrime = freezed,
    Object linkage = freezed,
    Object sugar = freezed,
  }) {
    return _then(_SubstanceNucleicAcidSubunit(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subunit: subunit == freezed ? _value.subunit : subunit as Integer,
      sequence: sequence == freezed ? _value.sequence : sequence as String,
      length: length == freezed ? _value.length : length as Integer,
      sequenceAttachment: sequenceAttachment == freezed
          ? _value.sequenceAttachment
          : sequenceAttachment as Attachment,
      fivePrime: fivePrime == freezed
          ? _value.fivePrime
          : fivePrime as CodeableConcept,
      threePrime: threePrime == freezed
          ? _value.threePrime
          : threePrime as CodeableConcept,
      linkage: linkage == freezed
          ? _value.linkage
          : linkage as List<SubstanceNucleicAcidLinkage>,
      sugar: sugar == freezed
          ? _value.sugar
          : sugar as List<SubstanceNucleicAcidSugar>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceNucleicAcidSubunit implements _SubstanceNucleicAcidSubunit {
  const _$_SubstanceNucleicAcidSubunit(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.subunit,
      this.sequence,
      this.length,
      this.sequenceAttachment,
      this.fivePrime,
      this.threePrime,
      this.linkage,
      this.sugar});

  factory _$_SubstanceNucleicAcidSubunit.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceNucleicAcidSubunitFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer subunit;
  @override
  final String sequence;
  @override
  final Integer length;
  @override
  final Attachment sequenceAttachment;
  @override
  final CodeableConcept fivePrime;
  @override
  final CodeableConcept threePrime;
  @override
  final List<SubstanceNucleicAcidLinkage> linkage;
  @override
  final List<SubstanceNucleicAcidSugar> sugar;

  @override
  String toString() {
    return 'SubstanceNucleicAcidSubunit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, subunit: $subunit, sequence: $sequence, length: $length, sequenceAttachment: $sequenceAttachment, fivePrime: $fivePrime, threePrime: $threePrime, linkage: $linkage, sugar: $sugar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceNucleicAcidSubunit &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subunit, subunit) ||
                const DeepCollectionEquality()
                    .equals(other.subunit, subunit)) &&
            (identical(other.sequence, sequence) ||
                const DeepCollectionEquality()
                    .equals(other.sequence, sequence)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.sequenceAttachment, sequenceAttachment) ||
                const DeepCollectionEquality()
                    .equals(other.sequenceAttachment, sequenceAttachment)) &&
            (identical(other.fivePrime, fivePrime) ||
                const DeepCollectionEquality()
                    .equals(other.fivePrime, fivePrime)) &&
            (identical(other.threePrime, threePrime) ||
                const DeepCollectionEquality()
                    .equals(other.threePrime, threePrime)) &&
            (identical(other.linkage, linkage) ||
                const DeepCollectionEquality()
                    .equals(other.linkage, linkage)) &&
            (identical(other.sugar, sugar) ||
                const DeepCollectionEquality().equals(other.sugar, sugar)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subunit) ^
      const DeepCollectionEquality().hash(sequence) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(sequenceAttachment) ^
      const DeepCollectionEquality().hash(fivePrime) ^
      const DeepCollectionEquality().hash(threePrime) ^
      const DeepCollectionEquality().hash(linkage) ^
      const DeepCollectionEquality().hash(sugar);

  @override
  _$SubstanceNucleicAcidSubunitCopyWith<_SubstanceNucleicAcidSubunit>
      get copyWith => __$SubstanceNucleicAcidSubunitCopyWithImpl<
          _SubstanceNucleicAcidSubunit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceNucleicAcidSubunitToJson(this);
  }
}

abstract class _SubstanceNucleicAcidSubunit
    implements SubstanceNucleicAcidSubunit {
  const factory _SubstanceNucleicAcidSubunit(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      CodeableConcept fivePrime,
      CodeableConcept threePrime,
      List<SubstanceNucleicAcidLinkage> linkage,
      List<SubstanceNucleicAcidSugar> sugar}) = _$_SubstanceNucleicAcidSubunit;

  factory _SubstanceNucleicAcidSubunit.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidSubunit.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get subunit;
  @override
  String get sequence;
  @override
  Integer get length;
  @override
  Attachment get sequenceAttachment;
  @override
  CodeableConcept get fivePrime;
  @override
  CodeableConcept get threePrime;
  @override
  List<SubstanceNucleicAcidLinkage> get linkage;
  @override
  List<SubstanceNucleicAcidSugar> get sugar;
  @override
  _$SubstanceNucleicAcidSubunitCopyWith<_SubstanceNucleicAcidSubunit>
      get copyWith;
}

SubstanceNucleicAcidLinkage _$SubstanceNucleicAcidLinkageFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidLinkage.fromJson(json);
}

class _$SubstanceNucleicAcidLinkageTearOff {
  const _$SubstanceNucleicAcidLinkageTearOff();

  _SubstanceNucleicAcidLinkage call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String connectivity,
      Identifier identifier,
      String name,
      String residueSite}) {
    return _SubstanceNucleicAcidLinkage(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      connectivity: connectivity,
      identifier: identifier,
      name: name,
      residueSite: residueSite,
    );
  }
}

// ignore: unused_element
const $SubstanceNucleicAcidLinkage = _$SubstanceNucleicAcidLinkageTearOff();

mixin _$SubstanceNucleicAcidLinkage {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get connectivity;
  Identifier get identifier;
  String get name;
  String get residueSite;

  Map<String, dynamic> toJson();
  $SubstanceNucleicAcidLinkageCopyWith<SubstanceNucleicAcidLinkage>
      get copyWith;
}

abstract class $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  factory $SubstanceNucleicAcidLinkageCopyWith(
          SubstanceNucleicAcidLinkage value,
          $Res Function(SubstanceNucleicAcidLinkage) then) =
      _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String connectivity,
      Identifier identifier,
      String name,
      String residueSite});

  $IdentifierCopyWith<$Res> get identifier;
}

class _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res>
    implements $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  _$SubstanceNucleicAcidLinkageCopyWithImpl(this._value, this._then);

  final SubstanceNucleicAcidLinkage _value;
  // ignore: unused_field
  final $Res Function(SubstanceNucleicAcidLinkage) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object connectivity = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object residueSite = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      connectivity: connectivity == freezed
          ? _value.connectivity
          : connectivity as String,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      residueSite:
          residueSite == freezed ? _value.residueSite : residueSite as String,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }
}

abstract class _$SubstanceNucleicAcidLinkageCopyWith<$Res>
    implements $SubstanceNucleicAcidLinkageCopyWith<$Res> {
  factory _$SubstanceNucleicAcidLinkageCopyWith(
          _SubstanceNucleicAcidLinkage value,
          $Res Function(_SubstanceNucleicAcidLinkage) then) =
      __$SubstanceNucleicAcidLinkageCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String connectivity,
      Identifier identifier,
      String name,
      String residueSite});

  @override
  $IdentifierCopyWith<$Res> get identifier;
}

class __$SubstanceNucleicAcidLinkageCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidLinkageCopyWithImpl<$Res>
    implements _$SubstanceNucleicAcidLinkageCopyWith<$Res> {
  __$SubstanceNucleicAcidLinkageCopyWithImpl(
      _SubstanceNucleicAcidLinkage _value,
      $Res Function(_SubstanceNucleicAcidLinkage) _then)
      : super(_value, (v) => _then(v as _SubstanceNucleicAcidLinkage));

  @override
  _SubstanceNucleicAcidLinkage get _value =>
      super._value as _SubstanceNucleicAcidLinkage;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object connectivity = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object residueSite = freezed,
  }) {
    return _then(_SubstanceNucleicAcidLinkage(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      connectivity: connectivity == freezed
          ? _value.connectivity
          : connectivity as String,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      residueSite:
          residueSite == freezed ? _value.residueSite : residueSite as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceNucleicAcidLinkage implements _SubstanceNucleicAcidLinkage {
  const _$_SubstanceNucleicAcidLinkage(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.connectivity,
      this.identifier,
      this.name,
      this.residueSite});

  factory _$_SubstanceNucleicAcidLinkage.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceNucleicAcidLinkageFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String connectivity;
  @override
  final Identifier identifier;
  @override
  final String name;
  @override
  final String residueSite;

  @override
  String toString() {
    return 'SubstanceNucleicAcidLinkage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, connectivity: $connectivity, identifier: $identifier, name: $name, residueSite: $residueSite)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceNucleicAcidLinkage &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.connectivity, connectivity) ||
                const DeepCollectionEquality()
                    .equals(other.connectivity, connectivity)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.residueSite, residueSite) ||
                const DeepCollectionEquality()
                    .equals(other.residueSite, residueSite)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(connectivity) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(residueSite);

  @override
  _$SubstanceNucleicAcidLinkageCopyWith<_SubstanceNucleicAcidLinkage>
      get copyWith => __$SubstanceNucleicAcidLinkageCopyWithImpl<
          _SubstanceNucleicAcidLinkage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceNucleicAcidLinkageToJson(this);
  }
}

abstract class _SubstanceNucleicAcidLinkage
    implements SubstanceNucleicAcidLinkage {
  const factory _SubstanceNucleicAcidLinkage(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String connectivity,
      Identifier identifier,
      String name,
      String residueSite}) = _$_SubstanceNucleicAcidLinkage;

  factory _SubstanceNucleicAcidLinkage.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidLinkage.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get connectivity;
  @override
  Identifier get identifier;
  @override
  String get name;
  @override
  String get residueSite;
  @override
  _$SubstanceNucleicAcidLinkageCopyWith<_SubstanceNucleicAcidLinkage>
      get copyWith;
}

SubstanceNucleicAcidSugar _$SubstanceNucleicAcidSugarFromJson(
    Map<String, dynamic> json) {
  return _SubstanceNucleicAcidSugar.fromJson(json);
}

class _$SubstanceNucleicAcidSugarTearOff {
  const _$SubstanceNucleicAcidSugarTearOff();

  _SubstanceNucleicAcidSugar call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      String residueSite}) {
    return _SubstanceNucleicAcidSugar(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      name: name,
      residueSite: residueSite,
    );
  }
}

// ignore: unused_element
const $SubstanceNucleicAcidSugar = _$SubstanceNucleicAcidSugarTearOff();

mixin _$SubstanceNucleicAcidSugar {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  String get name;
  String get residueSite;

  Map<String, dynamic> toJson();
  $SubstanceNucleicAcidSugarCopyWith<SubstanceNucleicAcidSugar> get copyWith;
}

abstract class $SubstanceNucleicAcidSugarCopyWith<$Res> {
  factory $SubstanceNucleicAcidSugarCopyWith(SubstanceNucleicAcidSugar value,
          $Res Function(SubstanceNucleicAcidSugar) then) =
      _$SubstanceNucleicAcidSugarCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      String residueSite});

  $IdentifierCopyWith<$Res> get identifier;
}

class _$SubstanceNucleicAcidSugarCopyWithImpl<$Res>
    implements $SubstanceNucleicAcidSugarCopyWith<$Res> {
  _$SubstanceNucleicAcidSugarCopyWithImpl(this._value, this._then);

  final SubstanceNucleicAcidSugar _value;
  // ignore: unused_field
  final $Res Function(SubstanceNucleicAcidSugar) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object residueSite = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      residueSite:
          residueSite == freezed ? _value.residueSite : residueSite as String,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }
}

abstract class _$SubstanceNucleicAcidSugarCopyWith<$Res>
    implements $SubstanceNucleicAcidSugarCopyWith<$Res> {
  factory _$SubstanceNucleicAcidSugarCopyWith(_SubstanceNucleicAcidSugar value,
          $Res Function(_SubstanceNucleicAcidSugar) then) =
      __$SubstanceNucleicAcidSugarCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      String residueSite});

  @override
  $IdentifierCopyWith<$Res> get identifier;
}

class __$SubstanceNucleicAcidSugarCopyWithImpl<$Res>
    extends _$SubstanceNucleicAcidSugarCopyWithImpl<$Res>
    implements _$SubstanceNucleicAcidSugarCopyWith<$Res> {
  __$SubstanceNucleicAcidSugarCopyWithImpl(_SubstanceNucleicAcidSugar _value,
      $Res Function(_SubstanceNucleicAcidSugar) _then)
      : super(_value, (v) => _then(v as _SubstanceNucleicAcidSugar));

  @override
  _SubstanceNucleicAcidSugar get _value =>
      super._value as _SubstanceNucleicAcidSugar;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object residueSite = freezed,
  }) {
    return _then(_SubstanceNucleicAcidSugar(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      residueSite:
          residueSite == freezed ? _value.residueSite : residueSite as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceNucleicAcidSugar implements _SubstanceNucleicAcidSugar {
  const _$_SubstanceNucleicAcidSugar(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      this.name,
      this.residueSite});

  factory _$_SubstanceNucleicAcidSugar.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceNucleicAcidSugarFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  final String name;
  @override
  final String residueSite;

  @override
  String toString() {
    return 'SubstanceNucleicAcidSugar(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, residueSite: $residueSite)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceNucleicAcidSugar &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.residueSite, residueSite) ||
                const DeepCollectionEquality()
                    .equals(other.residueSite, residueSite)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(residueSite);

  @override
  _$SubstanceNucleicAcidSugarCopyWith<_SubstanceNucleicAcidSugar>
      get copyWith =>
          __$SubstanceNucleicAcidSugarCopyWithImpl<_SubstanceNucleicAcidSugar>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceNucleicAcidSugarToJson(this);
  }
}

abstract class _SubstanceNucleicAcidSugar implements SubstanceNucleicAcidSugar {
  const factory _SubstanceNucleicAcidSugar(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      String residueSite}) = _$_SubstanceNucleicAcidSugar;

  factory _SubstanceNucleicAcidSugar.fromJson(Map<String, dynamic> json) =
      _$_SubstanceNucleicAcidSugar.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  String get name;
  @override
  String get residueSite;
  @override
  _$SubstanceNucleicAcidSugarCopyWith<_SubstanceNucleicAcidSugar> get copyWith;
}

SubstancePolymer _$SubstancePolymerFromJson(Map<String, dynamic> json) {
  return _SubstancePolymer.fromJson(json);
}

class _$SubstancePolymerTearOff {
  const _$SubstancePolymerTearOff();

  _SubstancePolymer call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstancePolymer')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'class')
          CodeableConcept class_,
      CodeableConcept geometry,
      List<CodeableConcept> copolymerConnectivity,
      List<String> modification,
      List<SubstancePolymerMonomerSet> monomerSet,
      List<SubstancePolymerRepeat> repeat}) {
    return _SubstancePolymer(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      class_: class_,
      geometry: geometry,
      copolymerConnectivity: copolymerConnectivity,
      modification: modification,
      monomerSet: monomerSet,
      repeat: repeat,
    );
  }
}

// ignore: unused_element
const $SubstancePolymer = _$SubstancePolymerTearOff();

mixin _$SubstancePolymer {
  @JsonKey(required: true, defaultValue: 'SubstancePolymer')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(name: 'class')
  CodeableConcept get class_;
  CodeableConcept get geometry;
  List<CodeableConcept> get copolymerConnectivity;
  List<String> get modification;
  List<SubstancePolymerMonomerSet> get monomerSet;
  List<SubstancePolymerRepeat> get repeat;

  Map<String, dynamic> toJson();
  $SubstancePolymerCopyWith<SubstancePolymer> get copyWith;
}

abstract class $SubstancePolymerCopyWith<$Res> {
  factory $SubstancePolymerCopyWith(
          SubstancePolymer value, $Res Function(SubstancePolymer) then) =
      _$SubstancePolymerCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstancePolymer')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'class')
          CodeableConcept class_,
      CodeableConcept geometry,
      List<CodeableConcept> copolymerConnectivity,
      List<String> modification,
      List<SubstancePolymerMonomerSet> monomerSet,
      List<SubstancePolymerRepeat> repeat});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get class_;
  $CodeableConceptCopyWith<$Res> get geometry;
}

class _$SubstancePolymerCopyWithImpl<$Res>
    implements $SubstancePolymerCopyWith<$Res> {
  _$SubstancePolymerCopyWithImpl(this._value, this._then);

  final SubstancePolymer _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymer) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object class_ = freezed,
    Object geometry = freezed,
    Object copolymerConnectivity = freezed,
    Object modification = freezed,
    Object monomerSet = freezed,
    Object repeat = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      class_: class_ == freezed ? _value.class_ : class_ as CodeableConcept,
      geometry:
          geometry == freezed ? _value.geometry : geometry as CodeableConcept,
      copolymerConnectivity: copolymerConnectivity == freezed
          ? _value.copolymerConnectivity
          : copolymerConnectivity as List<CodeableConcept>,
      modification: modification == freezed
          ? _value.modification
          : modification as List<String>,
      monomerSet: monomerSet == freezed
          ? _value.monomerSet
          : monomerSet as List<SubstancePolymerMonomerSet>,
      repeat: repeat == freezed
          ? _value.repeat
          : repeat as List<SubstancePolymerRepeat>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get class_ {
    if (_value.class_ == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.class_, (value) {
      return _then(_value.copyWith(class_: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get geometry {
    if (_value.geometry == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.geometry, (value) {
      return _then(_value.copyWith(geometry: value));
    });
  }
}

abstract class _$SubstancePolymerCopyWith<$Res>
    implements $SubstancePolymerCopyWith<$Res> {
  factory _$SubstancePolymerCopyWith(
          _SubstancePolymer value, $Res Function(_SubstancePolymer) then) =
      __$SubstancePolymerCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstancePolymer')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'class')
          CodeableConcept class_,
      CodeableConcept geometry,
      List<CodeableConcept> copolymerConnectivity,
      List<String> modification,
      List<SubstancePolymerMonomerSet> monomerSet,
      List<SubstancePolymerRepeat> repeat});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get class_;
  @override
  $CodeableConceptCopyWith<$Res> get geometry;
}

class __$SubstancePolymerCopyWithImpl<$Res>
    extends _$SubstancePolymerCopyWithImpl<$Res>
    implements _$SubstancePolymerCopyWith<$Res> {
  __$SubstancePolymerCopyWithImpl(
      _SubstancePolymer _value, $Res Function(_SubstancePolymer) _then)
      : super(_value, (v) => _then(v as _SubstancePolymer));

  @override
  _SubstancePolymer get _value => super._value as _SubstancePolymer;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object class_ = freezed,
    Object geometry = freezed,
    Object copolymerConnectivity = freezed,
    Object modification = freezed,
    Object monomerSet = freezed,
    Object repeat = freezed,
  }) {
    return _then(_SubstancePolymer(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      class_: class_ == freezed ? _value.class_ : class_ as CodeableConcept,
      geometry:
          geometry == freezed ? _value.geometry : geometry as CodeableConcept,
      copolymerConnectivity: copolymerConnectivity == freezed
          ? _value.copolymerConnectivity
          : copolymerConnectivity as List<CodeableConcept>,
      modification: modification == freezed
          ? _value.modification
          : modification as List<String>,
      monomerSet: monomerSet == freezed
          ? _value.monomerSet
          : monomerSet as List<SubstancePolymerMonomerSet>,
      repeat: repeat == freezed
          ? _value.repeat
          : repeat as List<SubstancePolymerRepeat>,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymer implements _SubstancePolymer {
  const _$_SubstancePolymer(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstancePolymer')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      @JsonKey(name: 'class')
          this.class_,
      this.geometry,
      this.copolymerConnectivity,
      this.modification,
      this.monomerSet,
      this.repeat})
      : assert(resourceType != null);

  factory _$_SubstancePolymer.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstancePolymerFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstancePolymer')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(name: 'class')
  final CodeableConcept class_;
  @override
  final CodeableConcept geometry;
  @override
  final List<CodeableConcept> copolymerConnectivity;
  @override
  final List<String> modification;
  @override
  final List<SubstancePolymerMonomerSet> monomerSet;
  @override
  final List<SubstancePolymerRepeat> repeat;

  @override
  String toString() {
    return 'SubstancePolymer(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, class_: $class_, geometry: $geometry, copolymerConnectivity: $copolymerConnectivity, modification: $modification, monomerSet: $monomerSet, repeat: $repeat)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymer &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.class_, class_) ||
                const DeepCollectionEquality().equals(other.class_, class_)) &&
            (identical(other.geometry, geometry) ||
                const DeepCollectionEquality()
                    .equals(other.geometry, geometry)) &&
            (identical(other.copolymerConnectivity, copolymerConnectivity) ||
                const DeepCollectionEquality().equals(
                    other.copolymerConnectivity, copolymerConnectivity)) &&
            (identical(other.modification, modification) ||
                const DeepCollectionEquality()
                    .equals(other.modification, modification)) &&
            (identical(other.monomerSet, monomerSet) ||
                const DeepCollectionEquality()
                    .equals(other.monomerSet, monomerSet)) &&
            (identical(other.repeat, repeat) ||
                const DeepCollectionEquality().equals(other.repeat, repeat)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(class_) ^
      const DeepCollectionEquality().hash(geometry) ^
      const DeepCollectionEquality().hash(copolymerConnectivity) ^
      const DeepCollectionEquality().hash(modification) ^
      const DeepCollectionEquality().hash(monomerSet) ^
      const DeepCollectionEquality().hash(repeat);

  @override
  _$SubstancePolymerCopyWith<_SubstancePolymer> get copyWith =>
      __$SubstancePolymerCopyWithImpl<_SubstancePolymer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerToJson(this);
  }
}

abstract class _SubstancePolymer implements SubstancePolymer {
  const factory _SubstancePolymer(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstancePolymer')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'class')
          CodeableConcept class_,
      CodeableConcept geometry,
      List<CodeableConcept> copolymerConnectivity,
      List<String> modification,
      List<SubstancePolymerMonomerSet> monomerSet,
      List<SubstancePolymerRepeat> repeat}) = _$_SubstancePolymer;

  factory _SubstancePolymer.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymer.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstancePolymer')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(name: 'class')
  CodeableConcept get class_;
  @override
  CodeableConcept get geometry;
  @override
  List<CodeableConcept> get copolymerConnectivity;
  @override
  List<String> get modification;
  @override
  List<SubstancePolymerMonomerSet> get monomerSet;
  @override
  List<SubstancePolymerRepeat> get repeat;
  @override
  _$SubstancePolymerCopyWith<_SubstancePolymer> get copyWith;
}

SubstancePolymerMonomerSet _$SubstancePolymerMonomerSetFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerMonomerSet.fromJson(json);
}

class _$SubstancePolymerMonomerSetTearOff {
  const _$SubstancePolymerMonomerSetTearOff();

  _SubstancePolymerMonomerSet call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept ratioType,
      List<SubstancePolymerStartingMaterial> startingMaterial}) {
    return _SubstancePolymerMonomerSet(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      ratioType: ratioType,
      startingMaterial: startingMaterial,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerMonomerSet = _$SubstancePolymerMonomerSetTearOff();

mixin _$SubstancePolymerMonomerSet {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get ratioType;
  List<SubstancePolymerStartingMaterial> get startingMaterial;

  Map<String, dynamic> toJson();
  $SubstancePolymerMonomerSetCopyWith<SubstancePolymerMonomerSet> get copyWith;
}

abstract class $SubstancePolymerMonomerSetCopyWith<$Res> {
  factory $SubstancePolymerMonomerSetCopyWith(SubstancePolymerMonomerSet value,
          $Res Function(SubstancePolymerMonomerSet) then) =
      _$SubstancePolymerMonomerSetCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept ratioType,
      List<SubstancePolymerStartingMaterial> startingMaterial});

  $CodeableConceptCopyWith<$Res> get ratioType;
}

class _$SubstancePolymerMonomerSetCopyWithImpl<$Res>
    implements $SubstancePolymerMonomerSetCopyWith<$Res> {
  _$SubstancePolymerMonomerSetCopyWithImpl(this._value, this._then);

  final SubstancePolymerMonomerSet _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerMonomerSet) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object ratioType = freezed,
    Object startingMaterial = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      ratioType: ratioType == freezed
          ? _value.ratioType
          : ratioType as CodeableConcept,
      startingMaterial: startingMaterial == freezed
          ? _value.startingMaterial
          : startingMaterial as List<SubstancePolymerStartingMaterial>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get ratioType {
    if (_value.ratioType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.ratioType, (value) {
      return _then(_value.copyWith(ratioType: value));
    });
  }
}

abstract class _$SubstancePolymerMonomerSetCopyWith<$Res>
    implements $SubstancePolymerMonomerSetCopyWith<$Res> {
  factory _$SubstancePolymerMonomerSetCopyWith(
          _SubstancePolymerMonomerSet value,
          $Res Function(_SubstancePolymerMonomerSet) then) =
      __$SubstancePolymerMonomerSetCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept ratioType,
      List<SubstancePolymerStartingMaterial> startingMaterial});

  @override
  $CodeableConceptCopyWith<$Res> get ratioType;
}

class __$SubstancePolymerMonomerSetCopyWithImpl<$Res>
    extends _$SubstancePolymerMonomerSetCopyWithImpl<$Res>
    implements _$SubstancePolymerMonomerSetCopyWith<$Res> {
  __$SubstancePolymerMonomerSetCopyWithImpl(_SubstancePolymerMonomerSet _value,
      $Res Function(_SubstancePolymerMonomerSet) _then)
      : super(_value, (v) => _then(v as _SubstancePolymerMonomerSet));

  @override
  _SubstancePolymerMonomerSet get _value =>
      super._value as _SubstancePolymerMonomerSet;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object ratioType = freezed,
    Object startingMaterial = freezed,
  }) {
    return _then(_SubstancePolymerMonomerSet(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      ratioType: ratioType == freezed
          ? _value.ratioType
          : ratioType as CodeableConcept,
      startingMaterial: startingMaterial == freezed
          ? _value.startingMaterial
          : startingMaterial as List<SubstancePolymerStartingMaterial>,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerMonomerSet implements _SubstancePolymerMonomerSet {
  const _$_SubstancePolymerMonomerSet(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.ratioType,
      this.startingMaterial});

  factory _$_SubstancePolymerMonomerSet.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstancePolymerMonomerSetFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept ratioType;
  @override
  final List<SubstancePolymerStartingMaterial> startingMaterial;

  @override
  String toString() {
    return 'SubstancePolymerMonomerSet(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, ratioType: $ratioType, startingMaterial: $startingMaterial)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerMonomerSet &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.ratioType, ratioType) ||
                const DeepCollectionEquality()
                    .equals(other.ratioType, ratioType)) &&
            (identical(other.startingMaterial, startingMaterial) ||
                const DeepCollectionEquality()
                    .equals(other.startingMaterial, startingMaterial)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(ratioType) ^
      const DeepCollectionEquality().hash(startingMaterial);

  @override
  _$SubstancePolymerMonomerSetCopyWith<_SubstancePolymerMonomerSet>
      get copyWith => __$SubstancePolymerMonomerSetCopyWithImpl<
          _SubstancePolymerMonomerSet>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerMonomerSetToJson(this);
  }
}

abstract class _SubstancePolymerMonomerSet
    implements SubstancePolymerMonomerSet {
  const factory _SubstancePolymerMonomerSet(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept ratioType,
          List<SubstancePolymerStartingMaterial> startingMaterial}) =
      _$_SubstancePolymerMonomerSet;

  factory _SubstancePolymerMonomerSet.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerMonomerSet.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get ratioType;
  @override
  List<SubstancePolymerStartingMaterial> get startingMaterial;
  @override
  _$SubstancePolymerMonomerSetCopyWith<_SubstancePolymerMonomerSet>
      get copyWith;
}

SubstancePolymerStartingMaterial _$SubstancePolymerStartingMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerStartingMaterial.fromJson(json);
}

class _$SubstancePolymerStartingMaterialTearOff {
  const _$SubstancePolymerStartingMaterialTearOff();

  _SubstancePolymerStartingMaterial call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      Boolean isDefining,
      SubstanceAmount amount}) {
    return _SubstancePolymerStartingMaterial(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      material: material,
      type: type,
      isDefining: isDefining,
      amount: amount,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerStartingMaterial =
    _$SubstancePolymerStartingMaterialTearOff();

mixin _$SubstancePolymerStartingMaterial {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get material;
  CodeableConcept get type;
  Boolean get isDefining;
  SubstanceAmount get amount;

  Map<String, dynamic> toJson();
  $SubstancePolymerStartingMaterialCopyWith<SubstancePolymerStartingMaterial>
      get copyWith;
}

abstract class $SubstancePolymerStartingMaterialCopyWith<$Res> {
  factory $SubstancePolymerStartingMaterialCopyWith(
          SubstancePolymerStartingMaterial value,
          $Res Function(SubstancePolymerStartingMaterial) then) =
      _$SubstancePolymerStartingMaterialCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      Boolean isDefining,
      SubstanceAmount amount});

  $CodeableConceptCopyWith<$Res> get material;
  $CodeableConceptCopyWith<$Res> get type;
  $SubstanceAmountCopyWith<$Res> get amount;
}

class _$SubstancePolymerStartingMaterialCopyWithImpl<$Res>
    implements $SubstancePolymerStartingMaterialCopyWith<$Res> {
  _$SubstancePolymerStartingMaterialCopyWithImpl(this._value, this._then);

  final SubstancePolymerStartingMaterial _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerStartingMaterial) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object material = freezed,
    Object type = freezed,
    Object isDefining = freezed,
    Object amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      material:
          material == freezed ? _value.material : material as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      isDefining:
          isDefining == freezed ? _value.isDefining : isDefining as Boolean,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get material {
    if (_value.material == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.material, (value) {
      return _then(_value.copyWith(material: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $SubstanceAmountCopyWith<$Res> get amount {
    if (_value.amount == null) {
      return null;
    }
    return $SubstanceAmountCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value));
    });
  }
}

abstract class _$SubstancePolymerStartingMaterialCopyWith<$Res>
    implements $SubstancePolymerStartingMaterialCopyWith<$Res> {
  factory _$SubstancePolymerStartingMaterialCopyWith(
          _SubstancePolymerStartingMaterial value,
          $Res Function(_SubstancePolymerStartingMaterial) then) =
      __$SubstancePolymerStartingMaterialCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      Boolean isDefining,
      SubstanceAmount amount});

  @override
  $CodeableConceptCopyWith<$Res> get material;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $SubstanceAmountCopyWith<$Res> get amount;
}

class __$SubstancePolymerStartingMaterialCopyWithImpl<$Res>
    extends _$SubstancePolymerStartingMaterialCopyWithImpl<$Res>
    implements _$SubstancePolymerStartingMaterialCopyWith<$Res> {
  __$SubstancePolymerStartingMaterialCopyWithImpl(
      _SubstancePolymerStartingMaterial _value,
      $Res Function(_SubstancePolymerStartingMaterial) _then)
      : super(_value, (v) => _then(v as _SubstancePolymerStartingMaterial));

  @override
  _SubstancePolymerStartingMaterial get _value =>
      super._value as _SubstancePolymerStartingMaterial;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object material = freezed,
    Object type = freezed,
    Object isDefining = freezed,
    Object amount = freezed,
  }) {
    return _then(_SubstancePolymerStartingMaterial(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      material:
          material == freezed ? _value.material : material as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      isDefining:
          isDefining == freezed ? _value.isDefining : isDefining as Boolean,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerStartingMaterial
    implements _SubstancePolymerStartingMaterial {
  const _$_SubstancePolymerStartingMaterial(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.material,
      this.type,
      this.isDefining,
      this.amount});

  factory _$_SubstancePolymerStartingMaterial.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstancePolymerStartingMaterialFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept material;
  @override
  final CodeableConcept type;
  @override
  final Boolean isDefining;
  @override
  final SubstanceAmount amount;

  @override
  String toString() {
    return 'SubstancePolymerStartingMaterial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, material: $material, type: $type, isDefining: $isDefining, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerStartingMaterial &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.material, material) ||
                const DeepCollectionEquality()
                    .equals(other.material, material)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isDefining, isDefining) ||
                const DeepCollectionEquality()
                    .equals(other.isDefining, isDefining)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(material) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isDefining) ^
      const DeepCollectionEquality().hash(amount);

  @override
  _$SubstancePolymerStartingMaterialCopyWith<_SubstancePolymerStartingMaterial>
      get copyWith => __$SubstancePolymerStartingMaterialCopyWithImpl<
          _SubstancePolymerStartingMaterial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerStartingMaterialToJson(this);
  }
}

abstract class _SubstancePolymerStartingMaterial
    implements SubstancePolymerStartingMaterial {
  const factory _SubstancePolymerStartingMaterial(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept material,
      CodeableConcept type,
      Boolean isDefining,
      SubstanceAmount amount}) = _$_SubstancePolymerStartingMaterial;

  factory _SubstancePolymerStartingMaterial.fromJson(
      Map<String, dynamic> json) = _$_SubstancePolymerStartingMaterial.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get material;
  @override
  CodeableConcept get type;
  @override
  Boolean get isDefining;
  @override
  SubstanceAmount get amount;
  @override
  _$SubstancePolymerStartingMaterialCopyWith<_SubstancePolymerStartingMaterial>
      get copyWith;
}

SubstancePolymerRepeat _$SubstancePolymerRepeatFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerRepeat.fromJson(json);
}

class _$SubstancePolymerRepeatTearOff {
  const _$SubstancePolymerRepeatTearOff();

  _SubstancePolymerRepeat call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer numberOfUnits,
      String averageMolecularFormula,
      CodeableConcept repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit> repeatUnit}) {
    return _SubstancePolymerRepeat(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      numberOfUnits: numberOfUnits,
      averageMolecularFormula: averageMolecularFormula,
      repeatUnitAmountType: repeatUnitAmountType,
      repeatUnit: repeatUnit,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerRepeat = _$SubstancePolymerRepeatTearOff();

mixin _$SubstancePolymerRepeat {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get numberOfUnits;
  String get averageMolecularFormula;
  CodeableConcept get repeatUnitAmountType;
  List<SubstancePolymerRepeatUnit> get repeatUnit;

  Map<String, dynamic> toJson();
  $SubstancePolymerRepeatCopyWith<SubstancePolymerRepeat> get copyWith;
}

abstract class $SubstancePolymerRepeatCopyWith<$Res> {
  factory $SubstancePolymerRepeatCopyWith(SubstancePolymerRepeat value,
          $Res Function(SubstancePolymerRepeat) then) =
      _$SubstancePolymerRepeatCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer numberOfUnits,
      String averageMolecularFormula,
      CodeableConcept repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit> repeatUnit});

  $CodeableConceptCopyWith<$Res> get repeatUnitAmountType;
}

class _$SubstancePolymerRepeatCopyWithImpl<$Res>
    implements $SubstancePolymerRepeatCopyWith<$Res> {
  _$SubstancePolymerRepeatCopyWithImpl(this._value, this._then);

  final SubstancePolymerRepeat _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerRepeat) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object numberOfUnits = freezed,
    Object averageMolecularFormula = freezed,
    Object repeatUnitAmountType = freezed,
    Object repeatUnit = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      numberOfUnits: numberOfUnits == freezed
          ? _value.numberOfUnits
          : numberOfUnits as Integer,
      averageMolecularFormula: averageMolecularFormula == freezed
          ? _value.averageMolecularFormula
          : averageMolecularFormula as String,
      repeatUnitAmountType: repeatUnitAmountType == freezed
          ? _value.repeatUnitAmountType
          : repeatUnitAmountType as CodeableConcept,
      repeatUnit: repeatUnit == freezed
          ? _value.repeatUnit
          : repeatUnit as List<SubstancePolymerRepeatUnit>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get repeatUnitAmountType {
    if (_value.repeatUnitAmountType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.repeatUnitAmountType, (value) {
      return _then(_value.copyWith(repeatUnitAmountType: value));
    });
  }
}

abstract class _$SubstancePolymerRepeatCopyWith<$Res>
    implements $SubstancePolymerRepeatCopyWith<$Res> {
  factory _$SubstancePolymerRepeatCopyWith(_SubstancePolymerRepeat value,
          $Res Function(_SubstancePolymerRepeat) then) =
      __$SubstancePolymerRepeatCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer numberOfUnits,
      String averageMolecularFormula,
      CodeableConcept repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit> repeatUnit});

  @override
  $CodeableConceptCopyWith<$Res> get repeatUnitAmountType;
}

class __$SubstancePolymerRepeatCopyWithImpl<$Res>
    extends _$SubstancePolymerRepeatCopyWithImpl<$Res>
    implements _$SubstancePolymerRepeatCopyWith<$Res> {
  __$SubstancePolymerRepeatCopyWithImpl(_SubstancePolymerRepeat _value,
      $Res Function(_SubstancePolymerRepeat) _then)
      : super(_value, (v) => _then(v as _SubstancePolymerRepeat));

  @override
  _SubstancePolymerRepeat get _value => super._value as _SubstancePolymerRepeat;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object numberOfUnits = freezed,
    Object averageMolecularFormula = freezed,
    Object repeatUnitAmountType = freezed,
    Object repeatUnit = freezed,
  }) {
    return _then(_SubstancePolymerRepeat(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      numberOfUnits: numberOfUnits == freezed
          ? _value.numberOfUnits
          : numberOfUnits as Integer,
      averageMolecularFormula: averageMolecularFormula == freezed
          ? _value.averageMolecularFormula
          : averageMolecularFormula as String,
      repeatUnitAmountType: repeatUnitAmountType == freezed
          ? _value.repeatUnitAmountType
          : repeatUnitAmountType as CodeableConcept,
      repeatUnit: repeatUnit == freezed
          ? _value.repeatUnit
          : repeatUnit as List<SubstancePolymerRepeatUnit>,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerRepeat implements _SubstancePolymerRepeat {
  const _$_SubstancePolymerRepeat(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.numberOfUnits,
      this.averageMolecularFormula,
      this.repeatUnitAmountType,
      this.repeatUnit});

  factory _$_SubstancePolymerRepeat.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstancePolymerRepeatFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer numberOfUnits;
  @override
  final String averageMolecularFormula;
  @override
  final CodeableConcept repeatUnitAmountType;
  @override
  final List<SubstancePolymerRepeatUnit> repeatUnit;

  @override
  String toString() {
    return 'SubstancePolymerRepeat(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, numberOfUnits: $numberOfUnits, averageMolecularFormula: $averageMolecularFormula, repeatUnitAmountType: $repeatUnitAmountType, repeatUnit: $repeatUnit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerRepeat &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.numberOfUnits, numberOfUnits) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfUnits, numberOfUnits)) &&
            (identical(
                    other.averageMolecularFormula, averageMolecularFormula) ||
                const DeepCollectionEquality().equals(
                    other.averageMolecularFormula, averageMolecularFormula)) &&
            (identical(other.repeatUnitAmountType, repeatUnitAmountType) ||
                const DeepCollectionEquality().equals(
                    other.repeatUnitAmountType, repeatUnitAmountType)) &&
            (identical(other.repeatUnit, repeatUnit) ||
                const DeepCollectionEquality()
                    .equals(other.repeatUnit, repeatUnit)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(numberOfUnits) ^
      const DeepCollectionEquality().hash(averageMolecularFormula) ^
      const DeepCollectionEquality().hash(repeatUnitAmountType) ^
      const DeepCollectionEquality().hash(repeatUnit);

  @override
  _$SubstancePolymerRepeatCopyWith<_SubstancePolymerRepeat> get copyWith =>
      __$SubstancePolymerRepeatCopyWithImpl<_SubstancePolymerRepeat>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerRepeatToJson(this);
  }
}

abstract class _SubstancePolymerRepeat implements SubstancePolymerRepeat {
  const factory _SubstancePolymerRepeat(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer numberOfUnits,
      String averageMolecularFormula,
      CodeableConcept repeatUnitAmountType,
      List<SubstancePolymerRepeatUnit> repeatUnit}) = _$_SubstancePolymerRepeat;

  factory _SubstancePolymerRepeat.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerRepeat.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get numberOfUnits;
  @override
  String get averageMolecularFormula;
  @override
  CodeableConcept get repeatUnitAmountType;
  @override
  List<SubstancePolymerRepeatUnit> get repeatUnit;
  @override
  _$SubstancePolymerRepeatCopyWith<_SubstancePolymerRepeat> get copyWith;
}

SubstancePolymerRepeatUnit _$SubstancePolymerRepeatUnitFromJson(
    Map<String, dynamic> json) {
  return _SubstancePolymerRepeatUnit.fromJson(json);
}

class _$SubstancePolymerRepeatUnitTearOff {
  const _$SubstancePolymerRepeatUnitTearOff();

  _SubstancePolymerRepeatUnit call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept orientationOfPolymerisation,
      String repeatUnit,
      SubstanceAmount amount,
      List<SubstancePolymerDegreeOfPolymerisation> degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation>
          structuralRepresentation}) {
    return _SubstancePolymerRepeatUnit(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      orientationOfPolymerisation: orientationOfPolymerisation,
      repeatUnit: repeatUnit,
      amount: amount,
      degreeOfPolymerisation: degreeOfPolymerisation,
      structuralRepresentation: structuralRepresentation,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerRepeatUnit = _$SubstancePolymerRepeatUnitTearOff();

mixin _$SubstancePolymerRepeatUnit {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get orientationOfPolymerisation;
  String get repeatUnit;
  SubstanceAmount get amount;
  List<SubstancePolymerDegreeOfPolymerisation> get degreeOfPolymerisation;
  List<SubstancePolymerStructuralRepresentation> get structuralRepresentation;

  Map<String, dynamic> toJson();
  $SubstancePolymerRepeatUnitCopyWith<SubstancePolymerRepeatUnit> get copyWith;
}

abstract class $SubstancePolymerRepeatUnitCopyWith<$Res> {
  factory $SubstancePolymerRepeatUnitCopyWith(SubstancePolymerRepeatUnit value,
          $Res Function(SubstancePolymerRepeatUnit) then) =
      _$SubstancePolymerRepeatUnitCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept orientationOfPolymerisation,
      String repeatUnit,
      SubstanceAmount amount,
      List<SubstancePolymerDegreeOfPolymerisation> degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation> structuralRepresentation});

  $CodeableConceptCopyWith<$Res> get orientationOfPolymerisation;
  $SubstanceAmountCopyWith<$Res> get amount;
}

class _$SubstancePolymerRepeatUnitCopyWithImpl<$Res>
    implements $SubstancePolymerRepeatUnitCopyWith<$Res> {
  _$SubstancePolymerRepeatUnitCopyWithImpl(this._value, this._then);

  final SubstancePolymerRepeatUnit _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerRepeatUnit) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object orientationOfPolymerisation = freezed,
    Object repeatUnit = freezed,
    Object amount = freezed,
    Object degreeOfPolymerisation = freezed,
    Object structuralRepresentation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      orientationOfPolymerisation: orientationOfPolymerisation == freezed
          ? _value.orientationOfPolymerisation
          : orientationOfPolymerisation as CodeableConcept,
      repeatUnit:
          repeatUnit == freezed ? _value.repeatUnit : repeatUnit as String,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
      degreeOfPolymerisation: degreeOfPolymerisation == freezed
          ? _value.degreeOfPolymerisation
          : degreeOfPolymerisation
              as List<SubstancePolymerDegreeOfPolymerisation>,
      structuralRepresentation: structuralRepresentation == freezed
          ? _value.structuralRepresentation
          : structuralRepresentation
              as List<SubstancePolymerStructuralRepresentation>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get orientationOfPolymerisation {
    if (_value.orientationOfPolymerisation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.orientationOfPolymerisation,
        (value) {
      return _then(_value.copyWith(orientationOfPolymerisation: value));
    });
  }

  @override
  $SubstanceAmountCopyWith<$Res> get amount {
    if (_value.amount == null) {
      return null;
    }
    return $SubstanceAmountCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value));
    });
  }
}

abstract class _$SubstancePolymerRepeatUnitCopyWith<$Res>
    implements $SubstancePolymerRepeatUnitCopyWith<$Res> {
  factory _$SubstancePolymerRepeatUnitCopyWith(
          _SubstancePolymerRepeatUnit value,
          $Res Function(_SubstancePolymerRepeatUnit) then) =
      __$SubstancePolymerRepeatUnitCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept orientationOfPolymerisation,
      String repeatUnit,
      SubstanceAmount amount,
      List<SubstancePolymerDegreeOfPolymerisation> degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation> structuralRepresentation});

  @override
  $CodeableConceptCopyWith<$Res> get orientationOfPolymerisation;
  @override
  $SubstanceAmountCopyWith<$Res> get amount;
}

class __$SubstancePolymerRepeatUnitCopyWithImpl<$Res>
    extends _$SubstancePolymerRepeatUnitCopyWithImpl<$Res>
    implements _$SubstancePolymerRepeatUnitCopyWith<$Res> {
  __$SubstancePolymerRepeatUnitCopyWithImpl(_SubstancePolymerRepeatUnit _value,
      $Res Function(_SubstancePolymerRepeatUnit) _then)
      : super(_value, (v) => _then(v as _SubstancePolymerRepeatUnit));

  @override
  _SubstancePolymerRepeatUnit get _value =>
      super._value as _SubstancePolymerRepeatUnit;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object orientationOfPolymerisation = freezed,
    Object repeatUnit = freezed,
    Object amount = freezed,
    Object degreeOfPolymerisation = freezed,
    Object structuralRepresentation = freezed,
  }) {
    return _then(_SubstancePolymerRepeatUnit(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      orientationOfPolymerisation: orientationOfPolymerisation == freezed
          ? _value.orientationOfPolymerisation
          : orientationOfPolymerisation as CodeableConcept,
      repeatUnit:
          repeatUnit == freezed ? _value.repeatUnit : repeatUnit as String,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
      degreeOfPolymerisation: degreeOfPolymerisation == freezed
          ? _value.degreeOfPolymerisation
          : degreeOfPolymerisation
              as List<SubstancePolymerDegreeOfPolymerisation>,
      structuralRepresentation: structuralRepresentation == freezed
          ? _value.structuralRepresentation
          : structuralRepresentation
              as List<SubstancePolymerStructuralRepresentation>,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerRepeatUnit implements _SubstancePolymerRepeatUnit {
  const _$_SubstancePolymerRepeatUnit(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.orientationOfPolymerisation,
      this.repeatUnit,
      this.amount,
      this.degreeOfPolymerisation,
      this.structuralRepresentation});

  factory _$_SubstancePolymerRepeatUnit.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstancePolymerRepeatUnitFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept orientationOfPolymerisation;
  @override
  final String repeatUnit;
  @override
  final SubstanceAmount amount;
  @override
  final List<SubstancePolymerDegreeOfPolymerisation> degreeOfPolymerisation;
  @override
  final List<SubstancePolymerStructuralRepresentation> structuralRepresentation;

  @override
  String toString() {
    return 'SubstancePolymerRepeatUnit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, orientationOfPolymerisation: $orientationOfPolymerisation, repeatUnit: $repeatUnit, amount: $amount, degreeOfPolymerisation: $degreeOfPolymerisation, structuralRepresentation: $structuralRepresentation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerRepeatUnit &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.orientationOfPolymerisation,
                    orientationOfPolymerisation) ||
                const DeepCollectionEquality().equals(
                    other.orientationOfPolymerisation,
                    orientationOfPolymerisation)) &&
            (identical(other.repeatUnit, repeatUnit) ||
                const DeepCollectionEquality()
                    .equals(other.repeatUnit, repeatUnit)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.degreeOfPolymerisation, degreeOfPolymerisation) ||
                const DeepCollectionEquality().equals(
                    other.degreeOfPolymerisation, degreeOfPolymerisation)) &&
            (identical(
                    other.structuralRepresentation, structuralRepresentation) ||
                const DeepCollectionEquality().equals(
                    other.structuralRepresentation, structuralRepresentation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(orientationOfPolymerisation) ^
      const DeepCollectionEquality().hash(repeatUnit) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(degreeOfPolymerisation) ^
      const DeepCollectionEquality().hash(structuralRepresentation);

  @override
  _$SubstancePolymerRepeatUnitCopyWith<_SubstancePolymerRepeatUnit>
      get copyWith => __$SubstancePolymerRepeatUnitCopyWithImpl<
          _SubstancePolymerRepeatUnit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerRepeatUnitToJson(this);
  }
}

abstract class _SubstancePolymerRepeatUnit
    implements SubstancePolymerRepeatUnit {
  const factory _SubstancePolymerRepeatUnit(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept orientationOfPolymerisation,
      String repeatUnit,
      SubstanceAmount amount,
      List<SubstancePolymerDegreeOfPolymerisation> degreeOfPolymerisation,
      List<SubstancePolymerStructuralRepresentation>
          structuralRepresentation}) = _$_SubstancePolymerRepeatUnit;

  factory _SubstancePolymerRepeatUnit.fromJson(Map<String, dynamic> json) =
      _$_SubstancePolymerRepeatUnit.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get orientationOfPolymerisation;
  @override
  String get repeatUnit;
  @override
  SubstanceAmount get amount;
  @override
  List<SubstancePolymerDegreeOfPolymerisation> get degreeOfPolymerisation;
  @override
  List<SubstancePolymerStructuralRepresentation> get structuralRepresentation;
  @override
  _$SubstancePolymerRepeatUnitCopyWith<_SubstancePolymerRepeatUnit>
      get copyWith;
}

SubstancePolymerDegreeOfPolymerisation
    _$SubstancePolymerDegreeOfPolymerisationFromJson(
        Map<String, dynamic> json) {
  return _SubstancePolymerDegreeOfPolymerisation.fromJson(json);
}

class _$SubstancePolymerDegreeOfPolymerisationTearOff {
  const _$SubstancePolymerDegreeOfPolymerisationTearOff();

  _SubstancePolymerDegreeOfPolymerisation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept degree,
      SubstanceAmount amount}) {
    return _SubstancePolymerDegreeOfPolymerisation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      degree: degree,
      amount: amount,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerDegreeOfPolymerisation =
    _$SubstancePolymerDegreeOfPolymerisationTearOff();

mixin _$SubstancePolymerDegreeOfPolymerisation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get degree;
  SubstanceAmount get amount;

  Map<String, dynamic> toJson();
  $SubstancePolymerDegreeOfPolymerisationCopyWith<
      SubstancePolymerDegreeOfPolymerisation> get copyWith;
}

abstract class $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  factory $SubstancePolymerDegreeOfPolymerisationCopyWith(
          SubstancePolymerDegreeOfPolymerisation value,
          $Res Function(SubstancePolymerDegreeOfPolymerisation) then) =
      _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept degree,
      SubstanceAmount amount});

  $CodeableConceptCopyWith<$Res> get degree;
  $SubstanceAmountCopyWith<$Res> get amount;
}

class _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>
    implements $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl(this._value, this._then);

  final SubstancePolymerDegreeOfPolymerisation _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerDegreeOfPolymerisation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object degree = freezed,
    Object amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      degree: degree == freezed ? _value.degree : degree as CodeableConcept,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get degree {
    if (_value.degree == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.degree, (value) {
      return _then(_value.copyWith(degree: value));
    });
  }

  @override
  $SubstanceAmountCopyWith<$Res> get amount {
    if (_value.amount == null) {
      return null;
    }
    return $SubstanceAmountCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value));
    });
  }
}

abstract class _$SubstancePolymerDegreeOfPolymerisationCopyWith<$Res>
    implements $SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  factory _$SubstancePolymerDegreeOfPolymerisationCopyWith(
          _SubstancePolymerDegreeOfPolymerisation value,
          $Res Function(_SubstancePolymerDegreeOfPolymerisation) then) =
      __$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept degree,
      SubstanceAmount amount});

  @override
  $CodeableConceptCopyWith<$Res> get degree;
  @override
  $SubstanceAmountCopyWith<$Res> get amount;
}

class __$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>
    extends _$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<$Res>
    implements _$SubstancePolymerDegreeOfPolymerisationCopyWith<$Res> {
  __$SubstancePolymerDegreeOfPolymerisationCopyWithImpl(
      _SubstancePolymerDegreeOfPolymerisation _value,
      $Res Function(_SubstancePolymerDegreeOfPolymerisation) _then)
      : super(
            _value, (v) => _then(v as _SubstancePolymerDegreeOfPolymerisation));

  @override
  _SubstancePolymerDegreeOfPolymerisation get _value =>
      super._value as _SubstancePolymerDegreeOfPolymerisation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object degree = freezed,
    Object amount = freezed,
  }) {
    return _then(_SubstancePolymerDegreeOfPolymerisation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      degree: degree == freezed ? _value.degree : degree as CodeableConcept,
      amount: amount == freezed ? _value.amount : amount as SubstanceAmount,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerDegreeOfPolymerisation
    implements _SubstancePolymerDegreeOfPolymerisation {
  const _$_SubstancePolymerDegreeOfPolymerisation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.degree,
      this.amount});

  factory _$_SubstancePolymerDegreeOfPolymerisation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstancePolymerDegreeOfPolymerisationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept degree;
  @override
  final SubstanceAmount amount;

  @override
  String toString() {
    return 'SubstancePolymerDegreeOfPolymerisation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, degree: $degree, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerDegreeOfPolymerisation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.degree, degree) ||
                const DeepCollectionEquality().equals(other.degree, degree)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(degree) ^
      const DeepCollectionEquality().hash(amount);

  @override
  _$SubstancePolymerDegreeOfPolymerisationCopyWith<
          _SubstancePolymerDegreeOfPolymerisation>
      get copyWith => __$SubstancePolymerDegreeOfPolymerisationCopyWithImpl<
          _SubstancePolymerDegreeOfPolymerisation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerDegreeOfPolymerisationToJson(this);
  }
}

abstract class _SubstancePolymerDegreeOfPolymerisation
    implements SubstancePolymerDegreeOfPolymerisation {
  const factory _SubstancePolymerDegreeOfPolymerisation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept degree,
      SubstanceAmount amount}) = _$_SubstancePolymerDegreeOfPolymerisation;

  factory _SubstancePolymerDegreeOfPolymerisation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstancePolymerDegreeOfPolymerisation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get degree;
  @override
  SubstanceAmount get amount;
  @override
  _$SubstancePolymerDegreeOfPolymerisationCopyWith<
      _SubstancePolymerDegreeOfPolymerisation> get copyWith;
}

SubstancePolymerStructuralRepresentation
    _$SubstancePolymerStructuralRepresentationFromJson(
        Map<String, dynamic> json) {
  return _SubstancePolymerStructuralRepresentation.fromJson(json);
}

class _$SubstancePolymerStructuralRepresentationTearOff {
  const _$SubstancePolymerStructuralRepresentationTearOff();

  _SubstancePolymerStructuralRepresentation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment}) {
    return _SubstancePolymerStructuralRepresentation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      representation: representation,
      attachment: attachment,
    );
  }
}

// ignore: unused_element
const $SubstancePolymerStructuralRepresentation =
    _$SubstancePolymerStructuralRepresentationTearOff();

mixin _$SubstancePolymerStructuralRepresentation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  String get representation;
  Attachment get attachment;

  Map<String, dynamic> toJson();
  $SubstancePolymerStructuralRepresentationCopyWith<
      SubstancePolymerStructuralRepresentation> get copyWith;
}

abstract class $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  factory $SubstancePolymerStructuralRepresentationCopyWith(
          SubstancePolymerStructuralRepresentation value,
          $Res Function(SubstancePolymerStructuralRepresentation) then) =
      _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment});

  $CodeableConceptCopyWith<$Res> get type;
  $AttachmentCopyWith<$Res> get attachment;
}

class _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>
    implements $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  _$SubstancePolymerStructuralRepresentationCopyWithImpl(
      this._value, this._then);

  final SubstancePolymerStructuralRepresentation _value;
  // ignore: unused_field
  final $Res Function(SubstancePolymerStructuralRepresentation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object representation = freezed,
    Object attachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      representation: representation == freezed
          ? _value.representation
          : representation as String,
      attachment:
          attachment == freezed ? _value.attachment : attachment as Attachment,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $AttachmentCopyWith<$Res> get attachment {
    if (_value.attachment == null) {
      return null;
    }
    return $AttachmentCopyWith<$Res>(_value.attachment, (value) {
      return _then(_value.copyWith(attachment: value));
    });
  }
}

abstract class _$SubstancePolymerStructuralRepresentationCopyWith<$Res>
    implements $SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  factory _$SubstancePolymerStructuralRepresentationCopyWith(
          _SubstancePolymerStructuralRepresentation value,
          $Res Function(_SubstancePolymerStructuralRepresentation) then) =
      __$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $AttachmentCopyWith<$Res> get attachment;
}

class __$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>
    extends _$SubstancePolymerStructuralRepresentationCopyWithImpl<$Res>
    implements _$SubstancePolymerStructuralRepresentationCopyWith<$Res> {
  __$SubstancePolymerStructuralRepresentationCopyWithImpl(
      _SubstancePolymerStructuralRepresentation _value,
      $Res Function(_SubstancePolymerStructuralRepresentation) _then)
      : super(_value,
            (v) => _then(v as _SubstancePolymerStructuralRepresentation));

  @override
  _SubstancePolymerStructuralRepresentation get _value =>
      super._value as _SubstancePolymerStructuralRepresentation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object representation = freezed,
    Object attachment = freezed,
  }) {
    return _then(_SubstancePolymerStructuralRepresentation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      representation: representation == freezed
          ? _value.representation
          : representation as String,
      attachment:
          attachment == freezed ? _value.attachment : attachment as Attachment,
    ));
  }
}

@JsonSerializable()
class _$_SubstancePolymerStructuralRepresentation
    implements _SubstancePolymerStructuralRepresentation {
  const _$_SubstancePolymerStructuralRepresentation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.representation,
      this.attachment});

  factory _$_SubstancePolymerStructuralRepresentation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstancePolymerStructuralRepresentationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final String representation;
  @override
  final Attachment attachment;

  @override
  String toString() {
    return 'SubstancePolymerStructuralRepresentation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, representation: $representation, attachment: $attachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstancePolymerStructuralRepresentation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.representation, representation) ||
                const DeepCollectionEquality()
                    .equals(other.representation, representation)) &&
            (identical(other.attachment, attachment) ||
                const DeepCollectionEquality()
                    .equals(other.attachment, attachment)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(representation) ^
      const DeepCollectionEquality().hash(attachment);

  @override
  _$SubstancePolymerStructuralRepresentationCopyWith<
          _SubstancePolymerStructuralRepresentation>
      get copyWith => __$SubstancePolymerStructuralRepresentationCopyWithImpl<
          _SubstancePolymerStructuralRepresentation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstancePolymerStructuralRepresentationToJson(this);
  }
}

abstract class _SubstancePolymerStructuralRepresentation
    implements SubstancePolymerStructuralRepresentation {
  const factory _SubstancePolymerStructuralRepresentation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment}) = _$_SubstancePolymerStructuralRepresentation;

  factory _SubstancePolymerStructuralRepresentation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstancePolymerStructuralRepresentation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  String get representation;
  @override
  Attachment get attachment;
  @override
  _$SubstancePolymerStructuralRepresentationCopyWith<
      _SubstancePolymerStructuralRepresentation> get copyWith;
}

SubstanceProtein _$SubstanceProteinFromJson(Map<String, dynamic> json) {
  return _SubstanceProtein.fromJson(json);
}

class _$SubstanceProteinTearOff {
  const _$SubstanceProteinTearOff();

  _SubstanceProtein call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceProtein')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      List<String> disulfideLinkage,
      List<SubstanceProteinSubunit> subunit}) {
    return _SubstanceProtein(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      sequenceType: sequenceType,
      numberOfSubunits: numberOfSubunits,
      disulfideLinkage: disulfideLinkage,
      subunit: subunit,
    );
  }
}

// ignore: unused_element
const $SubstanceProtein = _$SubstanceProteinTearOff();

mixin _$SubstanceProtein {
  @JsonKey(required: true, defaultValue: 'SubstanceProtein')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get sequenceType;
  Integer get numberOfSubunits;
  List<String> get disulfideLinkage;
  List<SubstanceProteinSubunit> get subunit;

  Map<String, dynamic> toJson();
  $SubstanceProteinCopyWith<SubstanceProtein> get copyWith;
}

abstract class $SubstanceProteinCopyWith<$Res> {
  factory $SubstanceProteinCopyWith(
          SubstanceProtein value, $Res Function(SubstanceProtein) then) =
      _$SubstanceProteinCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceProtein')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      List<String> disulfideLinkage,
      List<SubstanceProteinSubunit> subunit});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get sequenceType;
}

class _$SubstanceProteinCopyWithImpl<$Res>
    implements $SubstanceProteinCopyWith<$Res> {
  _$SubstanceProteinCopyWithImpl(this._value, this._then);

  final SubstanceProtein _value;
  // ignore: unused_field
  final $Res Function(SubstanceProtein) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sequenceType = freezed,
    Object numberOfSubunits = freezed,
    Object disulfideLinkage = freezed,
    Object subunit = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sequenceType: sequenceType == freezed
          ? _value.sequenceType
          : sequenceType as CodeableConcept,
      numberOfSubunits: numberOfSubunits == freezed
          ? _value.numberOfSubunits
          : numberOfSubunits as Integer,
      disulfideLinkage: disulfideLinkage == freezed
          ? _value.disulfideLinkage
          : disulfideLinkage as List<String>,
      subunit: subunit == freezed
          ? _value.subunit
          : subunit as List<SubstanceProteinSubunit>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get sequenceType {
    if (_value.sequenceType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.sequenceType, (value) {
      return _then(_value.copyWith(sequenceType: value));
    });
  }
}

abstract class _$SubstanceProteinCopyWith<$Res>
    implements $SubstanceProteinCopyWith<$Res> {
  factory _$SubstanceProteinCopyWith(
          _SubstanceProtein value, $Res Function(_SubstanceProtein) then) =
      __$SubstanceProteinCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceProtein')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      List<String> disulfideLinkage,
      List<SubstanceProteinSubunit> subunit});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get sequenceType;
}

class __$SubstanceProteinCopyWithImpl<$Res>
    extends _$SubstanceProteinCopyWithImpl<$Res>
    implements _$SubstanceProteinCopyWith<$Res> {
  __$SubstanceProteinCopyWithImpl(
      _SubstanceProtein _value, $Res Function(_SubstanceProtein) _then)
      : super(_value, (v) => _then(v as _SubstanceProtein));

  @override
  _SubstanceProtein get _value => super._value as _SubstanceProtein;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sequenceType = freezed,
    Object numberOfSubunits = freezed,
    Object disulfideLinkage = freezed,
    Object subunit = freezed,
  }) {
    return _then(_SubstanceProtein(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sequenceType: sequenceType == freezed
          ? _value.sequenceType
          : sequenceType as CodeableConcept,
      numberOfSubunits: numberOfSubunits == freezed
          ? _value.numberOfSubunits
          : numberOfSubunits as Integer,
      disulfideLinkage: disulfideLinkage == freezed
          ? _value.disulfideLinkage
          : disulfideLinkage as List<String>,
      subunit: subunit == freezed
          ? _value.subunit
          : subunit as List<SubstanceProteinSubunit>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceProtein implements _SubstanceProtein {
  const _$_SubstanceProtein(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceProtein')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.sequenceType,
      this.numberOfSubunits,
      this.disulfideLinkage,
      this.subunit})
      : assert(resourceType != null);

  factory _$_SubstanceProtein.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceProteinFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceProtein')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept sequenceType;
  @override
  final Integer numberOfSubunits;
  @override
  final List<String> disulfideLinkage;
  @override
  final List<SubstanceProteinSubunit> subunit;

  @override
  String toString() {
    return 'SubstanceProtein(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sequenceType: $sequenceType, numberOfSubunits: $numberOfSubunits, disulfideLinkage: $disulfideLinkage, subunit: $subunit)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceProtein &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.sequenceType, sequenceType) ||
                const DeepCollectionEquality()
                    .equals(other.sequenceType, sequenceType)) &&
            (identical(other.numberOfSubunits, numberOfSubunits) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfSubunits, numberOfSubunits)) &&
            (identical(other.disulfideLinkage, disulfideLinkage) ||
                const DeepCollectionEquality()
                    .equals(other.disulfideLinkage, disulfideLinkage)) &&
            (identical(other.subunit, subunit) ||
                const DeepCollectionEquality().equals(other.subunit, subunit)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(sequenceType) ^
      const DeepCollectionEquality().hash(numberOfSubunits) ^
      const DeepCollectionEquality().hash(disulfideLinkage) ^
      const DeepCollectionEquality().hash(subunit);

  @override
  _$SubstanceProteinCopyWith<_SubstanceProtein> get copyWith =>
      __$SubstanceProteinCopyWithImpl<_SubstanceProtein>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceProteinToJson(this);
  }
}

abstract class _SubstanceProtein implements SubstanceProtein {
  const factory _SubstanceProtein(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceProtein')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sequenceType,
      Integer numberOfSubunits,
      List<String> disulfideLinkage,
      List<SubstanceProteinSubunit> subunit}) = _$_SubstanceProtein;

  factory _SubstanceProtein.fromJson(Map<String, dynamic> json) =
      _$_SubstanceProtein.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceProtein')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get sequenceType;
  @override
  Integer get numberOfSubunits;
  @override
  List<String> get disulfideLinkage;
  @override
  List<SubstanceProteinSubunit> get subunit;
  @override
  _$SubstanceProteinCopyWith<_SubstanceProtein> get copyWith;
}

SubstanceProteinSubunit _$SubstanceProteinSubunitFromJson(
    Map<String, dynamic> json) {
  return _SubstanceProteinSubunit.fromJson(json);
}

class _$SubstanceProteinSubunitTearOff {
  const _$SubstanceProteinSubunitTearOff();

  _SubstanceProteinSubunit call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      Identifier nTerminalModificationId,
      String nTerminalModification,
      Identifier cTerminalModificationId,
      String cTerminalModification}) {
    return _SubstanceProteinSubunit(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      subunit: subunit,
      sequence: sequence,
      length: length,
      sequenceAttachment: sequenceAttachment,
      nTerminalModificationId: nTerminalModificationId,
      nTerminalModification: nTerminalModification,
      cTerminalModificationId: cTerminalModificationId,
      cTerminalModification: cTerminalModification,
    );
  }
}

// ignore: unused_element
const $SubstanceProteinSubunit = _$SubstanceProteinSubunitTearOff();

mixin _$SubstanceProteinSubunit {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get subunit;
  String get sequence;
  Integer get length;
  Attachment get sequenceAttachment;
  Identifier get nTerminalModificationId;
  String get nTerminalModification;
  Identifier get cTerminalModificationId;
  String get cTerminalModification;

  Map<String, dynamic> toJson();
  $SubstanceProteinSubunitCopyWith<SubstanceProteinSubunit> get copyWith;
}

abstract class $SubstanceProteinSubunitCopyWith<$Res> {
  factory $SubstanceProteinSubunitCopyWith(SubstanceProteinSubunit value,
          $Res Function(SubstanceProteinSubunit) then) =
      _$SubstanceProteinSubunitCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      Identifier nTerminalModificationId,
      String nTerminalModification,
      Identifier cTerminalModificationId,
      String cTerminalModification});

  $AttachmentCopyWith<$Res> get sequenceAttachment;
  $IdentifierCopyWith<$Res> get nTerminalModificationId;
  $IdentifierCopyWith<$Res> get cTerminalModificationId;
}

class _$SubstanceProteinSubunitCopyWithImpl<$Res>
    implements $SubstanceProteinSubunitCopyWith<$Res> {
  _$SubstanceProteinSubunitCopyWithImpl(this._value, this._then);

  final SubstanceProteinSubunit _value;
  // ignore: unused_field
  final $Res Function(SubstanceProteinSubunit) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subunit = freezed,
    Object sequence = freezed,
    Object length = freezed,
    Object sequenceAttachment = freezed,
    Object nTerminalModificationId = freezed,
    Object nTerminalModification = freezed,
    Object cTerminalModificationId = freezed,
    Object cTerminalModification = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subunit: subunit == freezed ? _value.subunit : subunit as Integer,
      sequence: sequence == freezed ? _value.sequence : sequence as String,
      length: length == freezed ? _value.length : length as Integer,
      sequenceAttachment: sequenceAttachment == freezed
          ? _value.sequenceAttachment
          : sequenceAttachment as Attachment,
      nTerminalModificationId: nTerminalModificationId == freezed
          ? _value.nTerminalModificationId
          : nTerminalModificationId as Identifier,
      nTerminalModification: nTerminalModification == freezed
          ? _value.nTerminalModification
          : nTerminalModification as String,
      cTerminalModificationId: cTerminalModificationId == freezed
          ? _value.cTerminalModificationId
          : cTerminalModificationId as Identifier,
      cTerminalModification: cTerminalModification == freezed
          ? _value.cTerminalModification
          : cTerminalModification as String,
    ));
  }

  @override
  $AttachmentCopyWith<$Res> get sequenceAttachment {
    if (_value.sequenceAttachment == null) {
      return null;
    }
    return $AttachmentCopyWith<$Res>(_value.sequenceAttachment, (value) {
      return _then(_value.copyWith(sequenceAttachment: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get nTerminalModificationId {
    if (_value.nTerminalModificationId == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.nTerminalModificationId, (value) {
      return _then(_value.copyWith(nTerminalModificationId: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get cTerminalModificationId {
    if (_value.cTerminalModificationId == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.cTerminalModificationId, (value) {
      return _then(_value.copyWith(cTerminalModificationId: value));
    });
  }
}

abstract class _$SubstanceProteinSubunitCopyWith<$Res>
    implements $SubstanceProteinSubunitCopyWith<$Res> {
  factory _$SubstanceProteinSubunitCopyWith(_SubstanceProteinSubunit value,
          $Res Function(_SubstanceProteinSubunit) then) =
      __$SubstanceProteinSubunitCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      Identifier nTerminalModificationId,
      String nTerminalModification,
      Identifier cTerminalModificationId,
      String cTerminalModification});

  @override
  $AttachmentCopyWith<$Res> get sequenceAttachment;
  @override
  $IdentifierCopyWith<$Res> get nTerminalModificationId;
  @override
  $IdentifierCopyWith<$Res> get cTerminalModificationId;
}

class __$SubstanceProteinSubunitCopyWithImpl<$Res>
    extends _$SubstanceProteinSubunitCopyWithImpl<$Res>
    implements _$SubstanceProteinSubunitCopyWith<$Res> {
  __$SubstanceProteinSubunitCopyWithImpl(_SubstanceProteinSubunit _value,
      $Res Function(_SubstanceProteinSubunit) _then)
      : super(_value, (v) => _then(v as _SubstanceProteinSubunit));

  @override
  _SubstanceProteinSubunit get _value =>
      super._value as _SubstanceProteinSubunit;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object subunit = freezed,
    Object sequence = freezed,
    Object length = freezed,
    Object sequenceAttachment = freezed,
    Object nTerminalModificationId = freezed,
    Object nTerminalModification = freezed,
    Object cTerminalModificationId = freezed,
    Object cTerminalModification = freezed,
  }) {
    return _then(_SubstanceProteinSubunit(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      subunit: subunit == freezed ? _value.subunit : subunit as Integer,
      sequence: sequence == freezed ? _value.sequence : sequence as String,
      length: length == freezed ? _value.length : length as Integer,
      sequenceAttachment: sequenceAttachment == freezed
          ? _value.sequenceAttachment
          : sequenceAttachment as Attachment,
      nTerminalModificationId: nTerminalModificationId == freezed
          ? _value.nTerminalModificationId
          : nTerminalModificationId as Identifier,
      nTerminalModification: nTerminalModification == freezed
          ? _value.nTerminalModification
          : nTerminalModification as String,
      cTerminalModificationId: cTerminalModificationId == freezed
          ? _value.cTerminalModificationId
          : cTerminalModificationId as Identifier,
      cTerminalModification: cTerminalModification == freezed
          ? _value.cTerminalModification
          : cTerminalModification as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceProteinSubunit implements _SubstanceProteinSubunit {
  const _$_SubstanceProteinSubunit(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.subunit,
      this.sequence,
      this.length,
      this.sequenceAttachment,
      this.nTerminalModificationId,
      this.nTerminalModification,
      this.cTerminalModificationId,
      this.cTerminalModification});

  factory _$_SubstanceProteinSubunit.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceProteinSubunitFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer subunit;
  @override
  final String sequence;
  @override
  final Integer length;
  @override
  final Attachment sequenceAttachment;
  @override
  final Identifier nTerminalModificationId;
  @override
  final String nTerminalModification;
  @override
  final Identifier cTerminalModificationId;
  @override
  final String cTerminalModification;

  @override
  String toString() {
    return 'SubstanceProteinSubunit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, subunit: $subunit, sequence: $sequence, length: $length, sequenceAttachment: $sequenceAttachment, nTerminalModificationId: $nTerminalModificationId, nTerminalModification: $nTerminalModification, cTerminalModificationId: $cTerminalModificationId, cTerminalModification: $cTerminalModification)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceProteinSubunit &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.subunit, subunit) ||
                const DeepCollectionEquality()
                    .equals(other.subunit, subunit)) &&
            (identical(other.sequence, sequence) ||
                const DeepCollectionEquality()
                    .equals(other.sequence, sequence)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.sequenceAttachment, sequenceAttachment) ||
                const DeepCollectionEquality()
                    .equals(other.sequenceAttachment, sequenceAttachment)) &&
            (identical(
                    other.nTerminalModificationId, nTerminalModificationId) ||
                const DeepCollectionEquality().equals(
                    other.nTerminalModificationId, nTerminalModificationId)) &&
            (identical(other.nTerminalModification, nTerminalModification) ||
                const DeepCollectionEquality().equals(
                    other.nTerminalModification, nTerminalModification)) &&
            (identical(
                    other.cTerminalModificationId, cTerminalModificationId) ||
                const DeepCollectionEquality().equals(
                    other.cTerminalModificationId, cTerminalModificationId)) &&
            (identical(other.cTerminalModification, cTerminalModification) ||
                const DeepCollectionEquality().equals(
                    other.cTerminalModification, cTerminalModification)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(subunit) ^
      const DeepCollectionEquality().hash(sequence) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(sequenceAttachment) ^
      const DeepCollectionEquality().hash(nTerminalModificationId) ^
      const DeepCollectionEquality().hash(nTerminalModification) ^
      const DeepCollectionEquality().hash(cTerminalModificationId) ^
      const DeepCollectionEquality().hash(cTerminalModification);

  @override
  _$SubstanceProteinSubunitCopyWith<_SubstanceProteinSubunit> get copyWith =>
      __$SubstanceProteinSubunitCopyWithImpl<_SubstanceProteinSubunit>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceProteinSubunitToJson(this);
  }
}

abstract class _SubstanceProteinSubunit implements SubstanceProteinSubunit {
  const factory _SubstanceProteinSubunit(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer subunit,
      String sequence,
      Integer length,
      Attachment sequenceAttachment,
      Identifier nTerminalModificationId,
      String nTerminalModification,
      Identifier cTerminalModificationId,
      String cTerminalModification}) = _$_SubstanceProteinSubunit;

  factory _SubstanceProteinSubunit.fromJson(Map<String, dynamic> json) =
      _$_SubstanceProteinSubunit.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get subunit;
  @override
  String get sequence;
  @override
  Integer get length;
  @override
  Attachment get sequenceAttachment;
  @override
  Identifier get nTerminalModificationId;
  @override
  String get nTerminalModification;
  @override
  Identifier get cTerminalModificationId;
  @override
  String get cTerminalModification;
  @override
  _$SubstanceProteinSubunitCopyWith<_SubstanceProteinSubunit> get copyWith;
}

SubstanceReferenceInformation _$SubstanceReferenceInformationFromJson(
    Map<String, dynamic> json) {
  return _SubstanceReferenceInformation.fromJson(json);
}

class _$SubstanceReferenceInformationTearOff {
  const _$SubstanceReferenceInformationTearOff();

  _SubstanceReferenceInformation call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String comment,
      List<SubstanceReferenceInformationGene> gene,
      List<SubstanceReferenceInformationGeneElement> geneElement,
      List<SubstanceReferenceInformationClassification> classification,
      List<SubstanceReferenceInformationTarget> target}) {
    return _SubstanceReferenceInformation(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      comment: comment,
      gene: gene,
      geneElement: geneElement,
      classification: classification,
      target: target,
    );
  }
}

// ignore: unused_element
const $SubstanceReferenceInformation = _$SubstanceReferenceInformationTearOff();

mixin _$SubstanceReferenceInformation {
  @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get comment;
  List<SubstanceReferenceInformationGene> get gene;
  List<SubstanceReferenceInformationGeneElement> get geneElement;
  List<SubstanceReferenceInformationClassification> get classification;
  List<SubstanceReferenceInformationTarget> get target;

  Map<String, dynamic> toJson();
  $SubstanceReferenceInformationCopyWith<SubstanceReferenceInformation>
      get copyWith;
}

abstract class $SubstanceReferenceInformationCopyWith<$Res> {
  factory $SubstanceReferenceInformationCopyWith(
          SubstanceReferenceInformation value,
          $Res Function(SubstanceReferenceInformation) then) =
      _$SubstanceReferenceInformationCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String comment,
      List<SubstanceReferenceInformationGene> gene,
      List<SubstanceReferenceInformationGeneElement> geneElement,
      List<SubstanceReferenceInformationClassification> classification,
      List<SubstanceReferenceInformationTarget> target});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
}

class _$SubstanceReferenceInformationCopyWithImpl<$Res>
    implements $SubstanceReferenceInformationCopyWith<$Res> {
  _$SubstanceReferenceInformationCopyWithImpl(this._value, this._then);

  final SubstanceReferenceInformation _value;
  // ignore: unused_field
  final $Res Function(SubstanceReferenceInformation) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object comment = freezed,
    Object gene = freezed,
    Object geneElement = freezed,
    Object classification = freezed,
    Object target = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      comment: comment == freezed ? _value.comment : comment as String,
      gene: gene == freezed
          ? _value.gene
          : gene as List<SubstanceReferenceInformationGene>,
      geneElement: geneElement == freezed
          ? _value.geneElement
          : geneElement as List<SubstanceReferenceInformationGeneElement>,
      classification: classification == freezed
          ? _value.classification
          : classification as List<SubstanceReferenceInformationClassification>,
      target: target == freezed
          ? _value.target
          : target as List<SubstanceReferenceInformationTarget>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }
}

abstract class _$SubstanceReferenceInformationCopyWith<$Res>
    implements $SubstanceReferenceInformationCopyWith<$Res> {
  factory _$SubstanceReferenceInformationCopyWith(
          _SubstanceReferenceInformation value,
          $Res Function(_SubstanceReferenceInformation) then) =
      __$SubstanceReferenceInformationCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String comment,
      List<SubstanceReferenceInformationGene> gene,
      List<SubstanceReferenceInformationGeneElement> geneElement,
      List<SubstanceReferenceInformationClassification> classification,
      List<SubstanceReferenceInformationTarget> target});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
}

class __$SubstanceReferenceInformationCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationCopyWithImpl<$Res>
    implements _$SubstanceReferenceInformationCopyWith<$Res> {
  __$SubstanceReferenceInformationCopyWithImpl(
      _SubstanceReferenceInformation _value,
      $Res Function(_SubstanceReferenceInformation) _then)
      : super(_value, (v) => _then(v as _SubstanceReferenceInformation));

  @override
  _SubstanceReferenceInformation get _value =>
      super._value as _SubstanceReferenceInformation;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object comment = freezed,
    Object gene = freezed,
    Object geneElement = freezed,
    Object classification = freezed,
    Object target = freezed,
  }) {
    return _then(_SubstanceReferenceInformation(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      comment: comment == freezed ? _value.comment : comment as String,
      gene: gene == freezed
          ? _value.gene
          : gene as List<SubstanceReferenceInformationGene>,
      geneElement: geneElement == freezed
          ? _value.geneElement
          : geneElement as List<SubstanceReferenceInformationGeneElement>,
      classification: classification == freezed
          ? _value.classification
          : classification as List<SubstanceReferenceInformationClassification>,
      target: target == freezed
          ? _value.target
          : target as List<SubstanceReferenceInformationTarget>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceReferenceInformation
    implements _SubstanceReferenceInformation {
  const _$_SubstanceReferenceInformation(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.comment,
      this.gene,
      this.geneElement,
      this.classification,
      this.target})
      : assert(resourceType != null);

  factory _$_SubstanceReferenceInformation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceReferenceInformationFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String comment;
  @override
  final List<SubstanceReferenceInformationGene> gene;
  @override
  final List<SubstanceReferenceInformationGeneElement> geneElement;
  @override
  final List<SubstanceReferenceInformationClassification> classification;
  @override
  final List<SubstanceReferenceInformationTarget> target;

  @override
  String toString() {
    return 'SubstanceReferenceInformation(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, comment: $comment, gene: $gene, geneElement: $geneElement, classification: $classification, target: $target)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceReferenceInformation &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.gene, gene) ||
                const DeepCollectionEquality().equals(other.gene, gene)) &&
            (identical(other.geneElement, geneElement) ||
                const DeepCollectionEquality()
                    .equals(other.geneElement, geneElement)) &&
            (identical(other.classification, classification) ||
                const DeepCollectionEquality()
                    .equals(other.classification, classification)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(gene) ^
      const DeepCollectionEquality().hash(geneElement) ^
      const DeepCollectionEquality().hash(classification) ^
      const DeepCollectionEquality().hash(target);

  @override
  _$SubstanceReferenceInformationCopyWith<_SubstanceReferenceInformation>
      get copyWith => __$SubstanceReferenceInformationCopyWithImpl<
          _SubstanceReferenceInformation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceReferenceInformationToJson(this);
  }
}

abstract class _SubstanceReferenceInformation
    implements SubstanceReferenceInformation {
  const factory _SubstanceReferenceInformation(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String comment,
      List<SubstanceReferenceInformationGene> gene,
      List<SubstanceReferenceInformationGeneElement> geneElement,
      List<SubstanceReferenceInformationClassification> classification,
      List<SubstanceReferenceInformationTarget>
          target}) = _$_SubstanceReferenceInformation;

  factory _SubstanceReferenceInformation.fromJson(Map<String, dynamic> json) =
      _$_SubstanceReferenceInformation.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceReferenceInformation')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get comment;
  @override
  List<SubstanceReferenceInformationGene> get gene;
  @override
  List<SubstanceReferenceInformationGeneElement> get geneElement;
  @override
  List<SubstanceReferenceInformationClassification> get classification;
  @override
  List<SubstanceReferenceInformationTarget> get target;
  @override
  _$SubstanceReferenceInformationCopyWith<_SubstanceReferenceInformation>
      get copyWith;
}

SubstanceReferenceInformationGene _$SubstanceReferenceInformationGeneFromJson(
    Map<String, dynamic> json) {
  return _SubstanceReferenceInformationGene.fromJson(json);
}

class _$SubstanceReferenceInformationGeneTearOff {
  const _$SubstanceReferenceInformationGeneTearOff();

  _SubstanceReferenceInformationGene call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept geneSequenceOrigin,
      CodeableConcept gene,
      List<Reference> source}) {
    return _SubstanceReferenceInformationGene(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      geneSequenceOrigin: geneSequenceOrigin,
      gene: gene,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceReferenceInformationGene =
    _$SubstanceReferenceInformationGeneTearOff();

mixin _$SubstanceReferenceInformationGene {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get geneSequenceOrigin;
  CodeableConcept get gene;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceReferenceInformationGeneCopyWith<SubstanceReferenceInformationGene>
      get copyWith;
}

abstract class $SubstanceReferenceInformationGeneCopyWith<$Res> {
  factory $SubstanceReferenceInformationGeneCopyWith(
          SubstanceReferenceInformationGene value,
          $Res Function(SubstanceReferenceInformationGene) then) =
      _$SubstanceReferenceInformationGeneCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept geneSequenceOrigin,
      CodeableConcept gene,
      List<Reference> source});

  $CodeableConceptCopyWith<$Res> get geneSequenceOrigin;
  $CodeableConceptCopyWith<$Res> get gene;
}

class _$SubstanceReferenceInformationGeneCopyWithImpl<$Res>
    implements $SubstanceReferenceInformationGeneCopyWith<$Res> {
  _$SubstanceReferenceInformationGeneCopyWithImpl(this._value, this._then);

  final SubstanceReferenceInformationGene _value;
  // ignore: unused_field
  final $Res Function(SubstanceReferenceInformationGene) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object geneSequenceOrigin = freezed,
    Object gene = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      geneSequenceOrigin: geneSequenceOrigin == freezed
          ? _value.geneSequenceOrigin
          : geneSequenceOrigin as CodeableConcept,
      gene: gene == freezed ? _value.gene : gene as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get geneSequenceOrigin {
    if (_value.geneSequenceOrigin == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.geneSequenceOrigin, (value) {
      return _then(_value.copyWith(geneSequenceOrigin: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get gene {
    if (_value.gene == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.gene, (value) {
      return _then(_value.copyWith(gene: value));
    });
  }
}

abstract class _$SubstanceReferenceInformationGeneCopyWith<$Res>
    implements $SubstanceReferenceInformationGeneCopyWith<$Res> {
  factory _$SubstanceReferenceInformationGeneCopyWith(
          _SubstanceReferenceInformationGene value,
          $Res Function(_SubstanceReferenceInformationGene) then) =
      __$SubstanceReferenceInformationGeneCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept geneSequenceOrigin,
      CodeableConcept gene,
      List<Reference> source});

  @override
  $CodeableConceptCopyWith<$Res> get geneSequenceOrigin;
  @override
  $CodeableConceptCopyWith<$Res> get gene;
}

class __$SubstanceReferenceInformationGeneCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationGeneCopyWithImpl<$Res>
    implements _$SubstanceReferenceInformationGeneCopyWith<$Res> {
  __$SubstanceReferenceInformationGeneCopyWithImpl(
      _SubstanceReferenceInformationGene _value,
      $Res Function(_SubstanceReferenceInformationGene) _then)
      : super(_value, (v) => _then(v as _SubstanceReferenceInformationGene));

  @override
  _SubstanceReferenceInformationGene get _value =>
      super._value as _SubstanceReferenceInformationGene;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object geneSequenceOrigin = freezed,
    Object gene = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceReferenceInformationGene(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      geneSequenceOrigin: geneSequenceOrigin == freezed
          ? _value.geneSequenceOrigin
          : geneSequenceOrigin as CodeableConcept,
      gene: gene == freezed ? _value.gene : gene as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceReferenceInformationGene
    implements _SubstanceReferenceInformationGene {
  const _$_SubstanceReferenceInformationGene(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.geneSequenceOrigin,
      this.gene,
      this.source});

  factory _$_SubstanceReferenceInformationGene.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceReferenceInformationGeneFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept geneSequenceOrigin;
  @override
  final CodeableConcept gene;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceReferenceInformationGene(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, geneSequenceOrigin: $geneSequenceOrigin, gene: $gene, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceReferenceInformationGene &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.geneSequenceOrigin, geneSequenceOrigin) ||
                const DeepCollectionEquality()
                    .equals(other.geneSequenceOrigin, geneSequenceOrigin)) &&
            (identical(other.gene, gene) ||
                const DeepCollectionEquality().equals(other.gene, gene)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(geneSequenceOrigin) ^
      const DeepCollectionEquality().hash(gene) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceReferenceInformationGeneCopyWith<
          _SubstanceReferenceInformationGene>
      get copyWith => __$SubstanceReferenceInformationGeneCopyWithImpl<
          _SubstanceReferenceInformationGene>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceReferenceInformationGeneToJson(this);
  }
}

abstract class _SubstanceReferenceInformationGene
    implements SubstanceReferenceInformationGene {
  const factory _SubstanceReferenceInformationGene(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept geneSequenceOrigin,
      CodeableConcept gene,
      List<Reference> source}) = _$_SubstanceReferenceInformationGene;

  factory _SubstanceReferenceInformationGene.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationGene.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get geneSequenceOrigin;
  @override
  CodeableConcept get gene;
  @override
  List<Reference> get source;
  @override
  _$SubstanceReferenceInformationGeneCopyWith<
      _SubstanceReferenceInformationGene> get copyWith;
}

SubstanceReferenceInformationGeneElement
    _$SubstanceReferenceInformationGeneElementFromJson(
        Map<String, dynamic> json) {
  return _SubstanceReferenceInformationGeneElement.fromJson(json);
}

class _$SubstanceReferenceInformationGeneElementTearOff {
  const _$SubstanceReferenceInformationGeneElementTearOff();

  _SubstanceReferenceInformationGeneElement call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Identifier element,
      List<Reference> source}) {
    return _SubstanceReferenceInformationGeneElement(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      element: element,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceReferenceInformationGeneElement =
    _$SubstanceReferenceInformationGeneElementTearOff();

mixin _$SubstanceReferenceInformationGeneElement {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  Identifier get element;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceReferenceInformationGeneElementCopyWith<
      SubstanceReferenceInformationGeneElement> get copyWith;
}

abstract class $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  factory $SubstanceReferenceInformationGeneElementCopyWith(
          SubstanceReferenceInformationGeneElement value,
          $Res Function(SubstanceReferenceInformationGeneElement) then) =
      _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Identifier element,
      List<Reference> source});

  $CodeableConceptCopyWith<$Res> get type;
  $IdentifierCopyWith<$Res> get element;
}

class _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>
    implements $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  _$SubstanceReferenceInformationGeneElementCopyWithImpl(
      this._value, this._then);

  final SubstanceReferenceInformationGeneElement _value;
  // ignore: unused_field
  final $Res Function(SubstanceReferenceInformationGeneElement) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object element = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      element: element == freezed ? _value.element : element as Identifier,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get element {
    if (_value.element == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.element, (value) {
      return _then(_value.copyWith(element: value));
    });
  }
}

abstract class _$SubstanceReferenceInformationGeneElementCopyWith<$Res>
    implements $SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  factory _$SubstanceReferenceInformationGeneElementCopyWith(
          _SubstanceReferenceInformationGeneElement value,
          $Res Function(_SubstanceReferenceInformationGeneElement) then) =
      __$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Identifier element,
      List<Reference> source});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $IdentifierCopyWith<$Res> get element;
}

class __$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationGeneElementCopyWithImpl<$Res>
    implements _$SubstanceReferenceInformationGeneElementCopyWith<$Res> {
  __$SubstanceReferenceInformationGeneElementCopyWithImpl(
      _SubstanceReferenceInformationGeneElement _value,
      $Res Function(_SubstanceReferenceInformationGeneElement) _then)
      : super(_value,
            (v) => _then(v as _SubstanceReferenceInformationGeneElement));

  @override
  _SubstanceReferenceInformationGeneElement get _value =>
      super._value as _SubstanceReferenceInformationGeneElement;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object element = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceReferenceInformationGeneElement(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      element: element == freezed ? _value.element : element as Identifier,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceReferenceInformationGeneElement
    implements _SubstanceReferenceInformationGeneElement {
  const _$_SubstanceReferenceInformationGeneElement(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.element,
      this.source});

  factory _$_SubstanceReferenceInformationGeneElement.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceReferenceInformationGeneElementFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final Identifier element;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceReferenceInformationGeneElement(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, element: $element, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceReferenceInformationGeneElement &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.element, element) ||
                const DeepCollectionEquality()
                    .equals(other.element, element)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(element) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceReferenceInformationGeneElementCopyWith<
          _SubstanceReferenceInformationGeneElement>
      get copyWith => __$SubstanceReferenceInformationGeneElementCopyWithImpl<
          _SubstanceReferenceInformationGeneElement>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceReferenceInformationGeneElementToJson(this);
  }
}

abstract class _SubstanceReferenceInformationGeneElement
    implements SubstanceReferenceInformationGeneElement {
  const factory _SubstanceReferenceInformationGeneElement(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      Identifier element,
      List<Reference> source}) = _$_SubstanceReferenceInformationGeneElement;

  factory _SubstanceReferenceInformationGeneElement.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationGeneElement.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  Identifier get element;
  @override
  List<Reference> get source;
  @override
  _$SubstanceReferenceInformationGeneElementCopyWith<
      _SubstanceReferenceInformationGeneElement> get copyWith;
}

SubstanceReferenceInformationClassification
    _$SubstanceReferenceInformationClassificationFromJson(
        Map<String, dynamic> json) {
  return _SubstanceReferenceInformationClassification.fromJson(json);
}

class _$SubstanceReferenceInformationClassificationTearOff {
  const _$SubstanceReferenceInformationClassificationTearOff();

  _SubstanceReferenceInformationClassification call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept domain,
      CodeableConcept classification,
      List<CodeableConcept> subtype,
      List<Reference> source}) {
    return _SubstanceReferenceInformationClassification(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      domain: domain,
      classification: classification,
      subtype: subtype,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceReferenceInformationClassification =
    _$SubstanceReferenceInformationClassificationTearOff();

mixin _$SubstanceReferenceInformationClassification {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get domain;
  CodeableConcept get classification;
  List<CodeableConcept> get subtype;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceReferenceInformationClassificationCopyWith<
      SubstanceReferenceInformationClassification> get copyWith;
}

abstract class $SubstanceReferenceInformationClassificationCopyWith<$Res> {
  factory $SubstanceReferenceInformationClassificationCopyWith(
          SubstanceReferenceInformationClassification value,
          $Res Function(SubstanceReferenceInformationClassification) then) =
      _$SubstanceReferenceInformationClassificationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept domain,
      CodeableConcept classification,
      List<CodeableConcept> subtype,
      List<Reference> source});

  $CodeableConceptCopyWith<$Res> get domain;
  $CodeableConceptCopyWith<$Res> get classification;
}

class _$SubstanceReferenceInformationClassificationCopyWithImpl<$Res>
    implements $SubstanceReferenceInformationClassificationCopyWith<$Res> {
  _$SubstanceReferenceInformationClassificationCopyWithImpl(
      this._value, this._then);

  final SubstanceReferenceInformationClassification _value;
  // ignore: unused_field
  final $Res Function(SubstanceReferenceInformationClassification) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object domain = freezed,
    Object classification = freezed,
    Object subtype = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      domain: domain == freezed ? _value.domain : domain as CodeableConcept,
      classification: classification == freezed
          ? _value.classification
          : classification as CodeableConcept,
      subtype: subtype == freezed
          ? _value.subtype
          : subtype as List<CodeableConcept>,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get domain {
    if (_value.domain == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.domain, (value) {
      return _then(_value.copyWith(domain: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get classification {
    if (_value.classification == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.classification, (value) {
      return _then(_value.copyWith(classification: value));
    });
  }
}

abstract class _$SubstanceReferenceInformationClassificationCopyWith<$Res>
    implements $SubstanceReferenceInformationClassificationCopyWith<$Res> {
  factory _$SubstanceReferenceInformationClassificationCopyWith(
          _SubstanceReferenceInformationClassification value,
          $Res Function(_SubstanceReferenceInformationClassification) then) =
      __$SubstanceReferenceInformationClassificationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept domain,
      CodeableConcept classification,
      List<CodeableConcept> subtype,
      List<Reference> source});

  @override
  $CodeableConceptCopyWith<$Res> get domain;
  @override
  $CodeableConceptCopyWith<$Res> get classification;
}

class __$SubstanceReferenceInformationClassificationCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationClassificationCopyWithImpl<$Res>
    implements _$SubstanceReferenceInformationClassificationCopyWith<$Res> {
  __$SubstanceReferenceInformationClassificationCopyWithImpl(
      _SubstanceReferenceInformationClassification _value,
      $Res Function(_SubstanceReferenceInformationClassification) _then)
      : super(_value,
            (v) => _then(v as _SubstanceReferenceInformationClassification));

  @override
  _SubstanceReferenceInformationClassification get _value =>
      super._value as _SubstanceReferenceInformationClassification;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object domain = freezed,
    Object classification = freezed,
    Object subtype = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceReferenceInformationClassification(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      domain: domain == freezed ? _value.domain : domain as CodeableConcept,
      classification: classification == freezed
          ? _value.classification
          : classification as CodeableConcept,
      subtype: subtype == freezed
          ? _value.subtype
          : subtype as List<CodeableConcept>,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceReferenceInformationClassification
    implements _SubstanceReferenceInformationClassification {
  const _$_SubstanceReferenceInformationClassification(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.domain,
      this.classification,
      this.subtype,
      this.source});

  factory _$_SubstanceReferenceInformationClassification.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceReferenceInformationClassificationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept domain;
  @override
  final CodeableConcept classification;
  @override
  final List<CodeableConcept> subtype;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceReferenceInformationClassification(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, domain: $domain, classification: $classification, subtype: $subtype, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceReferenceInformationClassification &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.domain, domain) ||
                const DeepCollectionEquality().equals(other.domain, domain)) &&
            (identical(other.classification, classification) ||
                const DeepCollectionEquality()
                    .equals(other.classification, classification)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(domain) ^
      const DeepCollectionEquality().hash(classification) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceReferenceInformationClassificationCopyWith<
          _SubstanceReferenceInformationClassification>
      get copyWith =>
          __$SubstanceReferenceInformationClassificationCopyWithImpl<
              _SubstanceReferenceInformationClassification>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceReferenceInformationClassificationToJson(this);
  }
}

abstract class _SubstanceReferenceInformationClassification
    implements SubstanceReferenceInformationClassification {
  const factory _SubstanceReferenceInformationClassification(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept domain,
      CodeableConcept classification,
      List<CodeableConcept> subtype,
      List<Reference> source}) = _$_SubstanceReferenceInformationClassification;

  factory _SubstanceReferenceInformationClassification.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationClassification.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get domain;
  @override
  CodeableConcept get classification;
  @override
  List<CodeableConcept> get subtype;
  @override
  List<Reference> get source;
  @override
  _$SubstanceReferenceInformationClassificationCopyWith<
      _SubstanceReferenceInformationClassification> get copyWith;
}

SubstanceReferenceInformationTarget
    _$SubstanceReferenceInformationTargetFromJson(Map<String, dynamic> json) {
  return _SubstanceReferenceInformationTarget.fromJson(json);
}

class _$SubstanceReferenceInformationTargetTearOff {
  const _$SubstanceReferenceInformationTargetTearOff();

  _SubstanceReferenceInformationTarget call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier target,
      CodeableConcept type,
      CodeableConcept interaction,
      CodeableConcept organism,
      CodeableConcept organismType,
      Quantity amountQuantity,
      Range amountRange,
      String amountString,
      CodeableConcept amountType,
      List<Reference> source}) {
    return _SubstanceReferenceInformationTarget(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      target: target,
      type: type,
      interaction: interaction,
      organism: organism,
      organismType: organismType,
      amountQuantity: amountQuantity,
      amountRange: amountRange,
      amountString: amountString,
      amountType: amountType,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceReferenceInformationTarget =
    _$SubstanceReferenceInformationTargetTearOff();

mixin _$SubstanceReferenceInformationTarget {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get target;
  CodeableConcept get type;
  CodeableConcept get interaction;
  CodeableConcept get organism;
  CodeableConcept get organismType;
  Quantity get amountQuantity;
  Range get amountRange;
  String get amountString;
  CodeableConcept get amountType;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceReferenceInformationTargetCopyWith<
      SubstanceReferenceInformationTarget> get copyWith;
}

abstract class $SubstanceReferenceInformationTargetCopyWith<$Res> {
  factory $SubstanceReferenceInformationTargetCopyWith(
          SubstanceReferenceInformationTarget value,
          $Res Function(SubstanceReferenceInformationTarget) then) =
      _$SubstanceReferenceInformationTargetCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier target,
      CodeableConcept type,
      CodeableConcept interaction,
      CodeableConcept organism,
      CodeableConcept organismType,
      Quantity amountQuantity,
      Range amountRange,
      String amountString,
      CodeableConcept amountType,
      List<Reference> source});

  $IdentifierCopyWith<$Res> get target;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get interaction;
  $CodeableConceptCopyWith<$Res> get organism;
  $CodeableConceptCopyWith<$Res> get organismType;
  $QuantityCopyWith<$Res> get amountQuantity;
  $RangeCopyWith<$Res> get amountRange;
  $CodeableConceptCopyWith<$Res> get amountType;
}

class _$SubstanceReferenceInformationTargetCopyWithImpl<$Res>
    implements $SubstanceReferenceInformationTargetCopyWith<$Res> {
  _$SubstanceReferenceInformationTargetCopyWithImpl(this._value, this._then);

  final SubstanceReferenceInformationTarget _value;
  // ignore: unused_field
  final $Res Function(SubstanceReferenceInformationTarget) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object target = freezed,
    Object type = freezed,
    Object interaction = freezed,
    Object organism = freezed,
    Object organismType = freezed,
    Object amountQuantity = freezed,
    Object amountRange = freezed,
    Object amountString = freezed,
    Object amountType = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      target: target == freezed ? _value.target : target as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      interaction: interaction == freezed
          ? _value.interaction
          : interaction as CodeableConcept,
      organism:
          organism == freezed ? _value.organism : organism as CodeableConcept,
      organismType: organismType == freezed
          ? _value.organismType
          : organismType as CodeableConcept,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountRange:
          amountRange == freezed ? _value.amountRange : amountRange as Range,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
      amountType: amountType == freezed
          ? _value.amountType
          : amountType as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get target {
    if (_value.target == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.target, (value) {
      return _then(_value.copyWith(target: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get interaction {
    if (_value.interaction == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.interaction, (value) {
      return _then(_value.copyWith(interaction: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get organism {
    if (_value.organism == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.organism, (value) {
      return _then(_value.copyWith(organism: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get organismType {
    if (_value.organismType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.organismType, (value) {
      return _then(_value.copyWith(organismType: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.amountQuantity, (value) {
      return _then(_value.copyWith(amountQuantity: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get amountRange {
    if (_value.amountRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.amountRange, (value) {
      return _then(_value.copyWith(amountRange: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get amountType {
    if (_value.amountType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.amountType, (value) {
      return _then(_value.copyWith(amountType: value));
    });
  }
}

abstract class _$SubstanceReferenceInformationTargetCopyWith<$Res>
    implements $SubstanceReferenceInformationTargetCopyWith<$Res> {
  factory _$SubstanceReferenceInformationTargetCopyWith(
          _SubstanceReferenceInformationTarget value,
          $Res Function(_SubstanceReferenceInformationTarget) then) =
      __$SubstanceReferenceInformationTargetCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier target,
      CodeableConcept type,
      CodeableConcept interaction,
      CodeableConcept organism,
      CodeableConcept organismType,
      Quantity amountQuantity,
      Range amountRange,
      String amountString,
      CodeableConcept amountType,
      List<Reference> source});

  @override
  $IdentifierCopyWith<$Res> get target;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get interaction;
  @override
  $CodeableConceptCopyWith<$Res> get organism;
  @override
  $CodeableConceptCopyWith<$Res> get organismType;
  @override
  $QuantityCopyWith<$Res> get amountQuantity;
  @override
  $RangeCopyWith<$Res> get amountRange;
  @override
  $CodeableConceptCopyWith<$Res> get amountType;
}

class __$SubstanceReferenceInformationTargetCopyWithImpl<$Res>
    extends _$SubstanceReferenceInformationTargetCopyWithImpl<$Res>
    implements _$SubstanceReferenceInformationTargetCopyWith<$Res> {
  __$SubstanceReferenceInformationTargetCopyWithImpl(
      _SubstanceReferenceInformationTarget _value,
      $Res Function(_SubstanceReferenceInformationTarget) _then)
      : super(_value, (v) => _then(v as _SubstanceReferenceInformationTarget));

  @override
  _SubstanceReferenceInformationTarget get _value =>
      super._value as _SubstanceReferenceInformationTarget;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object target = freezed,
    Object type = freezed,
    Object interaction = freezed,
    Object organism = freezed,
    Object organismType = freezed,
    Object amountQuantity = freezed,
    Object amountRange = freezed,
    Object amountString = freezed,
    Object amountType = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceReferenceInformationTarget(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      target: target == freezed ? _value.target : target as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      interaction: interaction == freezed
          ? _value.interaction
          : interaction as CodeableConcept,
      organism:
          organism == freezed ? _value.organism : organism as CodeableConcept,
      organismType: organismType == freezed
          ? _value.organismType
          : organismType as CodeableConcept,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountRange:
          amountRange == freezed ? _value.amountRange : amountRange as Range,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
      amountType: amountType == freezed
          ? _value.amountType
          : amountType as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceReferenceInformationTarget
    implements _SubstanceReferenceInformationTarget {
  const _$_SubstanceReferenceInformationTarget(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.target,
      this.type,
      this.interaction,
      this.organism,
      this.organismType,
      this.amountQuantity,
      this.amountRange,
      this.amountString,
      this.amountType,
      this.source});

  factory _$_SubstanceReferenceInformationTarget.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceReferenceInformationTargetFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier target;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept interaction;
  @override
  final CodeableConcept organism;
  @override
  final CodeableConcept organismType;
  @override
  final Quantity amountQuantity;
  @override
  final Range amountRange;
  @override
  final String amountString;
  @override
  final CodeableConcept amountType;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceReferenceInformationTarget(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, target: $target, type: $type, interaction: $interaction, organism: $organism, organismType: $organismType, amountQuantity: $amountQuantity, amountRange: $amountRange, amountString: $amountString, amountType: $amountType, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceReferenceInformationTarget &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.interaction, interaction) ||
                const DeepCollectionEquality()
                    .equals(other.interaction, interaction)) &&
            (identical(other.organism, organism) ||
                const DeepCollectionEquality()
                    .equals(other.organism, organism)) &&
            (identical(other.organismType, organismType) ||
                const DeepCollectionEquality()
                    .equals(other.organismType, organismType)) &&
            (identical(other.amountQuantity, amountQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.amountQuantity, amountQuantity)) &&
            (identical(other.amountRange, amountRange) ||
                const DeepCollectionEquality()
                    .equals(other.amountRange, amountRange)) &&
            (identical(other.amountString, amountString) ||
                const DeepCollectionEquality()
                    .equals(other.amountString, amountString)) &&
            (identical(other.amountType, amountType) ||
                const DeepCollectionEquality()
                    .equals(other.amountType, amountType)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(interaction) ^
      const DeepCollectionEquality().hash(organism) ^
      const DeepCollectionEquality().hash(organismType) ^
      const DeepCollectionEquality().hash(amountQuantity) ^
      const DeepCollectionEquality().hash(amountRange) ^
      const DeepCollectionEquality().hash(amountString) ^
      const DeepCollectionEquality().hash(amountType) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceReferenceInformationTargetCopyWith<
          _SubstanceReferenceInformationTarget>
      get copyWith => __$SubstanceReferenceInformationTargetCopyWithImpl<
          _SubstanceReferenceInformationTarget>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceReferenceInformationTargetToJson(this);
  }
}

abstract class _SubstanceReferenceInformationTarget
    implements SubstanceReferenceInformationTarget {
  const factory _SubstanceReferenceInformationTarget(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier target,
      CodeableConcept type,
      CodeableConcept interaction,
      CodeableConcept organism,
      CodeableConcept organismType,
      Quantity amountQuantity,
      Range amountRange,
      String amountString,
      CodeableConcept amountType,
      List<Reference> source}) = _$_SubstanceReferenceInformationTarget;

  factory _SubstanceReferenceInformationTarget.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceReferenceInformationTarget.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get target;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get interaction;
  @override
  CodeableConcept get organism;
  @override
  CodeableConcept get organismType;
  @override
  Quantity get amountQuantity;
  @override
  Range get amountRange;
  @override
  String get amountString;
  @override
  CodeableConcept get amountType;
  @override
  List<Reference> get source;
  @override
  _$SubstanceReferenceInformationTargetCopyWith<
      _SubstanceReferenceInformationTarget> get copyWith;
}

SubstanceSourceMaterial _$SubstanceSourceMaterialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterial.fromJson(json);
}

class _$SubstanceSourceMaterialTearOff {
  const _$SubstanceSourceMaterialTearOff();

  _SubstanceSourceMaterial call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sourceMaterialClass,
      CodeableConcept sourceMaterialType,
      CodeableConcept sourceMaterialState,
      Identifier organismId,
      String organismName,
      List<Identifier> parentSubstanceId,
      List<String> parentSubstanceName,
      List<CodeableConcept> countryOfOrigin,
      List<String> geographicalLocation,
      CodeableConcept developmentStage,
      List<SubstanceSourceMaterialFractionDescription> fractionDescription,
      SubstanceSourceMaterialOrganism organism,
      List<SubstanceSourceMaterialPartDescription> partDescription}) {
    return _SubstanceSourceMaterial(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      sourceMaterialClass: sourceMaterialClass,
      sourceMaterialType: sourceMaterialType,
      sourceMaterialState: sourceMaterialState,
      organismId: organismId,
      organismName: organismName,
      parentSubstanceId: parentSubstanceId,
      parentSubstanceName: parentSubstanceName,
      countryOfOrigin: countryOfOrigin,
      geographicalLocation: geographicalLocation,
      developmentStage: developmentStage,
      fractionDescription: fractionDescription,
      organism: organism,
      partDescription: partDescription,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterial = _$SubstanceSourceMaterialTearOff();

mixin _$SubstanceSourceMaterial {
  @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get sourceMaterialClass;
  CodeableConcept get sourceMaterialType;
  CodeableConcept get sourceMaterialState;
  Identifier get organismId;
  String get organismName;
  List<Identifier> get parentSubstanceId;
  List<String> get parentSubstanceName;
  List<CodeableConcept> get countryOfOrigin;
  List<String> get geographicalLocation;
  CodeableConcept get developmentStage;
  List<SubstanceSourceMaterialFractionDescription> get fractionDescription;
  SubstanceSourceMaterialOrganism get organism;
  List<SubstanceSourceMaterialPartDescription> get partDescription;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialCopyWith<SubstanceSourceMaterial> get copyWith;
}

abstract class $SubstanceSourceMaterialCopyWith<$Res> {
  factory $SubstanceSourceMaterialCopyWith(SubstanceSourceMaterial value,
          $Res Function(SubstanceSourceMaterial) then) =
      _$SubstanceSourceMaterialCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sourceMaterialClass,
      CodeableConcept sourceMaterialType,
      CodeableConcept sourceMaterialState,
      Identifier organismId,
      String organismName,
      List<Identifier> parentSubstanceId,
      List<String> parentSubstanceName,
      List<CodeableConcept> countryOfOrigin,
      List<String> geographicalLocation,
      CodeableConcept developmentStage,
      List<SubstanceSourceMaterialFractionDescription> fractionDescription,
      SubstanceSourceMaterialOrganism organism,
      List<SubstanceSourceMaterialPartDescription> partDescription});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $CodeableConceptCopyWith<$Res> get sourceMaterialClass;
  $CodeableConceptCopyWith<$Res> get sourceMaterialType;
  $CodeableConceptCopyWith<$Res> get sourceMaterialState;
  $IdentifierCopyWith<$Res> get organismId;
  $CodeableConceptCopyWith<$Res> get developmentStage;
  $SubstanceSourceMaterialOrganismCopyWith<$Res> get organism;
}

class _$SubstanceSourceMaterialCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialCopyWith<$Res> {
  _$SubstanceSourceMaterialCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterial _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterial) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sourceMaterialClass = freezed,
    Object sourceMaterialType = freezed,
    Object sourceMaterialState = freezed,
    Object organismId = freezed,
    Object organismName = freezed,
    Object parentSubstanceId = freezed,
    Object parentSubstanceName = freezed,
    Object countryOfOrigin = freezed,
    Object geographicalLocation = freezed,
    Object developmentStage = freezed,
    Object fractionDescription = freezed,
    Object organism = freezed,
    Object partDescription = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sourceMaterialClass: sourceMaterialClass == freezed
          ? _value.sourceMaterialClass
          : sourceMaterialClass as CodeableConcept,
      sourceMaterialType: sourceMaterialType == freezed
          ? _value.sourceMaterialType
          : sourceMaterialType as CodeableConcept,
      sourceMaterialState: sourceMaterialState == freezed
          ? _value.sourceMaterialState
          : sourceMaterialState as CodeableConcept,
      organismId:
          organismId == freezed ? _value.organismId : organismId as Identifier,
      organismName: organismName == freezed
          ? _value.organismName
          : organismName as String,
      parentSubstanceId: parentSubstanceId == freezed
          ? _value.parentSubstanceId
          : parentSubstanceId as List<Identifier>,
      parentSubstanceName: parentSubstanceName == freezed
          ? _value.parentSubstanceName
          : parentSubstanceName as List<String>,
      countryOfOrigin: countryOfOrigin == freezed
          ? _value.countryOfOrigin
          : countryOfOrigin as List<CodeableConcept>,
      geographicalLocation: geographicalLocation == freezed
          ? _value.geographicalLocation
          : geographicalLocation as List<String>,
      developmentStage: developmentStage == freezed
          ? _value.developmentStage
          : developmentStage as CodeableConcept,
      fractionDescription: fractionDescription == freezed
          ? _value.fractionDescription
          : fractionDescription
              as List<SubstanceSourceMaterialFractionDescription>,
      organism: organism == freezed
          ? _value.organism
          : organism as SubstanceSourceMaterialOrganism,
      partDescription: partDescription == freezed
          ? _value.partDescription
          : partDescription as List<SubstanceSourceMaterialPartDescription>,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialClass {
    if (_value.sourceMaterialClass == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialClass, (value) {
      return _then(_value.copyWith(sourceMaterialClass: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialType {
    if (_value.sourceMaterialType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialType, (value) {
      return _then(_value.copyWith(sourceMaterialType: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialState {
    if (_value.sourceMaterialState == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.sourceMaterialState, (value) {
      return _then(_value.copyWith(sourceMaterialState: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get organismId {
    if (_value.organismId == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.organismId, (value) {
      return _then(_value.copyWith(organismId: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get developmentStage {
    if (_value.developmentStage == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.developmentStage, (value) {
      return _then(_value.copyWith(developmentStage: value));
    });
  }

  @override
  $SubstanceSourceMaterialOrganismCopyWith<$Res> get organism {
    if (_value.organism == null) {
      return null;
    }
    return $SubstanceSourceMaterialOrganismCopyWith<$Res>(_value.organism,
        (value) {
      return _then(_value.copyWith(organism: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialCopyWith<$Res>
    implements $SubstanceSourceMaterialCopyWith<$Res> {
  factory _$SubstanceSourceMaterialCopyWith(_SubstanceSourceMaterial value,
          $Res Function(_SubstanceSourceMaterial) then) =
      __$SubstanceSourceMaterialCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept sourceMaterialClass,
      CodeableConcept sourceMaterialType,
      CodeableConcept sourceMaterialState,
      Identifier organismId,
      String organismName,
      List<Identifier> parentSubstanceId,
      List<String> parentSubstanceName,
      List<CodeableConcept> countryOfOrigin,
      List<String> geographicalLocation,
      CodeableConcept developmentStage,
      List<SubstanceSourceMaterialFractionDescription> fractionDescription,
      SubstanceSourceMaterialOrganism organism,
      List<SubstanceSourceMaterialPartDescription> partDescription});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialClass;
  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialType;
  @override
  $CodeableConceptCopyWith<$Res> get sourceMaterialState;
  @override
  $IdentifierCopyWith<$Res> get organismId;
  @override
  $CodeableConceptCopyWith<$Res> get developmentStage;
  @override
  $SubstanceSourceMaterialOrganismCopyWith<$Res> get organism;
}

class __$SubstanceSourceMaterialCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialCopyWith<$Res> {
  __$SubstanceSourceMaterialCopyWithImpl(_SubstanceSourceMaterial _value,
      $Res Function(_SubstanceSourceMaterial) _then)
      : super(_value, (v) => _then(v as _SubstanceSourceMaterial));

  @override
  _SubstanceSourceMaterial get _value =>
      super._value as _SubstanceSourceMaterial;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object sourceMaterialClass = freezed,
    Object sourceMaterialType = freezed,
    Object sourceMaterialState = freezed,
    Object organismId = freezed,
    Object organismName = freezed,
    Object parentSubstanceId = freezed,
    Object parentSubstanceName = freezed,
    Object countryOfOrigin = freezed,
    Object geographicalLocation = freezed,
    Object developmentStage = freezed,
    Object fractionDescription = freezed,
    Object organism = freezed,
    Object partDescription = freezed,
  }) {
    return _then(_SubstanceSourceMaterial(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      sourceMaterialClass: sourceMaterialClass == freezed
          ? _value.sourceMaterialClass
          : sourceMaterialClass as CodeableConcept,
      sourceMaterialType: sourceMaterialType == freezed
          ? _value.sourceMaterialType
          : sourceMaterialType as CodeableConcept,
      sourceMaterialState: sourceMaterialState == freezed
          ? _value.sourceMaterialState
          : sourceMaterialState as CodeableConcept,
      organismId:
          organismId == freezed ? _value.organismId : organismId as Identifier,
      organismName: organismName == freezed
          ? _value.organismName
          : organismName as String,
      parentSubstanceId: parentSubstanceId == freezed
          ? _value.parentSubstanceId
          : parentSubstanceId as List<Identifier>,
      parentSubstanceName: parentSubstanceName == freezed
          ? _value.parentSubstanceName
          : parentSubstanceName as List<String>,
      countryOfOrigin: countryOfOrigin == freezed
          ? _value.countryOfOrigin
          : countryOfOrigin as List<CodeableConcept>,
      geographicalLocation: geographicalLocation == freezed
          ? _value.geographicalLocation
          : geographicalLocation as List<String>,
      developmentStage: developmentStage == freezed
          ? _value.developmentStage
          : developmentStage as CodeableConcept,
      fractionDescription: fractionDescription == freezed
          ? _value.fractionDescription
          : fractionDescription
              as List<SubstanceSourceMaterialFractionDescription>,
      organism: organism == freezed
          ? _value.organism
          : organism as SubstanceSourceMaterialOrganism,
      partDescription: partDescription == freezed
          ? _value.partDescription
          : partDescription as List<SubstanceSourceMaterialPartDescription>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterial implements _SubstanceSourceMaterial {
  const _$_SubstanceSourceMaterial(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.sourceMaterialClass,
      this.sourceMaterialType,
      this.sourceMaterialState,
      this.organismId,
      this.organismName,
      this.parentSubstanceId,
      this.parentSubstanceName,
      this.countryOfOrigin,
      this.geographicalLocation,
      this.developmentStage,
      this.fractionDescription,
      this.organism,
      this.partDescription})
      : assert(resourceType != null);

  factory _$_SubstanceSourceMaterial.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept sourceMaterialClass;
  @override
  final CodeableConcept sourceMaterialType;
  @override
  final CodeableConcept sourceMaterialState;
  @override
  final Identifier organismId;
  @override
  final String organismName;
  @override
  final List<Identifier> parentSubstanceId;
  @override
  final List<String> parentSubstanceName;
  @override
  final List<CodeableConcept> countryOfOrigin;
  @override
  final List<String> geographicalLocation;
  @override
  final CodeableConcept developmentStage;
  @override
  final List<SubstanceSourceMaterialFractionDescription> fractionDescription;
  @override
  final SubstanceSourceMaterialOrganism organism;
  @override
  final List<SubstanceSourceMaterialPartDescription> partDescription;

  @override
  String toString() {
    return 'SubstanceSourceMaterial(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, sourceMaterialClass: $sourceMaterialClass, sourceMaterialType: $sourceMaterialType, sourceMaterialState: $sourceMaterialState, organismId: $organismId, organismName: $organismName, parentSubstanceId: $parentSubstanceId, parentSubstanceName: $parentSubstanceName, countryOfOrigin: $countryOfOrigin, geographicalLocation: $geographicalLocation, developmentStage: $developmentStage, fractionDescription: $fractionDescription, organism: $organism, partDescription: $partDescription)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterial &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.sourceMaterialClass, sourceMaterialClass) ||
                const DeepCollectionEquality()
                    .equals(other.sourceMaterialClass, sourceMaterialClass)) &&
            (identical(other.sourceMaterialType, sourceMaterialType) ||
                const DeepCollectionEquality()
                    .equals(other.sourceMaterialType, sourceMaterialType)) &&
            (identical(other.sourceMaterialState, sourceMaterialState) ||
                const DeepCollectionEquality()
                    .equals(other.sourceMaterialState, sourceMaterialState)) &&
            (identical(other.organismId, organismId) ||
                const DeepCollectionEquality()
                    .equals(other.organismId, organismId)) &&
            (identical(other.organismName, organismName) ||
                const DeepCollectionEquality()
                    .equals(other.organismName, organismName)) &&
            (identical(other.parentSubstanceId, parentSubstanceId) ||
                const DeepCollectionEquality()
                    .equals(other.parentSubstanceId, parentSubstanceId)) &&
            (identical(other.parentSubstanceName, parentSubstanceName) ||
                const DeepCollectionEquality()
                    .equals(other.parentSubstanceName, parentSubstanceName)) &&
            (identical(other.countryOfOrigin, countryOfOrigin) ||
                const DeepCollectionEquality()
                    .equals(other.countryOfOrigin, countryOfOrigin)) &&
            (identical(other.geographicalLocation, geographicalLocation) ||
                const DeepCollectionEquality().equals(
                    other.geographicalLocation, geographicalLocation)) &&
            (identical(other.developmentStage, developmentStage) ||
                const DeepCollectionEquality()
                    .equals(other.developmentStage, developmentStage)) &&
            (identical(other.fractionDescription, fractionDescription) ||
                const DeepCollectionEquality()
                    .equals(other.fractionDescription, fractionDescription)) &&
            (identical(other.organism, organism) ||
                const DeepCollectionEquality()
                    .equals(other.organism, organism)) &&
            (identical(other.partDescription, partDescription) ||
                const DeepCollectionEquality()
                    .equals(other.partDescription, partDescription)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(sourceMaterialClass) ^
      const DeepCollectionEquality().hash(sourceMaterialType) ^
      const DeepCollectionEquality().hash(sourceMaterialState) ^
      const DeepCollectionEquality().hash(organismId) ^
      const DeepCollectionEquality().hash(organismName) ^
      const DeepCollectionEquality().hash(parentSubstanceId) ^
      const DeepCollectionEquality().hash(parentSubstanceName) ^
      const DeepCollectionEquality().hash(countryOfOrigin) ^
      const DeepCollectionEquality().hash(geographicalLocation) ^
      const DeepCollectionEquality().hash(developmentStage) ^
      const DeepCollectionEquality().hash(fractionDescription) ^
      const DeepCollectionEquality().hash(organism) ^
      const DeepCollectionEquality().hash(partDescription);

  @override
  _$SubstanceSourceMaterialCopyWith<_SubstanceSourceMaterial> get copyWith =>
      __$SubstanceSourceMaterialCopyWithImpl<_SubstanceSourceMaterial>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialToJson(this);
  }
}

abstract class _SubstanceSourceMaterial implements SubstanceSourceMaterial {
  const factory _SubstanceSourceMaterial(
          {@required
          @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
              String resourceType,
          Id id,
          Meta meta,
          FhirUri implicitRules,
          Code language,
          Narrative text,
          List<Resource> contained,
          @JsonKey(name: 'extension')
              List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept sourceMaterialClass,
          CodeableConcept sourceMaterialType,
          CodeableConcept sourceMaterialState,
          Identifier organismId,
          String organismName,
          List<Identifier> parentSubstanceId,
          List<String> parentSubstanceName,
          List<CodeableConcept> countryOfOrigin,
          List<String> geographicalLocation,
          CodeableConcept developmentStage,
          List<SubstanceSourceMaterialFractionDescription> fractionDescription,
          SubstanceSourceMaterialOrganism organism,
          List<SubstanceSourceMaterialPartDescription> partDescription}) =
      _$_SubstanceSourceMaterial;

  factory _SubstanceSourceMaterial.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterial.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceSourceMaterial')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get sourceMaterialClass;
  @override
  CodeableConcept get sourceMaterialType;
  @override
  CodeableConcept get sourceMaterialState;
  @override
  Identifier get organismId;
  @override
  String get organismName;
  @override
  List<Identifier> get parentSubstanceId;
  @override
  List<String> get parentSubstanceName;
  @override
  List<CodeableConcept> get countryOfOrigin;
  @override
  List<String> get geographicalLocation;
  @override
  CodeableConcept get developmentStage;
  @override
  List<SubstanceSourceMaterialFractionDescription> get fractionDescription;
  @override
  SubstanceSourceMaterialOrganism get organism;
  @override
  List<SubstanceSourceMaterialPartDescription> get partDescription;
  @override
  _$SubstanceSourceMaterialCopyWith<_SubstanceSourceMaterial> get copyWith;
}

SubstanceSourceMaterialFractionDescription
    _$SubstanceSourceMaterialFractionDescriptionFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialFractionDescription.fromJson(json);
}

class _$SubstanceSourceMaterialFractionDescriptionTearOff {
  const _$SubstanceSourceMaterialFractionDescriptionTearOff();

  _SubstanceSourceMaterialFractionDescription call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String fraction,
      CodeableConcept materialType}) {
    return _SubstanceSourceMaterialFractionDescription(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      fraction: fraction,
      materialType: materialType,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialFractionDescription =
    _$SubstanceSourceMaterialFractionDescriptionTearOff();

mixin _$SubstanceSourceMaterialFractionDescription {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get fraction;
  CodeableConcept get materialType;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialFractionDescriptionCopyWith<
      SubstanceSourceMaterialFractionDescription> get copyWith;
}

abstract class $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  factory $SubstanceSourceMaterialFractionDescriptionCopyWith(
          SubstanceSourceMaterialFractionDescription value,
          $Res Function(SubstanceSourceMaterialFractionDescription) then) =
      _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String fraction,
      CodeableConcept materialType});

  $CodeableConceptCopyWith<$Res> get materialType;
}

class _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl(
      this._value, this._then);

  final SubstanceSourceMaterialFractionDescription _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialFractionDescription) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object fraction = freezed,
    Object materialType = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      fraction: fraction == freezed ? _value.fraction : fraction as String,
      materialType: materialType == freezed
          ? _value.materialType
          : materialType as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get materialType {
    if (_value.materialType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.materialType, (value) {
      return _then(_value.copyWith(materialType: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialFractionDescriptionCopyWith<$Res>
    implements $SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  factory _$SubstanceSourceMaterialFractionDescriptionCopyWith(
          _SubstanceSourceMaterialFractionDescription value,
          $Res Function(_SubstanceSourceMaterialFractionDescription) then) =
      __$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String fraction,
      CodeableConcept materialType});

  @override
  $CodeableConceptCopyWith<$Res> get materialType;
}

class __$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialFractionDescriptionCopyWith<$Res> {
  __$SubstanceSourceMaterialFractionDescriptionCopyWithImpl(
      _SubstanceSourceMaterialFractionDescription _value,
      $Res Function(_SubstanceSourceMaterialFractionDescription) _then)
      : super(_value,
            (v) => _then(v as _SubstanceSourceMaterialFractionDescription));

  @override
  _SubstanceSourceMaterialFractionDescription get _value =>
      super._value as _SubstanceSourceMaterialFractionDescription;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object fraction = freezed,
    Object materialType = freezed,
  }) {
    return _then(_SubstanceSourceMaterialFractionDescription(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      fraction: fraction == freezed ? _value.fraction : fraction as String,
      materialType: materialType == freezed
          ? _value.materialType
          : materialType as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialFractionDescription
    implements _SubstanceSourceMaterialFractionDescription {
  const _$_SubstanceSourceMaterialFractionDescription(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.fraction,
      this.materialType});

  factory _$_SubstanceSourceMaterialFractionDescription.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialFractionDescriptionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String fraction;
  @override
  final CodeableConcept materialType;

  @override
  String toString() {
    return 'SubstanceSourceMaterialFractionDescription(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, fraction: $fraction, materialType: $materialType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialFractionDescription &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.fraction, fraction) ||
                const DeepCollectionEquality()
                    .equals(other.fraction, fraction)) &&
            (identical(other.materialType, materialType) ||
                const DeepCollectionEquality()
                    .equals(other.materialType, materialType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(fraction) ^
      const DeepCollectionEquality().hash(materialType);

  @override
  _$SubstanceSourceMaterialFractionDescriptionCopyWith<
          _SubstanceSourceMaterialFractionDescription>
      get copyWith => __$SubstanceSourceMaterialFractionDescriptionCopyWithImpl<
          _SubstanceSourceMaterialFractionDescription>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialFractionDescriptionToJson(this);
  }
}

abstract class _SubstanceSourceMaterialFractionDescription
    implements SubstanceSourceMaterialFractionDescription {
  const factory _SubstanceSourceMaterialFractionDescription(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String fraction,
          CodeableConcept materialType}) =
      _$_SubstanceSourceMaterialFractionDescription;

  factory _SubstanceSourceMaterialFractionDescription.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialFractionDescription.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get fraction;
  @override
  CodeableConcept get materialType;
  @override
  _$SubstanceSourceMaterialFractionDescriptionCopyWith<
      _SubstanceSourceMaterialFractionDescription> get copyWith;
}

SubstanceSourceMaterialOrganism _$SubstanceSourceMaterialOrganismFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialOrganism.fromJson(json);
}

class _$SubstanceSourceMaterialOrganismTearOff {
  const _$SubstanceSourceMaterialOrganismTearOff();

  _SubstanceSourceMaterialOrganism call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept family,
      CodeableConcept genus,
      CodeableConcept species,
      CodeableConcept intraspecificType,
      String intraspecificDescription,
      List<SubstanceSourceMaterialAuthor> author,
      SubstanceSourceMaterialHybrid hybrid,
      SubstanceSourceMaterialOrganismGeneral organismGeneral}) {
    return _SubstanceSourceMaterialOrganism(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      family: family,
      genus: genus,
      species: species,
      intraspecificType: intraspecificType,
      intraspecificDescription: intraspecificDescription,
      author: author,
      hybrid: hybrid,
      organismGeneral: organismGeneral,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialOrganism =
    _$SubstanceSourceMaterialOrganismTearOff();

mixin _$SubstanceSourceMaterialOrganism {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get family;
  CodeableConcept get genus;
  CodeableConcept get species;
  CodeableConcept get intraspecificType;
  String get intraspecificDescription;
  List<SubstanceSourceMaterialAuthor> get author;
  SubstanceSourceMaterialHybrid get hybrid;
  SubstanceSourceMaterialOrganismGeneral get organismGeneral;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialOrganismCopyWith<SubstanceSourceMaterialOrganism>
      get copyWith;
}

abstract class $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  factory $SubstanceSourceMaterialOrganismCopyWith(
          SubstanceSourceMaterialOrganism value,
          $Res Function(SubstanceSourceMaterialOrganism) then) =
      _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept family,
      CodeableConcept genus,
      CodeableConcept species,
      CodeableConcept intraspecificType,
      String intraspecificDescription,
      List<SubstanceSourceMaterialAuthor> author,
      SubstanceSourceMaterialHybrid hybrid,
      SubstanceSourceMaterialOrganismGeneral organismGeneral});

  $CodeableConceptCopyWith<$Res> get family;
  $CodeableConceptCopyWith<$Res> get genus;
  $CodeableConceptCopyWith<$Res> get species;
  $CodeableConceptCopyWith<$Res> get intraspecificType;
  $SubstanceSourceMaterialHybridCopyWith<$Res> get hybrid;
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> get organismGeneral;
}

class _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  _$SubstanceSourceMaterialOrganismCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterialOrganism _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialOrganism) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object family = freezed,
    Object genus = freezed,
    Object species = freezed,
    Object intraspecificType = freezed,
    Object intraspecificDescription = freezed,
    Object author = freezed,
    Object hybrid = freezed,
    Object organismGeneral = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      family: family == freezed ? _value.family : family as CodeableConcept,
      genus: genus == freezed ? _value.genus : genus as CodeableConcept,
      species: species == freezed ? _value.species : species as CodeableConcept,
      intraspecificType: intraspecificType == freezed
          ? _value.intraspecificType
          : intraspecificType as CodeableConcept,
      intraspecificDescription: intraspecificDescription == freezed
          ? _value.intraspecificDescription
          : intraspecificDescription as String,
      author: author == freezed
          ? _value.author
          : author as List<SubstanceSourceMaterialAuthor>,
      hybrid: hybrid == freezed
          ? _value.hybrid
          : hybrid as SubstanceSourceMaterialHybrid,
      organismGeneral: organismGeneral == freezed
          ? _value.organismGeneral
          : organismGeneral as SubstanceSourceMaterialOrganismGeneral,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get family {
    if (_value.family == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.family, (value) {
      return _then(_value.copyWith(family: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get genus {
    if (_value.genus == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.genus, (value) {
      return _then(_value.copyWith(genus: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get species {
    if (_value.species == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.species, (value) {
      return _then(_value.copyWith(species: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get intraspecificType {
    if (_value.intraspecificType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.intraspecificType, (value) {
      return _then(_value.copyWith(intraspecificType: value));
    });
  }

  @override
  $SubstanceSourceMaterialHybridCopyWith<$Res> get hybrid {
    if (_value.hybrid == null) {
      return null;
    }
    return $SubstanceSourceMaterialHybridCopyWith<$Res>(_value.hybrid, (value) {
      return _then(_value.copyWith(hybrid: value));
    });
  }

  @override
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> get organismGeneral {
    if (_value.organismGeneral == null) {
      return null;
    }
    return $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>(
        _value.organismGeneral, (value) {
      return _then(_value.copyWith(organismGeneral: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialOrganismCopyWith<$Res>
    implements $SubstanceSourceMaterialOrganismCopyWith<$Res> {
  factory _$SubstanceSourceMaterialOrganismCopyWith(
          _SubstanceSourceMaterialOrganism value,
          $Res Function(_SubstanceSourceMaterialOrganism) then) =
      __$SubstanceSourceMaterialOrganismCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept family,
      CodeableConcept genus,
      CodeableConcept species,
      CodeableConcept intraspecificType,
      String intraspecificDescription,
      List<SubstanceSourceMaterialAuthor> author,
      SubstanceSourceMaterialHybrid hybrid,
      SubstanceSourceMaterialOrganismGeneral organismGeneral});

  @override
  $CodeableConceptCopyWith<$Res> get family;
  @override
  $CodeableConceptCopyWith<$Res> get genus;
  @override
  $CodeableConceptCopyWith<$Res> get species;
  @override
  $CodeableConceptCopyWith<$Res> get intraspecificType;
  @override
  $SubstanceSourceMaterialHybridCopyWith<$Res> get hybrid;
  @override
  $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> get organismGeneral;
}

class __$SubstanceSourceMaterialOrganismCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialOrganismCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialOrganismCopyWith<$Res> {
  __$SubstanceSourceMaterialOrganismCopyWithImpl(
      _SubstanceSourceMaterialOrganism _value,
      $Res Function(_SubstanceSourceMaterialOrganism) _then)
      : super(_value, (v) => _then(v as _SubstanceSourceMaterialOrganism));

  @override
  _SubstanceSourceMaterialOrganism get _value =>
      super._value as _SubstanceSourceMaterialOrganism;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object family = freezed,
    Object genus = freezed,
    Object species = freezed,
    Object intraspecificType = freezed,
    Object intraspecificDescription = freezed,
    Object author = freezed,
    Object hybrid = freezed,
    Object organismGeneral = freezed,
  }) {
    return _then(_SubstanceSourceMaterialOrganism(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      family: family == freezed ? _value.family : family as CodeableConcept,
      genus: genus == freezed ? _value.genus : genus as CodeableConcept,
      species: species == freezed ? _value.species : species as CodeableConcept,
      intraspecificType: intraspecificType == freezed
          ? _value.intraspecificType
          : intraspecificType as CodeableConcept,
      intraspecificDescription: intraspecificDescription == freezed
          ? _value.intraspecificDescription
          : intraspecificDescription as String,
      author: author == freezed
          ? _value.author
          : author as List<SubstanceSourceMaterialAuthor>,
      hybrid: hybrid == freezed
          ? _value.hybrid
          : hybrid as SubstanceSourceMaterialHybrid,
      organismGeneral: organismGeneral == freezed
          ? _value.organismGeneral
          : organismGeneral as SubstanceSourceMaterialOrganismGeneral,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialOrganism
    implements _SubstanceSourceMaterialOrganism {
  const _$_SubstanceSourceMaterialOrganism(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.family,
      this.genus,
      this.species,
      this.intraspecificType,
      this.intraspecificDescription,
      this.author,
      this.hybrid,
      this.organismGeneral});

  factory _$_SubstanceSourceMaterialOrganism.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialOrganismFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept family;
  @override
  final CodeableConcept genus;
  @override
  final CodeableConcept species;
  @override
  final CodeableConcept intraspecificType;
  @override
  final String intraspecificDescription;
  @override
  final List<SubstanceSourceMaterialAuthor> author;
  @override
  final SubstanceSourceMaterialHybrid hybrid;
  @override
  final SubstanceSourceMaterialOrganismGeneral organismGeneral;

  @override
  String toString() {
    return 'SubstanceSourceMaterialOrganism(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, family: $family, genus: $genus, species: $species, intraspecificType: $intraspecificType, intraspecificDescription: $intraspecificDescription, author: $author, hybrid: $hybrid, organismGeneral: $organismGeneral)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialOrganism &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.family, family) ||
                const DeepCollectionEquality().equals(other.family, family)) &&
            (identical(other.genus, genus) ||
                const DeepCollectionEquality().equals(other.genus, genus)) &&
            (identical(other.species, species) ||
                const DeepCollectionEquality()
                    .equals(other.species, species)) &&
            (identical(other.intraspecificType, intraspecificType) ||
                const DeepCollectionEquality()
                    .equals(other.intraspecificType, intraspecificType)) &&
            (identical(
                    other.intraspecificDescription, intraspecificDescription) ||
                const DeepCollectionEquality().equals(
                    other.intraspecificDescription,
                    intraspecificDescription)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.hybrid, hybrid) ||
                const DeepCollectionEquality().equals(other.hybrid, hybrid)) &&
            (identical(other.organismGeneral, organismGeneral) ||
                const DeepCollectionEquality()
                    .equals(other.organismGeneral, organismGeneral)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(family) ^
      const DeepCollectionEquality().hash(genus) ^
      const DeepCollectionEquality().hash(species) ^
      const DeepCollectionEquality().hash(intraspecificType) ^
      const DeepCollectionEquality().hash(intraspecificDescription) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(hybrid) ^
      const DeepCollectionEquality().hash(organismGeneral);

  @override
  _$SubstanceSourceMaterialOrganismCopyWith<_SubstanceSourceMaterialOrganism>
      get copyWith => __$SubstanceSourceMaterialOrganismCopyWithImpl<
          _SubstanceSourceMaterialOrganism>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialOrganismToJson(this);
  }
}

abstract class _SubstanceSourceMaterialOrganism
    implements SubstanceSourceMaterialOrganism {
  const factory _SubstanceSourceMaterialOrganism(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept family,
          CodeableConcept genus,
          CodeableConcept species,
          CodeableConcept intraspecificType,
          String intraspecificDescription,
          List<SubstanceSourceMaterialAuthor> author,
          SubstanceSourceMaterialHybrid hybrid,
          SubstanceSourceMaterialOrganismGeneral organismGeneral}) =
      _$_SubstanceSourceMaterialOrganism;

  factory _SubstanceSourceMaterialOrganism.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialOrganism.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get family;
  @override
  CodeableConcept get genus;
  @override
  CodeableConcept get species;
  @override
  CodeableConcept get intraspecificType;
  @override
  String get intraspecificDescription;
  @override
  List<SubstanceSourceMaterialAuthor> get author;
  @override
  SubstanceSourceMaterialHybrid get hybrid;
  @override
  SubstanceSourceMaterialOrganismGeneral get organismGeneral;
  @override
  _$SubstanceSourceMaterialOrganismCopyWith<_SubstanceSourceMaterialOrganism>
      get copyWith;
}

SubstanceSourceMaterialAuthor _$SubstanceSourceMaterialAuthorFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialAuthor.fromJson(json);
}

class _$SubstanceSourceMaterialAuthorTearOff {
  const _$SubstanceSourceMaterialAuthorTearOff();

  _SubstanceSourceMaterialAuthor call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authorType,
      String authorDescription}) {
    return _SubstanceSourceMaterialAuthor(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      authorType: authorType,
      authorDescription: authorDescription,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialAuthor = _$SubstanceSourceMaterialAuthorTearOff();

mixin _$SubstanceSourceMaterialAuthor {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get authorType;
  String get authorDescription;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialAuthorCopyWith<SubstanceSourceMaterialAuthor>
      get copyWith;
}

abstract class $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  factory $SubstanceSourceMaterialAuthorCopyWith(
          SubstanceSourceMaterialAuthor value,
          $Res Function(SubstanceSourceMaterialAuthor) then) =
      _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authorType,
      String authorDescription});

  $CodeableConceptCopyWith<$Res> get authorType;
}

class _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  _$SubstanceSourceMaterialAuthorCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterialAuthor _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialAuthor) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object authorType = freezed,
    Object authorDescription = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      authorType: authorType == freezed
          ? _value.authorType
          : authorType as CodeableConcept,
      authorDescription: authorDescription == freezed
          ? _value.authorDescription
          : authorDescription as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get authorType {
    if (_value.authorType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.authorType, (value) {
      return _then(_value.copyWith(authorType: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialAuthorCopyWith<$Res>
    implements $SubstanceSourceMaterialAuthorCopyWith<$Res> {
  factory _$SubstanceSourceMaterialAuthorCopyWith(
          _SubstanceSourceMaterialAuthor value,
          $Res Function(_SubstanceSourceMaterialAuthor) then) =
      __$SubstanceSourceMaterialAuthorCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authorType,
      String authorDescription});

  @override
  $CodeableConceptCopyWith<$Res> get authorType;
}

class __$SubstanceSourceMaterialAuthorCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialAuthorCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialAuthorCopyWith<$Res> {
  __$SubstanceSourceMaterialAuthorCopyWithImpl(
      _SubstanceSourceMaterialAuthor _value,
      $Res Function(_SubstanceSourceMaterialAuthor) _then)
      : super(_value, (v) => _then(v as _SubstanceSourceMaterialAuthor));

  @override
  _SubstanceSourceMaterialAuthor get _value =>
      super._value as _SubstanceSourceMaterialAuthor;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object authorType = freezed,
    Object authorDescription = freezed,
  }) {
    return _then(_SubstanceSourceMaterialAuthor(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      authorType: authorType == freezed
          ? _value.authorType
          : authorType as CodeableConcept,
      authorDescription: authorDescription == freezed
          ? _value.authorDescription
          : authorDescription as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialAuthor
    implements _SubstanceSourceMaterialAuthor {
  const _$_SubstanceSourceMaterialAuthor(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.authorType,
      this.authorDescription});

  factory _$_SubstanceSourceMaterialAuthor.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialAuthorFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept authorType;
  @override
  final String authorDescription;

  @override
  String toString() {
    return 'SubstanceSourceMaterialAuthor(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, authorType: $authorType, authorDescription: $authorDescription)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialAuthor &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.authorType, authorType) ||
                const DeepCollectionEquality()
                    .equals(other.authorType, authorType)) &&
            (identical(other.authorDescription, authorDescription) ||
                const DeepCollectionEquality()
                    .equals(other.authorDescription, authorDescription)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(authorType) ^
      const DeepCollectionEquality().hash(authorDescription);

  @override
  _$SubstanceSourceMaterialAuthorCopyWith<_SubstanceSourceMaterialAuthor>
      get copyWith => __$SubstanceSourceMaterialAuthorCopyWithImpl<
          _SubstanceSourceMaterialAuthor>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialAuthorToJson(this);
  }
}

abstract class _SubstanceSourceMaterialAuthor
    implements SubstanceSourceMaterialAuthor {
  const factory _SubstanceSourceMaterialAuthor(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authorType,
      String authorDescription}) = _$_SubstanceSourceMaterialAuthor;

  factory _SubstanceSourceMaterialAuthor.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialAuthor.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get authorType;
  @override
  String get authorDescription;
  @override
  _$SubstanceSourceMaterialAuthorCopyWith<_SubstanceSourceMaterialAuthor>
      get copyWith;
}

SubstanceSourceMaterialHybrid _$SubstanceSourceMaterialHybridFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSourceMaterialHybrid.fromJson(json);
}

class _$SubstanceSourceMaterialHybridTearOff {
  const _$SubstanceSourceMaterialHybridTearOff();

  _SubstanceSourceMaterialHybrid call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String maternalOrganismId,
      String maternalOrganismName,
      String paternalOrganismId,
      String paternalOrganismName,
      CodeableConcept hybridType}) {
    return _SubstanceSourceMaterialHybrid(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      maternalOrganismId: maternalOrganismId,
      maternalOrganismName: maternalOrganismName,
      paternalOrganismId: paternalOrganismId,
      paternalOrganismName: paternalOrganismName,
      hybridType: hybridType,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialHybrid = _$SubstanceSourceMaterialHybridTearOff();

mixin _$SubstanceSourceMaterialHybrid {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get maternalOrganismId;
  String get maternalOrganismName;
  String get paternalOrganismId;
  String get paternalOrganismName;
  CodeableConcept get hybridType;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialHybridCopyWith<SubstanceSourceMaterialHybrid>
      get copyWith;
}

abstract class $SubstanceSourceMaterialHybridCopyWith<$Res> {
  factory $SubstanceSourceMaterialHybridCopyWith(
          SubstanceSourceMaterialHybrid value,
          $Res Function(SubstanceSourceMaterialHybrid) then) =
      _$SubstanceSourceMaterialHybridCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String maternalOrganismId,
      String maternalOrganismName,
      String paternalOrganismId,
      String paternalOrganismName,
      CodeableConcept hybridType});

  $CodeableConceptCopyWith<$Res> get hybridType;
}

class _$SubstanceSourceMaterialHybridCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialHybridCopyWith<$Res> {
  _$SubstanceSourceMaterialHybridCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterialHybrid _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialHybrid) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object maternalOrganismId = freezed,
    Object maternalOrganismName = freezed,
    Object paternalOrganismId = freezed,
    Object paternalOrganismName = freezed,
    Object hybridType = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      maternalOrganismId: maternalOrganismId == freezed
          ? _value.maternalOrganismId
          : maternalOrganismId as String,
      maternalOrganismName: maternalOrganismName == freezed
          ? _value.maternalOrganismName
          : maternalOrganismName as String,
      paternalOrganismId: paternalOrganismId == freezed
          ? _value.paternalOrganismId
          : paternalOrganismId as String,
      paternalOrganismName: paternalOrganismName == freezed
          ? _value.paternalOrganismName
          : paternalOrganismName as String,
      hybridType: hybridType == freezed
          ? _value.hybridType
          : hybridType as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get hybridType {
    if (_value.hybridType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.hybridType, (value) {
      return _then(_value.copyWith(hybridType: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialHybridCopyWith<$Res>
    implements $SubstanceSourceMaterialHybridCopyWith<$Res> {
  factory _$SubstanceSourceMaterialHybridCopyWith(
          _SubstanceSourceMaterialHybrid value,
          $Res Function(_SubstanceSourceMaterialHybrid) then) =
      __$SubstanceSourceMaterialHybridCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String maternalOrganismId,
      String maternalOrganismName,
      String paternalOrganismId,
      String paternalOrganismName,
      CodeableConcept hybridType});

  @override
  $CodeableConceptCopyWith<$Res> get hybridType;
}

class __$SubstanceSourceMaterialHybridCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialHybridCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialHybridCopyWith<$Res> {
  __$SubstanceSourceMaterialHybridCopyWithImpl(
      _SubstanceSourceMaterialHybrid _value,
      $Res Function(_SubstanceSourceMaterialHybrid) _then)
      : super(_value, (v) => _then(v as _SubstanceSourceMaterialHybrid));

  @override
  _SubstanceSourceMaterialHybrid get _value =>
      super._value as _SubstanceSourceMaterialHybrid;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object maternalOrganismId = freezed,
    Object maternalOrganismName = freezed,
    Object paternalOrganismId = freezed,
    Object paternalOrganismName = freezed,
    Object hybridType = freezed,
  }) {
    return _then(_SubstanceSourceMaterialHybrid(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      maternalOrganismId: maternalOrganismId == freezed
          ? _value.maternalOrganismId
          : maternalOrganismId as String,
      maternalOrganismName: maternalOrganismName == freezed
          ? _value.maternalOrganismName
          : maternalOrganismName as String,
      paternalOrganismId: paternalOrganismId == freezed
          ? _value.paternalOrganismId
          : paternalOrganismId as String,
      paternalOrganismName: paternalOrganismName == freezed
          ? _value.paternalOrganismName
          : paternalOrganismName as String,
      hybridType: hybridType == freezed
          ? _value.hybridType
          : hybridType as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialHybrid
    implements _SubstanceSourceMaterialHybrid {
  const _$_SubstanceSourceMaterialHybrid(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.maternalOrganismId,
      this.maternalOrganismName,
      this.paternalOrganismId,
      this.paternalOrganismName,
      this.hybridType});

  factory _$_SubstanceSourceMaterialHybrid.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialHybridFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String maternalOrganismId;
  @override
  final String maternalOrganismName;
  @override
  final String paternalOrganismId;
  @override
  final String paternalOrganismName;
  @override
  final CodeableConcept hybridType;

  @override
  String toString() {
    return 'SubstanceSourceMaterialHybrid(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, maternalOrganismId: $maternalOrganismId, maternalOrganismName: $maternalOrganismName, paternalOrganismId: $paternalOrganismId, paternalOrganismName: $paternalOrganismName, hybridType: $hybridType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialHybrid &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.maternalOrganismId, maternalOrganismId) ||
                const DeepCollectionEquality()
                    .equals(other.maternalOrganismId, maternalOrganismId)) &&
            (identical(other.maternalOrganismName, maternalOrganismName) ||
                const DeepCollectionEquality().equals(
                    other.maternalOrganismName, maternalOrganismName)) &&
            (identical(other.paternalOrganismId, paternalOrganismId) ||
                const DeepCollectionEquality()
                    .equals(other.paternalOrganismId, paternalOrganismId)) &&
            (identical(other.paternalOrganismName, paternalOrganismName) ||
                const DeepCollectionEquality().equals(
                    other.paternalOrganismName, paternalOrganismName)) &&
            (identical(other.hybridType, hybridType) ||
                const DeepCollectionEquality()
                    .equals(other.hybridType, hybridType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(maternalOrganismId) ^
      const DeepCollectionEquality().hash(maternalOrganismName) ^
      const DeepCollectionEquality().hash(paternalOrganismId) ^
      const DeepCollectionEquality().hash(paternalOrganismName) ^
      const DeepCollectionEquality().hash(hybridType);

  @override
  _$SubstanceSourceMaterialHybridCopyWith<_SubstanceSourceMaterialHybrid>
      get copyWith => __$SubstanceSourceMaterialHybridCopyWithImpl<
          _SubstanceSourceMaterialHybrid>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialHybridToJson(this);
  }
}

abstract class _SubstanceSourceMaterialHybrid
    implements SubstanceSourceMaterialHybrid {
  const factory _SubstanceSourceMaterialHybrid(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String maternalOrganismId,
      String maternalOrganismName,
      String paternalOrganismId,
      String paternalOrganismName,
      CodeableConcept hybridType}) = _$_SubstanceSourceMaterialHybrid;

  factory _SubstanceSourceMaterialHybrid.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialHybrid.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get maternalOrganismId;
  @override
  String get maternalOrganismName;
  @override
  String get paternalOrganismId;
  @override
  String get paternalOrganismName;
  @override
  CodeableConcept get hybridType;
  @override
  _$SubstanceSourceMaterialHybridCopyWith<_SubstanceSourceMaterialHybrid>
      get copyWith;
}

SubstanceSourceMaterialOrganismGeneral
    _$SubstanceSourceMaterialOrganismGeneralFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialOrganismGeneral.fromJson(json);
}

class _$SubstanceSourceMaterialOrganismGeneralTearOff {
  const _$SubstanceSourceMaterialOrganismGeneralTearOff();

  _SubstanceSourceMaterialOrganismGeneral call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept kingdom,
      CodeableConcept phylum,
      @JsonKey(name: 'class') CodeableConcept class_,
      CodeableConcept order}) {
    return _SubstanceSourceMaterialOrganismGeneral(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      kingdom: kingdom,
      phylum: phylum,
      class_: class_,
      order: order,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialOrganismGeneral =
    _$SubstanceSourceMaterialOrganismGeneralTearOff();

mixin _$SubstanceSourceMaterialOrganismGeneral {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get kingdom;
  CodeableConcept get phylum;
  @JsonKey(name: 'class')
  CodeableConcept get class_;
  CodeableConcept get order;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialOrganismGeneralCopyWith<
      SubstanceSourceMaterialOrganismGeneral> get copyWith;
}

abstract class $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  factory $SubstanceSourceMaterialOrganismGeneralCopyWith(
          SubstanceSourceMaterialOrganismGeneral value,
          $Res Function(SubstanceSourceMaterialOrganismGeneral) then) =
      _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept kingdom,
      CodeableConcept phylum,
      @JsonKey(name: 'class') CodeableConcept class_,
      CodeableConcept order});

  $CodeableConceptCopyWith<$Res> get kingdom;
  $CodeableConceptCopyWith<$Res> get phylum;
  $CodeableConceptCopyWith<$Res> get class_;
  $CodeableConceptCopyWith<$Res> get order;
}

class _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterialOrganismGeneral _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialOrganismGeneral) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object kingdom = freezed,
    Object phylum = freezed,
    Object class_ = freezed,
    Object order = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      kingdom: kingdom == freezed ? _value.kingdom : kingdom as CodeableConcept,
      phylum: phylum == freezed ? _value.phylum : phylum as CodeableConcept,
      class_: class_ == freezed ? _value.class_ : class_ as CodeableConcept,
      order: order == freezed ? _value.order : order as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get kingdom {
    if (_value.kingdom == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.kingdom, (value) {
      return _then(_value.copyWith(kingdom: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get phylum {
    if (_value.phylum == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.phylum, (value) {
      return _then(_value.copyWith(phylum: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get class_ {
    if (_value.class_ == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.class_, (value) {
      return _then(_value.copyWith(class_: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get order {
    if (_value.order == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.order, (value) {
      return _then(_value.copyWith(order: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialOrganismGeneralCopyWith<$Res>
    implements $SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  factory _$SubstanceSourceMaterialOrganismGeneralCopyWith(
          _SubstanceSourceMaterialOrganismGeneral value,
          $Res Function(_SubstanceSourceMaterialOrganismGeneral) then) =
      __$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept kingdom,
      CodeableConcept phylum,
      @JsonKey(name: 'class') CodeableConcept class_,
      CodeableConcept order});

  @override
  $CodeableConceptCopyWith<$Res> get kingdom;
  @override
  $CodeableConceptCopyWith<$Res> get phylum;
  @override
  $CodeableConceptCopyWith<$Res> get class_;
  @override
  $CodeableConceptCopyWith<$Res> get order;
}

class __$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialOrganismGeneralCopyWith<$Res> {
  __$SubstanceSourceMaterialOrganismGeneralCopyWithImpl(
      _SubstanceSourceMaterialOrganismGeneral _value,
      $Res Function(_SubstanceSourceMaterialOrganismGeneral) _then)
      : super(
            _value, (v) => _then(v as _SubstanceSourceMaterialOrganismGeneral));

  @override
  _SubstanceSourceMaterialOrganismGeneral get _value =>
      super._value as _SubstanceSourceMaterialOrganismGeneral;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object kingdom = freezed,
    Object phylum = freezed,
    Object class_ = freezed,
    Object order = freezed,
  }) {
    return _then(_SubstanceSourceMaterialOrganismGeneral(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      kingdom: kingdom == freezed ? _value.kingdom : kingdom as CodeableConcept,
      phylum: phylum == freezed ? _value.phylum : phylum as CodeableConcept,
      class_: class_ == freezed ? _value.class_ : class_ as CodeableConcept,
      order: order == freezed ? _value.order : order as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialOrganismGeneral
    implements _SubstanceSourceMaterialOrganismGeneral {
  const _$_SubstanceSourceMaterialOrganismGeneral(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.kingdom,
      this.phylum,
      @JsonKey(name: 'class') this.class_,
      this.order});

  factory _$_SubstanceSourceMaterialOrganismGeneral.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialOrganismGeneralFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept kingdom;
  @override
  final CodeableConcept phylum;
  @override
  @JsonKey(name: 'class')
  final CodeableConcept class_;
  @override
  final CodeableConcept order;

  @override
  String toString() {
    return 'SubstanceSourceMaterialOrganismGeneral(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, kingdom: $kingdom, phylum: $phylum, class_: $class_, order: $order)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialOrganismGeneral &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.kingdom, kingdom) ||
                const DeepCollectionEquality()
                    .equals(other.kingdom, kingdom)) &&
            (identical(other.phylum, phylum) ||
                const DeepCollectionEquality().equals(other.phylum, phylum)) &&
            (identical(other.class_, class_) ||
                const DeepCollectionEquality().equals(other.class_, class_)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(kingdom) ^
      const DeepCollectionEquality().hash(phylum) ^
      const DeepCollectionEquality().hash(class_) ^
      const DeepCollectionEquality().hash(order);

  @override
  _$SubstanceSourceMaterialOrganismGeneralCopyWith<
          _SubstanceSourceMaterialOrganismGeneral>
      get copyWith => __$SubstanceSourceMaterialOrganismGeneralCopyWithImpl<
          _SubstanceSourceMaterialOrganismGeneral>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialOrganismGeneralToJson(this);
  }
}

abstract class _SubstanceSourceMaterialOrganismGeneral
    implements SubstanceSourceMaterialOrganismGeneral {
  const factory _SubstanceSourceMaterialOrganismGeneral(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept kingdom,
      CodeableConcept phylum,
      @JsonKey(name: 'class') CodeableConcept class_,
      CodeableConcept order}) = _$_SubstanceSourceMaterialOrganismGeneral;

  factory _SubstanceSourceMaterialOrganismGeneral.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialOrganismGeneral.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get kingdom;
  @override
  CodeableConcept get phylum;
  @override
  @JsonKey(name: 'class')
  CodeableConcept get class_;
  @override
  CodeableConcept get order;
  @override
  _$SubstanceSourceMaterialOrganismGeneralCopyWith<
      _SubstanceSourceMaterialOrganismGeneral> get copyWith;
}

SubstanceSourceMaterialPartDescription
    _$SubstanceSourceMaterialPartDescriptionFromJson(
        Map<String, dynamic> json) {
  return _SubstanceSourceMaterialPartDescription.fromJson(json);
}

class _$SubstanceSourceMaterialPartDescriptionTearOff {
  const _$SubstanceSourceMaterialPartDescriptionTearOff();

  _SubstanceSourceMaterialPartDescription call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept part,
      CodeableConcept partLocation}) {
    return _SubstanceSourceMaterialPartDescription(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      part: part,
      partLocation: partLocation,
    );
  }
}

// ignore: unused_element
const $SubstanceSourceMaterialPartDescription =
    _$SubstanceSourceMaterialPartDescriptionTearOff();

mixin _$SubstanceSourceMaterialPartDescription {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get part;
  CodeableConcept get partLocation;

  Map<String, dynamic> toJson();
  $SubstanceSourceMaterialPartDescriptionCopyWith<
      SubstanceSourceMaterialPartDescription> get copyWith;
}

abstract class $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  factory $SubstanceSourceMaterialPartDescriptionCopyWith(
          SubstanceSourceMaterialPartDescription value,
          $Res Function(SubstanceSourceMaterialPartDescription) then) =
      _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept part,
      CodeableConcept partLocation});

  $CodeableConceptCopyWith<$Res> get part;
  $CodeableConceptCopyWith<$Res> get partLocation;
}

class _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>
    implements $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  _$SubstanceSourceMaterialPartDescriptionCopyWithImpl(this._value, this._then);

  final SubstanceSourceMaterialPartDescription _value;
  // ignore: unused_field
  final $Res Function(SubstanceSourceMaterialPartDescription) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object part = freezed,
    Object partLocation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      part: part == freezed ? _value.part : part as CodeableConcept,
      partLocation: partLocation == freezed
          ? _value.partLocation
          : partLocation as CodeableConcept,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get part {
    if (_value.part == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.part, (value) {
      return _then(_value.copyWith(part: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get partLocation {
    if (_value.partLocation == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.partLocation, (value) {
      return _then(_value.copyWith(partLocation: value));
    });
  }
}

abstract class _$SubstanceSourceMaterialPartDescriptionCopyWith<$Res>
    implements $SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  factory _$SubstanceSourceMaterialPartDescriptionCopyWith(
          _SubstanceSourceMaterialPartDescription value,
          $Res Function(_SubstanceSourceMaterialPartDescription) then) =
      __$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept part,
      CodeableConcept partLocation});

  @override
  $CodeableConceptCopyWith<$Res> get part;
  @override
  $CodeableConceptCopyWith<$Res> get partLocation;
}

class __$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>
    extends _$SubstanceSourceMaterialPartDescriptionCopyWithImpl<$Res>
    implements _$SubstanceSourceMaterialPartDescriptionCopyWith<$Res> {
  __$SubstanceSourceMaterialPartDescriptionCopyWithImpl(
      _SubstanceSourceMaterialPartDescription _value,
      $Res Function(_SubstanceSourceMaterialPartDescription) _then)
      : super(
            _value, (v) => _then(v as _SubstanceSourceMaterialPartDescription));

  @override
  _SubstanceSourceMaterialPartDescription get _value =>
      super._value as _SubstanceSourceMaterialPartDescription;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object part = freezed,
    Object partLocation = freezed,
  }) {
    return _then(_SubstanceSourceMaterialPartDescription(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      part: part == freezed ? _value.part : part as CodeableConcept,
      partLocation: partLocation == freezed
          ? _value.partLocation
          : partLocation as CodeableConcept,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSourceMaterialPartDescription
    implements _SubstanceSourceMaterialPartDescription {
  const _$_SubstanceSourceMaterialPartDescription(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.part,
      this.partLocation});

  factory _$_SubstanceSourceMaterialPartDescription.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSourceMaterialPartDescriptionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept part;
  @override
  final CodeableConcept partLocation;

  @override
  String toString() {
    return 'SubstanceSourceMaterialPartDescription(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, part: $part, partLocation: $partLocation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSourceMaterialPartDescription &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.part, part) ||
                const DeepCollectionEquality().equals(other.part, part)) &&
            (identical(other.partLocation, partLocation) ||
                const DeepCollectionEquality()
                    .equals(other.partLocation, partLocation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(part) ^
      const DeepCollectionEquality().hash(partLocation);

  @override
  _$SubstanceSourceMaterialPartDescriptionCopyWith<
          _SubstanceSourceMaterialPartDescription>
      get copyWith => __$SubstanceSourceMaterialPartDescriptionCopyWithImpl<
          _SubstanceSourceMaterialPartDescription>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSourceMaterialPartDescriptionToJson(this);
  }
}

abstract class _SubstanceSourceMaterialPartDescription
    implements SubstanceSourceMaterialPartDescription {
  const factory _SubstanceSourceMaterialPartDescription(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept part,
          CodeableConcept partLocation}) =
      _$_SubstanceSourceMaterialPartDescription;

  factory _SubstanceSourceMaterialPartDescription.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSourceMaterialPartDescription.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get part;
  @override
  CodeableConcept get partLocation;
  @override
  _$SubstanceSourceMaterialPartDescriptionCopyWith<
      _SubstanceSourceMaterialPartDescription> get copyWith;
}

SubstanceSpecification _$SubstanceSpecificationFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecification.fromJson(json);
}

class _$SubstanceSpecificationTearOff {
  const _$SubstanceSpecificationTearOff();

  _SubstanceSpecification call(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept type,
      CodeableConcept status,
      CodeableConcept domain,
      String description,
      List<Reference> source,
      String comment,
      List<SubstanceSpecificationMoiety> moiety,
      List<SubstanceSpecificationProperty> property,
      Reference referenceInformation,
      SubstanceSpecificationStructure structure,
      List<SubstanceSpecificationCode> code,
      List<SubstanceSpecificationName> name,
      List<SubstanceSpecificationMolecularWeight> molecularWeight,
      List<SubstanceSpecificationRelationship> relationship,
      Reference nucleicAcid,
      Reference polymer,
      Reference protein,
      Reference sourceMaterial}) {
    return _SubstanceSpecification(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      type: type,
      status: status,
      domain: domain,
      description: description,
      source: source,
      comment: comment,
      moiety: moiety,
      property: property,
      referenceInformation: referenceInformation,
      structure: structure,
      code: code,
      name: name,
      molecularWeight: molecularWeight,
      relationship: relationship,
      nucleicAcid: nucleicAcid,
      polymer: polymer,
      protein: protein,
      sourceMaterial: sourceMaterial,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecification = _$SubstanceSpecificationTearOff();

mixin _$SubstanceSpecification {
  @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  CodeableConcept get type;
  CodeableConcept get status;
  CodeableConcept get domain;
  String get description;
  List<Reference> get source;
  String get comment;
  List<SubstanceSpecificationMoiety> get moiety;
  List<SubstanceSpecificationProperty> get property;
  Reference get referenceInformation;
  SubstanceSpecificationStructure get structure;
  List<SubstanceSpecificationCode> get code;
  List<SubstanceSpecificationName> get name;
  List<SubstanceSpecificationMolecularWeight> get molecularWeight;
  List<SubstanceSpecificationRelationship> get relationship;
  Reference get nucleicAcid;
  Reference get polymer;
  Reference get protein;
  Reference get sourceMaterial;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationCopyWith<SubstanceSpecification> get copyWith;
}

abstract class $SubstanceSpecificationCopyWith<$Res> {
  factory $SubstanceSpecificationCopyWith(SubstanceSpecification value,
          $Res Function(SubstanceSpecification) then) =
      _$SubstanceSpecificationCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceSpecification')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept type,
      CodeableConcept status,
      CodeableConcept domain,
      String description,
      List<Reference> source,
      String comment,
      List<SubstanceSpecificationMoiety> moiety,
      List<SubstanceSpecificationProperty> property,
      Reference referenceInformation,
      SubstanceSpecificationStructure structure,
      List<SubstanceSpecificationCode> code,
      List<SubstanceSpecificationName> name,
      List<SubstanceSpecificationMolecularWeight> molecularWeight,
      List<SubstanceSpecificationRelationship> relationship,
      Reference nucleicAcid,
      Reference polymer,
      Reference protein,
      Reference sourceMaterial});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get status;
  $CodeableConceptCopyWith<$Res> get domain;
  $ReferenceCopyWith<$Res> get referenceInformation;
  $SubstanceSpecificationStructureCopyWith<$Res> get structure;
  $ReferenceCopyWith<$Res> get nucleicAcid;
  $ReferenceCopyWith<$Res> get polymer;
  $ReferenceCopyWith<$Res> get protein;
  $ReferenceCopyWith<$Res> get sourceMaterial;
}

class _$SubstanceSpecificationCopyWithImpl<$Res>
    implements $SubstanceSpecificationCopyWith<$Res> {
  _$SubstanceSpecificationCopyWithImpl(this._value, this._then);

  final SubstanceSpecification _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecification) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object status = freezed,
    Object domain = freezed,
    Object description = freezed,
    Object source = freezed,
    Object comment = freezed,
    Object moiety = freezed,
    Object property = freezed,
    Object referenceInformation = freezed,
    Object structure = freezed,
    Object code = freezed,
    Object name = freezed,
    Object molecularWeight = freezed,
    Object relationship = freezed,
    Object nucleicAcid = freezed,
    Object polymer = freezed,
    Object protein = freezed,
    Object sourceMaterial = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      domain: domain == freezed ? _value.domain : domain as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      source: source == freezed ? _value.source : source as List<Reference>,
      comment: comment == freezed ? _value.comment : comment as String,
      moiety: moiety == freezed
          ? _value.moiety
          : moiety as List<SubstanceSpecificationMoiety>,
      property: property == freezed
          ? _value.property
          : property as List<SubstanceSpecificationProperty>,
      referenceInformation: referenceInformation == freezed
          ? _value.referenceInformation
          : referenceInformation as Reference,
      structure: structure == freezed
          ? _value.structure
          : structure as SubstanceSpecificationStructure,
      code: code == freezed
          ? _value.code
          : code as List<SubstanceSpecificationCode>,
      name: name == freezed
          ? _value.name
          : name as List<SubstanceSpecificationName>,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as List<SubstanceSpecificationMolecularWeight>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SubstanceSpecificationRelationship>,
      nucleicAcid: nucleicAcid == freezed
          ? _value.nucleicAcid
          : nucleicAcid as Reference,
      polymer: polymer == freezed ? _value.polymer : polymer as Reference,
      protein: protein == freezed ? _value.protein : protein as Reference,
      sourceMaterial: sourceMaterial == freezed
          ? _value.sourceMaterial
          : sourceMaterial as Reference,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get domain {
    if (_value.domain == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.domain, (value) {
      return _then(_value.copyWith(domain: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get referenceInformation {
    if (_value.referenceInformation == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.referenceInformation, (value) {
      return _then(_value.copyWith(referenceInformation: value));
    });
  }

  @override
  $SubstanceSpecificationStructureCopyWith<$Res> get structure {
    if (_value.structure == null) {
      return null;
    }
    return $SubstanceSpecificationStructureCopyWith<$Res>(_value.structure,
        (value) {
      return _then(_value.copyWith(structure: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get nucleicAcid {
    if (_value.nucleicAcid == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.nucleicAcid, (value) {
      return _then(_value.copyWith(nucleicAcid: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get polymer {
    if (_value.polymer == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.polymer, (value) {
      return _then(_value.copyWith(polymer: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get protein {
    if (_value.protein == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.protein, (value) {
      return _then(_value.copyWith(protein: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get sourceMaterial {
    if (_value.sourceMaterial == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.sourceMaterial, (value) {
      return _then(_value.copyWith(sourceMaterial: value));
    });
  }
}

abstract class _$SubstanceSpecificationCopyWith<$Res>
    implements $SubstanceSpecificationCopyWith<$Res> {
  factory _$SubstanceSpecificationCopyWith(_SubstanceSpecification value,
          $Res Function(_SubstanceSpecification) then) =
      __$SubstanceSpecificationCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'SubstanceSpecification')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept type,
      CodeableConcept status,
      CodeableConcept domain,
      String description,
      List<Reference> source,
      String comment,
      List<SubstanceSpecificationMoiety> moiety,
      List<SubstanceSpecificationProperty> property,
      Reference referenceInformation,
      SubstanceSpecificationStructure structure,
      List<SubstanceSpecificationCode> code,
      List<SubstanceSpecificationName> name,
      List<SubstanceSpecificationMolecularWeight> molecularWeight,
      List<SubstanceSpecificationRelationship> relationship,
      Reference nucleicAcid,
      Reference polymer,
      Reference protein,
      Reference sourceMaterial});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get status;
  @override
  $CodeableConceptCopyWith<$Res> get domain;
  @override
  $ReferenceCopyWith<$Res> get referenceInformation;
  @override
  $SubstanceSpecificationStructureCopyWith<$Res> get structure;
  @override
  $ReferenceCopyWith<$Res> get nucleicAcid;
  @override
  $ReferenceCopyWith<$Res> get polymer;
  @override
  $ReferenceCopyWith<$Res> get protein;
  @override
  $ReferenceCopyWith<$Res> get sourceMaterial;
}

class __$SubstanceSpecificationCopyWithImpl<$Res>
    extends _$SubstanceSpecificationCopyWithImpl<$Res>
    implements _$SubstanceSpecificationCopyWith<$Res> {
  __$SubstanceSpecificationCopyWithImpl(_SubstanceSpecification _value,
      $Res Function(_SubstanceSpecification) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecification));

  @override
  _SubstanceSpecification get _value => super._value as _SubstanceSpecification;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object type = freezed,
    Object status = freezed,
    Object domain = freezed,
    Object description = freezed,
    Object source = freezed,
    Object comment = freezed,
    Object moiety = freezed,
    Object property = freezed,
    Object referenceInformation = freezed,
    Object structure = freezed,
    Object code = freezed,
    Object name = freezed,
    Object molecularWeight = freezed,
    Object relationship = freezed,
    Object nucleicAcid = freezed,
    Object polymer = freezed,
    Object protein = freezed,
    Object sourceMaterial = freezed,
  }) {
    return _then(_SubstanceSpecification(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      domain: domain == freezed ? _value.domain : domain as CodeableConcept,
      description:
          description == freezed ? _value.description : description as String,
      source: source == freezed ? _value.source : source as List<Reference>,
      comment: comment == freezed ? _value.comment : comment as String,
      moiety: moiety == freezed
          ? _value.moiety
          : moiety as List<SubstanceSpecificationMoiety>,
      property: property == freezed
          ? _value.property
          : property as List<SubstanceSpecificationProperty>,
      referenceInformation: referenceInformation == freezed
          ? _value.referenceInformation
          : referenceInformation as Reference,
      structure: structure == freezed
          ? _value.structure
          : structure as SubstanceSpecificationStructure,
      code: code == freezed
          ? _value.code
          : code as List<SubstanceSpecificationCode>,
      name: name == freezed
          ? _value.name
          : name as List<SubstanceSpecificationName>,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as List<SubstanceSpecificationMolecularWeight>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SubstanceSpecificationRelationship>,
      nucleicAcid: nucleicAcid == freezed
          ? _value.nucleicAcid
          : nucleicAcid as Reference,
      polymer: polymer == freezed ? _value.polymer : polymer as Reference,
      protein: protein == freezed ? _value.protein : protein as Reference,
      sourceMaterial: sourceMaterial == freezed
          ? _value.sourceMaterial
          : sourceMaterial as Reference,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecification implements _SubstanceSpecification {
  const _$_SubstanceSpecification(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.type,
      this.status,
      this.domain,
      this.description,
      this.source,
      this.comment,
      this.moiety,
      this.property,
      this.referenceInformation,
      this.structure,
      this.code,
      this.name,
      this.molecularWeight,
      this.relationship,
      this.nucleicAcid,
      this.polymer,
      this.protein,
      this.sourceMaterial})
      : assert(resourceType != null);

  factory _$_SubstanceSpecification.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept status;
  @override
  final CodeableConcept domain;
  @override
  final String description;
  @override
  final List<Reference> source;
  @override
  final String comment;
  @override
  final List<SubstanceSpecificationMoiety> moiety;
  @override
  final List<SubstanceSpecificationProperty> property;
  @override
  final Reference referenceInformation;
  @override
  final SubstanceSpecificationStructure structure;
  @override
  final List<SubstanceSpecificationCode> code;
  @override
  final List<SubstanceSpecificationName> name;
  @override
  final List<SubstanceSpecificationMolecularWeight> molecularWeight;
  @override
  final List<SubstanceSpecificationRelationship> relationship;
  @override
  final Reference nucleicAcid;
  @override
  final Reference polymer;
  @override
  final Reference protein;
  @override
  final Reference sourceMaterial;

  @override
  String toString() {
    return 'SubstanceSpecification(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, status: $status, domain: $domain, description: $description, source: $source, comment: $comment, moiety: $moiety, property: $property, referenceInformation: $referenceInformation, structure: $structure, code: $code, name: $name, molecularWeight: $molecularWeight, relationship: $relationship, nucleicAcid: $nucleicAcid, polymer: $polymer, protein: $protein, sourceMaterial: $sourceMaterial)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecification &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.domain, domain) ||
                const DeepCollectionEquality().equals(other.domain, domain)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.moiety, moiety) ||
                const DeepCollectionEquality().equals(other.moiety, moiety)) &&
            (identical(other.property, property) ||
                const DeepCollectionEquality()
                    .equals(other.property, property)) &&
            (identical(other.referenceInformation, referenceInformation) ||
                const DeepCollectionEquality().equals(
                    other.referenceInformation, referenceInformation)) &&
            (identical(other.structure, structure) ||
                const DeepCollectionEquality()
                    .equals(other.structure, structure)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.molecularWeight, molecularWeight) ||
                const DeepCollectionEquality()
                    .equals(other.molecularWeight, molecularWeight)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.nucleicAcid, nucleicAcid) ||
                const DeepCollectionEquality()
                    .equals(other.nucleicAcid, nucleicAcid)) &&
            (identical(other.polymer, polymer) ||
                const DeepCollectionEquality()
                    .equals(other.polymer, polymer)) &&
            (identical(other.protein, protein) ||
                const DeepCollectionEquality().equals(other.protein, protein)) &&
            (identical(other.sourceMaterial, sourceMaterial) || const DeepCollectionEquality().equals(other.sourceMaterial, sourceMaterial)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(domain) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(moiety) ^
      const DeepCollectionEquality().hash(property) ^
      const DeepCollectionEquality().hash(referenceInformation) ^
      const DeepCollectionEquality().hash(structure) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(molecularWeight) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(nucleicAcid) ^
      const DeepCollectionEquality().hash(polymer) ^
      const DeepCollectionEquality().hash(protein) ^
      const DeepCollectionEquality().hash(sourceMaterial);

  @override
  _$SubstanceSpecificationCopyWith<_SubstanceSpecification> get copyWith =>
      __$SubstanceSpecificationCopyWithImpl<_SubstanceSpecification>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationToJson(this);
  }
}

abstract class _SubstanceSpecification implements SubstanceSpecification {
  const factory _SubstanceSpecification(
      {@required
      @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept type,
      CodeableConcept status,
      CodeableConcept domain,
      String description,
      List<Reference> source,
      String comment,
      List<SubstanceSpecificationMoiety> moiety,
      List<SubstanceSpecificationProperty> property,
      Reference referenceInformation,
      SubstanceSpecificationStructure structure,
      List<SubstanceSpecificationCode> code,
      List<SubstanceSpecificationName> name,
      List<SubstanceSpecificationMolecularWeight> molecularWeight,
      List<SubstanceSpecificationRelationship> relationship,
      Reference nucleicAcid,
      Reference polymer,
      Reference protein,
      Reference sourceMaterial}) = _$_SubstanceSpecification;

  factory _SubstanceSpecification.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecification.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'SubstanceSpecification')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get status;
  @override
  CodeableConcept get domain;
  @override
  String get description;
  @override
  List<Reference> get source;
  @override
  String get comment;
  @override
  List<SubstanceSpecificationMoiety> get moiety;
  @override
  List<SubstanceSpecificationProperty> get property;
  @override
  Reference get referenceInformation;
  @override
  SubstanceSpecificationStructure get structure;
  @override
  List<SubstanceSpecificationCode> get code;
  @override
  List<SubstanceSpecificationName> get name;
  @override
  List<SubstanceSpecificationMolecularWeight> get molecularWeight;
  @override
  List<SubstanceSpecificationRelationship> get relationship;
  @override
  Reference get nucleicAcid;
  @override
  Reference get polymer;
  @override
  Reference get protein;
  @override
  Reference get sourceMaterial;
  @override
  _$SubstanceSpecificationCopyWith<_SubstanceSpecification> get copyWith;
}

SubstanceSpecificationMoiety _$SubstanceSpecificationMoietyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationMoiety.fromJson(json);
}

class _$SubstanceSpecificationMoietyTearOff {
  const _$SubstanceSpecificationMoietyTearOff();

  _SubstanceSpecificationMoiety call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept role,
      Identifier identifier,
      String name,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      Quantity amountQuantity,
      String amountString}) {
    return _SubstanceSpecificationMoiety(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      role: role,
      identifier: identifier,
      name: name,
      stereochemistry: stereochemistry,
      opticalActivity: opticalActivity,
      molecularFormula: molecularFormula,
      amountQuantity: amountQuantity,
      amountString: amountString,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationMoiety = _$SubstanceSpecificationMoietyTearOff();

mixin _$SubstanceSpecificationMoiety {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get role;
  Identifier get identifier;
  String get name;
  CodeableConcept get stereochemistry;
  CodeableConcept get opticalActivity;
  String get molecularFormula;
  Quantity get amountQuantity;
  String get amountString;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationMoietyCopyWith<SubstanceSpecificationMoiety>
      get copyWith;
}

abstract class $SubstanceSpecificationMoietyCopyWith<$Res> {
  factory $SubstanceSpecificationMoietyCopyWith(
          SubstanceSpecificationMoiety value,
          $Res Function(SubstanceSpecificationMoiety) then) =
      _$SubstanceSpecificationMoietyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept role,
      Identifier identifier,
      String name,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      Quantity amountQuantity,
      String amountString});

  $CodeableConceptCopyWith<$Res> get role;
  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get stereochemistry;
  $CodeableConceptCopyWith<$Res> get opticalActivity;
  $QuantityCopyWith<$Res> get amountQuantity;
}

class _$SubstanceSpecificationMoietyCopyWithImpl<$Res>
    implements $SubstanceSpecificationMoietyCopyWith<$Res> {
  _$SubstanceSpecificationMoietyCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationMoiety _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationMoiety) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object role = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object stereochemistry = freezed,
    Object opticalActivity = freezed,
    Object molecularFormula = freezed,
    Object amountQuantity = freezed,
    Object amountString = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      role: role == freezed ? _value.role : role as CodeableConcept,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      stereochemistry: stereochemistry == freezed
          ? _value.stereochemistry
          : stereochemistry as CodeableConcept,
      opticalActivity: opticalActivity == freezed
          ? _value.opticalActivity
          : opticalActivity as CodeableConcept,
      molecularFormula: molecularFormula == freezed
          ? _value.molecularFormula
          : molecularFormula as String,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get role {
    if (_value.role == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry, (value) {
      return _then(_value.copyWith(stereochemistry: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity, (value) {
      return _then(_value.copyWith(opticalActivity: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.amountQuantity, (value) {
      return _then(_value.copyWith(amountQuantity: value));
    });
  }
}

abstract class _$SubstanceSpecificationMoietyCopyWith<$Res>
    implements $SubstanceSpecificationMoietyCopyWith<$Res> {
  factory _$SubstanceSpecificationMoietyCopyWith(
          _SubstanceSpecificationMoiety value,
          $Res Function(_SubstanceSpecificationMoiety) then) =
      __$SubstanceSpecificationMoietyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept role,
      Identifier identifier,
      String name,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      Quantity amountQuantity,
      String amountString});

  @override
  $CodeableConceptCopyWith<$Res> get role;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res> get opticalActivity;
  @override
  $QuantityCopyWith<$Res> get amountQuantity;
}

class __$SubstanceSpecificationMoietyCopyWithImpl<$Res>
    extends _$SubstanceSpecificationMoietyCopyWithImpl<$Res>
    implements _$SubstanceSpecificationMoietyCopyWith<$Res> {
  __$SubstanceSpecificationMoietyCopyWithImpl(
      _SubstanceSpecificationMoiety _value,
      $Res Function(_SubstanceSpecificationMoiety) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationMoiety));

  @override
  _SubstanceSpecificationMoiety get _value =>
      super._value as _SubstanceSpecificationMoiety;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object role = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object stereochemistry = freezed,
    Object opticalActivity = freezed,
    Object molecularFormula = freezed,
    Object amountQuantity = freezed,
    Object amountString = freezed,
  }) {
    return _then(_SubstanceSpecificationMoiety(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      role: role == freezed ? _value.role : role as CodeableConcept,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      stereochemistry: stereochemistry == freezed
          ? _value.stereochemistry
          : stereochemistry as CodeableConcept,
      opticalActivity: opticalActivity == freezed
          ? _value.opticalActivity
          : opticalActivity as CodeableConcept,
      molecularFormula: molecularFormula == freezed
          ? _value.molecularFormula
          : molecularFormula as String,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationMoiety implements _SubstanceSpecificationMoiety {
  const _$_SubstanceSpecificationMoiety(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.role,
      this.identifier,
      this.name,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      this.amountQuantity,
      this.amountString});

  factory _$_SubstanceSpecificationMoiety.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationMoietyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept role;
  @override
  final Identifier identifier;
  @override
  final String name;
  @override
  final CodeableConcept stereochemistry;
  @override
  final CodeableConcept opticalActivity;
  @override
  final String molecularFormula;
  @override
  final Quantity amountQuantity;
  @override
  final String amountString;

  @override
  String toString() {
    return 'SubstanceSpecificationMoiety(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, role: $role, identifier: $identifier, name: $name, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, amountQuantity: $amountQuantity, amountString: $amountString)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationMoiety &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.stereochemistry, stereochemistry) ||
                const DeepCollectionEquality()
                    .equals(other.stereochemistry, stereochemistry)) &&
            (identical(other.opticalActivity, opticalActivity) ||
                const DeepCollectionEquality()
                    .equals(other.opticalActivity, opticalActivity)) &&
            (identical(other.molecularFormula, molecularFormula) ||
                const DeepCollectionEquality()
                    .equals(other.molecularFormula, molecularFormula)) &&
            (identical(other.amountQuantity, amountQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.amountQuantity, amountQuantity)) &&
            (identical(other.amountString, amountString) ||
                const DeepCollectionEquality()
                    .equals(other.amountString, amountString)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(stereochemistry) ^
      const DeepCollectionEquality().hash(opticalActivity) ^
      const DeepCollectionEquality().hash(molecularFormula) ^
      const DeepCollectionEquality().hash(amountQuantity) ^
      const DeepCollectionEquality().hash(amountString);

  @override
  _$SubstanceSpecificationMoietyCopyWith<_SubstanceSpecificationMoiety>
      get copyWith => __$SubstanceSpecificationMoietyCopyWithImpl<
          _SubstanceSpecificationMoiety>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationMoietyToJson(this);
  }
}

abstract class _SubstanceSpecificationMoiety
    implements SubstanceSpecificationMoiety {
  const factory _SubstanceSpecificationMoiety(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept role,
      Identifier identifier,
      String name,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      Quantity amountQuantity,
      String amountString}) = _$_SubstanceSpecificationMoiety;

  factory _SubstanceSpecificationMoiety.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationMoiety.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get role;
  @override
  Identifier get identifier;
  @override
  String get name;
  @override
  CodeableConcept get stereochemistry;
  @override
  CodeableConcept get opticalActivity;
  @override
  String get molecularFormula;
  @override
  Quantity get amountQuantity;
  @override
  String get amountString;
  @override
  _$SubstanceSpecificationMoietyCopyWith<_SubstanceSpecificationMoiety>
      get copyWith;
}

SubstanceSpecificationProperty _$SubstanceSpecificationPropertyFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationProperty.fromJson(json);
}

class _$SubstanceSpecificationPropertyTearOff {
  const _$SubstanceSpecificationPropertyTearOff();

  _SubstanceSpecificationProperty call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      CodeableConcept code,
      String parameters,
      Reference definingSubstanceReference,
      CodeableConcept definingSubstanceCodeableConcept,
      Quantity amountQuantity,
      String amountString}) {
    return _SubstanceSpecificationProperty(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      category: category,
      code: code,
      parameters: parameters,
      definingSubstanceReference: definingSubstanceReference,
      definingSubstanceCodeableConcept: definingSubstanceCodeableConcept,
      amountQuantity: amountQuantity,
      amountString: amountString,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationProperty =
    _$SubstanceSpecificationPropertyTearOff();

mixin _$SubstanceSpecificationProperty {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get category;
  CodeableConcept get code;
  String get parameters;
  Reference get definingSubstanceReference;
  CodeableConcept get definingSubstanceCodeableConcept;
  Quantity get amountQuantity;
  String get amountString;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationPropertyCopyWith<SubstanceSpecificationProperty>
      get copyWith;
}

abstract class $SubstanceSpecificationPropertyCopyWith<$Res> {
  factory $SubstanceSpecificationPropertyCopyWith(
          SubstanceSpecificationProperty value,
          $Res Function(SubstanceSpecificationProperty) then) =
      _$SubstanceSpecificationPropertyCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      CodeableConcept code,
      String parameters,
      Reference definingSubstanceReference,
      CodeableConcept definingSubstanceCodeableConcept,
      Quantity amountQuantity,
      String amountString});

  $CodeableConceptCopyWith<$Res> get category;
  $CodeableConceptCopyWith<$Res> get code;
  $ReferenceCopyWith<$Res> get definingSubstanceReference;
  $CodeableConceptCopyWith<$Res> get definingSubstanceCodeableConcept;
  $QuantityCopyWith<$Res> get amountQuantity;
}

class _$SubstanceSpecificationPropertyCopyWithImpl<$Res>
    implements $SubstanceSpecificationPropertyCopyWith<$Res> {
  _$SubstanceSpecificationPropertyCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationProperty _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationProperty) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object code = freezed,
    Object parameters = freezed,
    Object definingSubstanceReference = freezed,
    Object definingSubstanceCodeableConcept = freezed,
    Object amountQuantity = freezed,
    Object amountString = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category:
          category == freezed ? _value.category : category as CodeableConcept,
      code: code == freezed ? _value.code : code as CodeableConcept,
      parameters:
          parameters == freezed ? _value.parameters : parameters as String,
      definingSubstanceReference: definingSubstanceReference == freezed
          ? _value.definingSubstanceReference
          : definingSubstanceReference as Reference,
      definingSubstanceCodeableConcept:
          definingSubstanceCodeableConcept == freezed
              ? _value.definingSubstanceCodeableConcept
              : definingSubstanceCodeableConcept as CodeableConcept,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get category {
    if (_value.category == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get definingSubstanceReference {
    if (_value.definingSubstanceReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.definingSubstanceReference, (value) {
      return _then(_value.copyWith(definingSubstanceReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get definingSubstanceCodeableConcept {
    if (_value.definingSubstanceCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(
        _value.definingSubstanceCodeableConcept, (value) {
      return _then(_value.copyWith(definingSubstanceCodeableConcept: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.amountQuantity, (value) {
      return _then(_value.copyWith(amountQuantity: value));
    });
  }
}

abstract class _$SubstanceSpecificationPropertyCopyWith<$Res>
    implements $SubstanceSpecificationPropertyCopyWith<$Res> {
  factory _$SubstanceSpecificationPropertyCopyWith(
          _SubstanceSpecificationProperty value,
          $Res Function(_SubstanceSpecificationProperty) then) =
      __$SubstanceSpecificationPropertyCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      CodeableConcept code,
      String parameters,
      Reference definingSubstanceReference,
      CodeableConcept definingSubstanceCodeableConcept,
      Quantity amountQuantity,
      String amountString});

  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ReferenceCopyWith<$Res> get definingSubstanceReference;
  @override
  $CodeableConceptCopyWith<$Res> get definingSubstanceCodeableConcept;
  @override
  $QuantityCopyWith<$Res> get amountQuantity;
}

class __$SubstanceSpecificationPropertyCopyWithImpl<$Res>
    extends _$SubstanceSpecificationPropertyCopyWithImpl<$Res>
    implements _$SubstanceSpecificationPropertyCopyWith<$Res> {
  __$SubstanceSpecificationPropertyCopyWithImpl(
      _SubstanceSpecificationProperty _value,
      $Res Function(_SubstanceSpecificationProperty) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationProperty));

  @override
  _SubstanceSpecificationProperty get _value =>
      super._value as _SubstanceSpecificationProperty;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object category = freezed,
    Object code = freezed,
    Object parameters = freezed,
    Object definingSubstanceReference = freezed,
    Object definingSubstanceCodeableConcept = freezed,
    Object amountQuantity = freezed,
    Object amountString = freezed,
  }) {
    return _then(_SubstanceSpecificationProperty(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      category:
          category == freezed ? _value.category : category as CodeableConcept,
      code: code == freezed ? _value.code : code as CodeableConcept,
      parameters:
          parameters == freezed ? _value.parameters : parameters as String,
      definingSubstanceReference: definingSubstanceReference == freezed
          ? _value.definingSubstanceReference
          : definingSubstanceReference as Reference,
      definingSubstanceCodeableConcept:
          definingSubstanceCodeableConcept == freezed
              ? _value.definingSubstanceCodeableConcept
              : definingSubstanceCodeableConcept as CodeableConcept,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationProperty
    implements _SubstanceSpecificationProperty {
  const _$_SubstanceSpecificationProperty(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.category,
      this.code,
      this.parameters,
      this.definingSubstanceReference,
      this.definingSubstanceCodeableConcept,
      this.amountQuantity,
      this.amountString});

  factory _$_SubstanceSpecificationProperty.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationPropertyFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept category;
  @override
  final CodeableConcept code;
  @override
  final String parameters;
  @override
  final Reference definingSubstanceReference;
  @override
  final CodeableConcept definingSubstanceCodeableConcept;
  @override
  final Quantity amountQuantity;
  @override
  final String amountString;

  @override
  String toString() {
    return 'SubstanceSpecificationProperty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, code: $code, parameters: $parameters, definingSubstanceReference: $definingSubstanceReference, definingSubstanceCodeableConcept: $definingSubstanceCodeableConcept, amountQuantity: $amountQuantity, amountString: $amountString)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationProperty &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.definingSubstanceReference,
                    definingSubstanceReference) ||
                const DeepCollectionEquality().equals(
                    other.definingSubstanceReference,
                    definingSubstanceReference)) &&
            (identical(other.definingSubstanceCodeableConcept,
                    definingSubstanceCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.definingSubstanceCodeableConcept,
                    definingSubstanceCodeableConcept)) &&
            (identical(other.amountQuantity, amountQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.amountQuantity, amountQuantity)) &&
            (identical(other.amountString, amountString) ||
                const DeepCollectionEquality()
                    .equals(other.amountString, amountString)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(definingSubstanceReference) ^
      const DeepCollectionEquality().hash(definingSubstanceCodeableConcept) ^
      const DeepCollectionEquality().hash(amountQuantity) ^
      const DeepCollectionEquality().hash(amountString);

  @override
  _$SubstanceSpecificationPropertyCopyWith<_SubstanceSpecificationProperty>
      get copyWith => __$SubstanceSpecificationPropertyCopyWithImpl<
          _SubstanceSpecificationProperty>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationPropertyToJson(this);
  }
}

abstract class _SubstanceSpecificationProperty
    implements SubstanceSpecificationProperty {
  const factory _SubstanceSpecificationProperty(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept category,
      CodeableConcept code,
      String parameters,
      Reference definingSubstanceReference,
      CodeableConcept definingSubstanceCodeableConcept,
      Quantity amountQuantity,
      String amountString}) = _$_SubstanceSpecificationProperty;

  factory _SubstanceSpecificationProperty.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationProperty.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get category;
  @override
  CodeableConcept get code;
  @override
  String get parameters;
  @override
  Reference get definingSubstanceReference;
  @override
  CodeableConcept get definingSubstanceCodeableConcept;
  @override
  Quantity get amountQuantity;
  @override
  String get amountString;
  @override
  _$SubstanceSpecificationPropertyCopyWith<_SubstanceSpecificationProperty>
      get copyWith;
}

SubstanceSpecificationStructure _$SubstanceSpecificationStructureFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationStructure.fromJson(json);
}

class _$SubstanceSpecificationStructureTearOff {
  const _$SubstanceSpecificationStructureTearOff();

  _SubstanceSpecificationStructure call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      String molecularFormulaByMoiety,
      List<SubstanceSpecificationIsotope> isotope,
      SubstanceSpecificationMolecularWeight molecularWeight,
      List<Reference> source,
      List<SubstanceSpecificationRepresentation> representation}) {
    return _SubstanceSpecificationStructure(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      stereochemistry: stereochemistry,
      opticalActivity: opticalActivity,
      molecularFormula: molecularFormula,
      molecularFormulaByMoiety: molecularFormulaByMoiety,
      isotope: isotope,
      molecularWeight: molecularWeight,
      source: source,
      representation: representation,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationStructure =
    _$SubstanceSpecificationStructureTearOff();

mixin _$SubstanceSpecificationStructure {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get stereochemistry;
  CodeableConcept get opticalActivity;
  String get molecularFormula;
  String get molecularFormulaByMoiety;
  List<SubstanceSpecificationIsotope> get isotope;
  SubstanceSpecificationMolecularWeight get molecularWeight;
  List<Reference> get source;
  List<SubstanceSpecificationRepresentation> get representation;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationStructureCopyWith<SubstanceSpecificationStructure>
      get copyWith;
}

abstract class $SubstanceSpecificationStructureCopyWith<$Res> {
  factory $SubstanceSpecificationStructureCopyWith(
          SubstanceSpecificationStructure value,
          $Res Function(SubstanceSpecificationStructure) then) =
      _$SubstanceSpecificationStructureCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      String molecularFormulaByMoiety,
      List<SubstanceSpecificationIsotope> isotope,
      SubstanceSpecificationMolecularWeight molecularWeight,
      List<Reference> source,
      List<SubstanceSpecificationRepresentation> representation});

  $CodeableConceptCopyWith<$Res> get stereochemistry;
  $CodeableConceptCopyWith<$Res> get opticalActivity;
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight;
}

class _$SubstanceSpecificationStructureCopyWithImpl<$Res>
    implements $SubstanceSpecificationStructureCopyWith<$Res> {
  _$SubstanceSpecificationStructureCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationStructure _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationStructure) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object stereochemistry = freezed,
    Object opticalActivity = freezed,
    Object molecularFormula = freezed,
    Object molecularFormulaByMoiety = freezed,
    Object isotope = freezed,
    Object molecularWeight = freezed,
    Object source = freezed,
    Object representation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      stereochemistry: stereochemistry == freezed
          ? _value.stereochemistry
          : stereochemistry as CodeableConcept,
      opticalActivity: opticalActivity == freezed
          ? _value.opticalActivity
          : opticalActivity as CodeableConcept,
      molecularFormula: molecularFormula == freezed
          ? _value.molecularFormula
          : molecularFormula as String,
      molecularFormulaByMoiety: molecularFormulaByMoiety == freezed
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety as String,
      isotope: isotope == freezed
          ? _value.isotope
          : isotope as List<SubstanceSpecificationIsotope>,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as SubstanceSpecificationMolecularWeight,
      source: source == freezed ? _value.source : source as List<Reference>,
      representation: representation == freezed
          ? _value.representation
          : representation as List<SubstanceSpecificationRepresentation>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get stereochemistry {
    if (_value.stereochemistry == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.stereochemistry, (value) {
      return _then(_value.copyWith(stereochemistry: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get opticalActivity {
    if (_value.opticalActivity == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.opticalActivity, (value) {
      return _then(_value.copyWith(opticalActivity: value));
    });
  }

  @override
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight {
    if (_value.molecularWeight == null) {
      return null;
    }
    return $SubstanceSpecificationMolecularWeightCopyWith<$Res>(
        _value.molecularWeight, (value) {
      return _then(_value.copyWith(molecularWeight: value));
    });
  }
}

abstract class _$SubstanceSpecificationStructureCopyWith<$Res>
    implements $SubstanceSpecificationStructureCopyWith<$Res> {
  factory _$SubstanceSpecificationStructureCopyWith(
          _SubstanceSpecificationStructure value,
          $Res Function(_SubstanceSpecificationStructure) then) =
      __$SubstanceSpecificationStructureCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept stereochemistry,
      CodeableConcept opticalActivity,
      String molecularFormula,
      String molecularFormulaByMoiety,
      List<SubstanceSpecificationIsotope> isotope,
      SubstanceSpecificationMolecularWeight molecularWeight,
      List<Reference> source,
      List<SubstanceSpecificationRepresentation> representation});

  @override
  $CodeableConceptCopyWith<$Res> get stereochemistry;
  @override
  $CodeableConceptCopyWith<$Res> get opticalActivity;
  @override
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight;
}

class __$SubstanceSpecificationStructureCopyWithImpl<$Res>
    extends _$SubstanceSpecificationStructureCopyWithImpl<$Res>
    implements _$SubstanceSpecificationStructureCopyWith<$Res> {
  __$SubstanceSpecificationStructureCopyWithImpl(
      _SubstanceSpecificationStructure _value,
      $Res Function(_SubstanceSpecificationStructure) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationStructure));

  @override
  _SubstanceSpecificationStructure get _value =>
      super._value as _SubstanceSpecificationStructure;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object stereochemistry = freezed,
    Object opticalActivity = freezed,
    Object molecularFormula = freezed,
    Object molecularFormulaByMoiety = freezed,
    Object isotope = freezed,
    Object molecularWeight = freezed,
    Object source = freezed,
    Object representation = freezed,
  }) {
    return _then(_SubstanceSpecificationStructure(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      stereochemistry: stereochemistry == freezed
          ? _value.stereochemistry
          : stereochemistry as CodeableConcept,
      opticalActivity: opticalActivity == freezed
          ? _value.opticalActivity
          : opticalActivity as CodeableConcept,
      molecularFormula: molecularFormula == freezed
          ? _value.molecularFormula
          : molecularFormula as String,
      molecularFormulaByMoiety: molecularFormulaByMoiety == freezed
          ? _value.molecularFormulaByMoiety
          : molecularFormulaByMoiety as String,
      isotope: isotope == freezed
          ? _value.isotope
          : isotope as List<SubstanceSpecificationIsotope>,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as SubstanceSpecificationMolecularWeight,
      source: source == freezed ? _value.source : source as List<Reference>,
      representation: representation == freezed
          ? _value.representation
          : representation as List<SubstanceSpecificationRepresentation>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationStructure
    implements _SubstanceSpecificationStructure {
  const _$_SubstanceSpecificationStructure(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.stereochemistry,
      this.opticalActivity,
      this.molecularFormula,
      this.molecularFormulaByMoiety,
      this.isotope,
      this.molecularWeight,
      this.source,
      this.representation});

  factory _$_SubstanceSpecificationStructure.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationStructureFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept stereochemistry;
  @override
  final CodeableConcept opticalActivity;
  @override
  final String molecularFormula;
  @override
  final String molecularFormulaByMoiety;
  @override
  final List<SubstanceSpecificationIsotope> isotope;
  @override
  final SubstanceSpecificationMolecularWeight molecularWeight;
  @override
  final List<Reference> source;
  @override
  final List<SubstanceSpecificationRepresentation> representation;

  @override
  String toString() {
    return 'SubstanceSpecificationStructure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, stereochemistry: $stereochemistry, opticalActivity: $opticalActivity, molecularFormula: $molecularFormula, molecularFormulaByMoiety: $molecularFormulaByMoiety, isotope: $isotope, molecularWeight: $molecularWeight, source: $source, representation: $representation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationStructure &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.stereochemistry, stereochemistry) ||
                const DeepCollectionEquality()
                    .equals(other.stereochemistry, stereochemistry)) &&
            (identical(other.opticalActivity, opticalActivity) ||
                const DeepCollectionEquality()
                    .equals(other.opticalActivity, opticalActivity)) &&
            (identical(other.molecularFormula, molecularFormula) ||
                const DeepCollectionEquality()
                    .equals(other.molecularFormula, molecularFormula)) &&
            (identical(
                    other.molecularFormulaByMoiety, molecularFormulaByMoiety) ||
                const DeepCollectionEquality().equals(
                    other.molecularFormulaByMoiety,
                    molecularFormulaByMoiety)) &&
            (identical(other.isotope, isotope) ||
                const DeepCollectionEquality()
                    .equals(other.isotope, isotope)) &&
            (identical(other.molecularWeight, molecularWeight) ||
                const DeepCollectionEquality()
                    .equals(other.molecularWeight, molecularWeight)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.representation, representation) ||
                const DeepCollectionEquality()
                    .equals(other.representation, representation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(stereochemistry) ^
      const DeepCollectionEquality().hash(opticalActivity) ^
      const DeepCollectionEquality().hash(molecularFormula) ^
      const DeepCollectionEquality().hash(molecularFormulaByMoiety) ^
      const DeepCollectionEquality().hash(isotope) ^
      const DeepCollectionEquality().hash(molecularWeight) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(representation);

  @override
  _$SubstanceSpecificationStructureCopyWith<_SubstanceSpecificationStructure>
      get copyWith => __$SubstanceSpecificationStructureCopyWithImpl<
          _SubstanceSpecificationStructure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationStructureToJson(this);
  }
}

abstract class _SubstanceSpecificationStructure
    implements SubstanceSpecificationStructure {
  const factory _SubstanceSpecificationStructure(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          CodeableConcept stereochemistry,
          CodeableConcept opticalActivity,
          String molecularFormula,
          String molecularFormulaByMoiety,
          List<SubstanceSpecificationIsotope> isotope,
          SubstanceSpecificationMolecularWeight molecularWeight,
          List<Reference> source,
          List<SubstanceSpecificationRepresentation> representation}) =
      _$_SubstanceSpecificationStructure;

  factory _SubstanceSpecificationStructure.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationStructure.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get stereochemistry;
  @override
  CodeableConcept get opticalActivity;
  @override
  String get molecularFormula;
  @override
  String get molecularFormulaByMoiety;
  @override
  List<SubstanceSpecificationIsotope> get isotope;
  @override
  SubstanceSpecificationMolecularWeight get molecularWeight;
  @override
  List<Reference> get source;
  @override
  List<SubstanceSpecificationRepresentation> get representation;
  @override
  _$SubstanceSpecificationStructureCopyWith<_SubstanceSpecificationStructure>
      get copyWith;
}

SubstanceSpecificationIsotope _$SubstanceSpecificationIsotopeFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationIsotope.fromJson(json);
}

class _$SubstanceSpecificationIsotopeTearOff {
  const _$SubstanceSpecificationIsotopeTearOff();

  _SubstanceSpecificationIsotope call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept name,
      CodeableConcept substitution,
      Quantity halfLife,
      SubstanceSpecificationMolecularWeight molecularWeight}) {
    return _SubstanceSpecificationIsotope(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      name: name,
      substitution: substitution,
      halfLife: halfLife,
      molecularWeight: molecularWeight,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationIsotope = _$SubstanceSpecificationIsotopeTearOff();

mixin _$SubstanceSpecificationIsotope {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  CodeableConcept get name;
  CodeableConcept get substitution;
  Quantity get halfLife;
  SubstanceSpecificationMolecularWeight get molecularWeight;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationIsotopeCopyWith<SubstanceSpecificationIsotope>
      get copyWith;
}

abstract class $SubstanceSpecificationIsotopeCopyWith<$Res> {
  factory $SubstanceSpecificationIsotopeCopyWith(
          SubstanceSpecificationIsotope value,
          $Res Function(SubstanceSpecificationIsotope) then) =
      _$SubstanceSpecificationIsotopeCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept name,
      CodeableConcept substitution,
      Quantity halfLife,
      SubstanceSpecificationMolecularWeight molecularWeight});

  $IdentifierCopyWith<$Res> get identifier;
  $CodeableConceptCopyWith<$Res> get name;
  $CodeableConceptCopyWith<$Res> get substitution;
  $QuantityCopyWith<$Res> get halfLife;
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight;
}

class _$SubstanceSpecificationIsotopeCopyWithImpl<$Res>
    implements $SubstanceSpecificationIsotopeCopyWith<$Res> {
  _$SubstanceSpecificationIsotopeCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationIsotope _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationIsotope) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object substitution = freezed,
    Object halfLife = freezed,
    Object molecularWeight = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as CodeableConcept,
      substitution: substitution == freezed
          ? _value.substitution
          : substitution as CodeableConcept,
      halfLife: halfLife == freezed ? _value.halfLife : halfLife as Quantity,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as SubstanceSpecificationMolecularWeight,
    ));
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get name {
    if (_value.name == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.name, (value) {
      return _then(_value.copyWith(name: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get substitution {
    if (_value.substitution == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.substitution, (value) {
      return _then(_value.copyWith(substitution: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get halfLife {
    if (_value.halfLife == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.halfLife, (value) {
      return _then(_value.copyWith(halfLife: value));
    });
  }

  @override
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight {
    if (_value.molecularWeight == null) {
      return null;
    }
    return $SubstanceSpecificationMolecularWeightCopyWith<$Res>(
        _value.molecularWeight, (value) {
      return _then(_value.copyWith(molecularWeight: value));
    });
  }
}

abstract class _$SubstanceSpecificationIsotopeCopyWith<$Res>
    implements $SubstanceSpecificationIsotopeCopyWith<$Res> {
  factory _$SubstanceSpecificationIsotopeCopyWith(
          _SubstanceSpecificationIsotope value,
          $Res Function(_SubstanceSpecificationIsotope) then) =
      __$SubstanceSpecificationIsotopeCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      CodeableConcept name,
      CodeableConcept substitution,
      Quantity halfLife,
      SubstanceSpecificationMolecularWeight molecularWeight});

  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $CodeableConceptCopyWith<$Res> get name;
  @override
  $CodeableConceptCopyWith<$Res> get substitution;
  @override
  $QuantityCopyWith<$Res> get halfLife;
  @override
  $SubstanceSpecificationMolecularWeightCopyWith<$Res> get molecularWeight;
}

class __$SubstanceSpecificationIsotopeCopyWithImpl<$Res>
    extends _$SubstanceSpecificationIsotopeCopyWithImpl<$Res>
    implements _$SubstanceSpecificationIsotopeCopyWith<$Res> {
  __$SubstanceSpecificationIsotopeCopyWithImpl(
      _SubstanceSpecificationIsotope _value,
      $Res Function(_SubstanceSpecificationIsotope) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationIsotope));

  @override
  _SubstanceSpecificationIsotope get _value =>
      super._value as _SubstanceSpecificationIsotope;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object substitution = freezed,
    Object halfLife = freezed,
    Object molecularWeight = freezed,
  }) {
    return _then(_SubstanceSpecificationIsotope(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as CodeableConcept,
      substitution: substitution == freezed
          ? _value.substitution
          : substitution as CodeableConcept,
      halfLife: halfLife == freezed ? _value.halfLife : halfLife as Quantity,
      molecularWeight: molecularWeight == freezed
          ? _value.molecularWeight
          : molecularWeight as SubstanceSpecificationMolecularWeight,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationIsotope
    implements _SubstanceSpecificationIsotope {
  const _$_SubstanceSpecificationIsotope(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.identifier,
      this.name,
      this.substitution,
      this.halfLife,
      this.molecularWeight});

  factory _$_SubstanceSpecificationIsotope.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationIsotopeFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  final CodeableConcept name;
  @override
  final CodeableConcept substitution;
  @override
  final Quantity halfLife;
  @override
  final SubstanceSpecificationMolecularWeight molecularWeight;

  @override
  String toString() {
    return 'SubstanceSpecificationIsotope(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, substitution: $substitution, halfLife: $halfLife, molecularWeight: $molecularWeight)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationIsotope &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.substitution, substitution) ||
                const DeepCollectionEquality()
                    .equals(other.substitution, substitution)) &&
            (identical(other.halfLife, halfLife) ||
                const DeepCollectionEquality()
                    .equals(other.halfLife, halfLife)) &&
            (identical(other.molecularWeight, molecularWeight) ||
                const DeepCollectionEquality()
                    .equals(other.molecularWeight, molecularWeight)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(substitution) ^
      const DeepCollectionEquality().hash(halfLife) ^
      const DeepCollectionEquality().hash(molecularWeight);

  @override
  _$SubstanceSpecificationIsotopeCopyWith<_SubstanceSpecificationIsotope>
      get copyWith => __$SubstanceSpecificationIsotopeCopyWithImpl<
          _SubstanceSpecificationIsotope>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationIsotopeToJson(this);
  }
}

abstract class _SubstanceSpecificationIsotope
    implements SubstanceSpecificationIsotope {
  const factory _SubstanceSpecificationIsotope(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Identifier identifier,
          CodeableConcept name,
          CodeableConcept substitution,
          Quantity halfLife,
          SubstanceSpecificationMolecularWeight molecularWeight}) =
      _$_SubstanceSpecificationIsotope;

  factory _SubstanceSpecificationIsotope.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationIsotope.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  CodeableConcept get name;
  @override
  CodeableConcept get substitution;
  @override
  Quantity get halfLife;
  @override
  SubstanceSpecificationMolecularWeight get molecularWeight;
  @override
  _$SubstanceSpecificationIsotopeCopyWith<_SubstanceSpecificationIsotope>
      get copyWith;
}

SubstanceSpecificationMolecularWeight
    _$SubstanceSpecificationMolecularWeightFromJson(Map<String, dynamic> json) {
  return _SubstanceSpecificationMolecularWeight.fromJson(json);
}

class _$SubstanceSpecificationMolecularWeightTearOff {
  const _$SubstanceSpecificationMolecularWeightTearOff();

  _SubstanceSpecificationMolecularWeight call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept method,
      CodeableConcept type,
      Quantity amount}) {
    return _SubstanceSpecificationMolecularWeight(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      method: method,
      type: type,
      amount: amount,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationMolecularWeight =
    _$SubstanceSpecificationMolecularWeightTearOff();

mixin _$SubstanceSpecificationMolecularWeight {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get method;
  CodeableConcept get type;
  Quantity get amount;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationMolecularWeightCopyWith<
      SubstanceSpecificationMolecularWeight> get copyWith;
}

abstract class $SubstanceSpecificationMolecularWeightCopyWith<$Res> {
  factory $SubstanceSpecificationMolecularWeightCopyWith(
          SubstanceSpecificationMolecularWeight value,
          $Res Function(SubstanceSpecificationMolecularWeight) then) =
      _$SubstanceSpecificationMolecularWeightCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept method,
      CodeableConcept type,
      Quantity amount});

  $CodeableConceptCopyWith<$Res> get method;
  $CodeableConceptCopyWith<$Res> get type;
  $QuantityCopyWith<$Res> get amount;
}

class _$SubstanceSpecificationMolecularWeightCopyWithImpl<$Res>
    implements $SubstanceSpecificationMolecularWeightCopyWith<$Res> {
  _$SubstanceSpecificationMolecularWeightCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationMolecularWeight _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationMolecularWeight) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object method = freezed,
    Object type = freezed,
    Object amount = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      method: method == freezed ? _value.method : method as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      amount: amount == freezed ? _value.amount : amount as Quantity,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get method {
    if (_value.method == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.method, (value) {
      return _then(_value.copyWith(method: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get amount {
    if (_value.amount == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value));
    });
  }
}

abstract class _$SubstanceSpecificationMolecularWeightCopyWith<$Res>
    implements $SubstanceSpecificationMolecularWeightCopyWith<$Res> {
  factory _$SubstanceSpecificationMolecularWeightCopyWith(
          _SubstanceSpecificationMolecularWeight value,
          $Res Function(_SubstanceSpecificationMolecularWeight) then) =
      __$SubstanceSpecificationMolecularWeightCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept method,
      CodeableConcept type,
      Quantity amount});

  @override
  $CodeableConceptCopyWith<$Res> get method;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $QuantityCopyWith<$Res> get amount;
}

class __$SubstanceSpecificationMolecularWeightCopyWithImpl<$Res>
    extends _$SubstanceSpecificationMolecularWeightCopyWithImpl<$Res>
    implements _$SubstanceSpecificationMolecularWeightCopyWith<$Res> {
  __$SubstanceSpecificationMolecularWeightCopyWithImpl(
      _SubstanceSpecificationMolecularWeight _value,
      $Res Function(_SubstanceSpecificationMolecularWeight) _then)
      : super(
            _value, (v) => _then(v as _SubstanceSpecificationMolecularWeight));

  @override
  _SubstanceSpecificationMolecularWeight get _value =>
      super._value as _SubstanceSpecificationMolecularWeight;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object method = freezed,
    Object type = freezed,
    Object amount = freezed,
  }) {
    return _then(_SubstanceSpecificationMolecularWeight(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      method: method == freezed ? _value.method : method as CodeableConcept,
      type: type == freezed ? _value.type : type as CodeableConcept,
      amount: amount == freezed ? _value.amount : amount as Quantity,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationMolecularWeight
    implements _SubstanceSpecificationMolecularWeight {
  const _$_SubstanceSpecificationMolecularWeight(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.method,
      this.type,
      this.amount});

  factory _$_SubstanceSpecificationMolecularWeight.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationMolecularWeightFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept method;
  @override
  final CodeableConcept type;
  @override
  final Quantity amount;

  @override
  String toString() {
    return 'SubstanceSpecificationMolecularWeight(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, method: $method, type: $type, amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationMolecularWeight &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount);

  @override
  _$SubstanceSpecificationMolecularWeightCopyWith<
          _SubstanceSpecificationMolecularWeight>
      get copyWith => __$SubstanceSpecificationMolecularWeightCopyWithImpl<
          _SubstanceSpecificationMolecularWeight>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationMolecularWeightToJson(this);
  }
}

abstract class _SubstanceSpecificationMolecularWeight
    implements SubstanceSpecificationMolecularWeight {
  const factory _SubstanceSpecificationMolecularWeight(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept method,
      CodeableConcept type,
      Quantity amount}) = _$_SubstanceSpecificationMolecularWeight;

  factory _SubstanceSpecificationMolecularWeight.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSpecificationMolecularWeight.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get method;
  @override
  CodeableConcept get type;
  @override
  Quantity get amount;
  @override
  _$SubstanceSpecificationMolecularWeightCopyWith<
      _SubstanceSpecificationMolecularWeight> get copyWith;
}

SubstanceSpecificationRepresentation
    _$SubstanceSpecificationRepresentationFromJson(Map<String, dynamic> json) {
  return _SubstanceSpecificationRepresentation.fromJson(json);
}

class _$SubstanceSpecificationRepresentationTearOff {
  const _$SubstanceSpecificationRepresentationTearOff();

  _SubstanceSpecificationRepresentation call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment}) {
    return _SubstanceSpecificationRepresentation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      representation: representation,
      attachment: attachment,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationRepresentation =
    _$SubstanceSpecificationRepresentationTearOff();

mixin _$SubstanceSpecificationRepresentation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get type;
  String get representation;
  Attachment get attachment;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationRepresentationCopyWith<
      SubstanceSpecificationRepresentation> get copyWith;
}

abstract class $SubstanceSpecificationRepresentationCopyWith<$Res> {
  factory $SubstanceSpecificationRepresentationCopyWith(
          SubstanceSpecificationRepresentation value,
          $Res Function(SubstanceSpecificationRepresentation) then) =
      _$SubstanceSpecificationRepresentationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment});

  $CodeableConceptCopyWith<$Res> get type;
  $AttachmentCopyWith<$Res> get attachment;
}

class _$SubstanceSpecificationRepresentationCopyWithImpl<$Res>
    implements $SubstanceSpecificationRepresentationCopyWith<$Res> {
  _$SubstanceSpecificationRepresentationCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationRepresentation _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationRepresentation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object representation = freezed,
    Object attachment = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      representation: representation == freezed
          ? _value.representation
          : representation as String,
      attachment:
          attachment == freezed ? _value.attachment : attachment as Attachment,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $AttachmentCopyWith<$Res> get attachment {
    if (_value.attachment == null) {
      return null;
    }
    return $AttachmentCopyWith<$Res>(_value.attachment, (value) {
      return _then(_value.copyWith(attachment: value));
    });
  }
}

abstract class _$SubstanceSpecificationRepresentationCopyWith<$Res>
    implements $SubstanceSpecificationRepresentationCopyWith<$Res> {
  factory _$SubstanceSpecificationRepresentationCopyWith(
          _SubstanceSpecificationRepresentation value,
          $Res Function(_SubstanceSpecificationRepresentation) then) =
      __$SubstanceSpecificationRepresentationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $AttachmentCopyWith<$Res> get attachment;
}

class __$SubstanceSpecificationRepresentationCopyWithImpl<$Res>
    extends _$SubstanceSpecificationRepresentationCopyWithImpl<$Res>
    implements _$SubstanceSpecificationRepresentationCopyWith<$Res> {
  __$SubstanceSpecificationRepresentationCopyWithImpl(
      _SubstanceSpecificationRepresentation _value,
      $Res Function(_SubstanceSpecificationRepresentation) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationRepresentation));

  @override
  _SubstanceSpecificationRepresentation get _value =>
      super._value as _SubstanceSpecificationRepresentation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object representation = freezed,
    Object attachment = freezed,
  }) {
    return _then(_SubstanceSpecificationRepresentation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as CodeableConcept,
      representation: representation == freezed
          ? _value.representation
          : representation as String,
      attachment:
          attachment == freezed ? _value.attachment : attachment as Attachment,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationRepresentation
    implements _SubstanceSpecificationRepresentation {
  const _$_SubstanceSpecificationRepresentation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.representation,
      this.attachment});

  factory _$_SubstanceSpecificationRepresentation.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationRepresentationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept type;
  @override
  final String representation;
  @override
  final Attachment attachment;

  @override
  String toString() {
    return 'SubstanceSpecificationRepresentation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, representation: $representation, attachment: $attachment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationRepresentation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.representation, representation) ||
                const DeepCollectionEquality()
                    .equals(other.representation, representation)) &&
            (identical(other.attachment, attachment) ||
                const DeepCollectionEquality()
                    .equals(other.attachment, attachment)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(representation) ^
      const DeepCollectionEquality().hash(attachment);

  @override
  _$SubstanceSpecificationRepresentationCopyWith<
          _SubstanceSpecificationRepresentation>
      get copyWith => __$SubstanceSpecificationRepresentationCopyWithImpl<
          _SubstanceSpecificationRepresentation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationRepresentationToJson(this);
  }
}

abstract class _SubstanceSpecificationRepresentation
    implements SubstanceSpecificationRepresentation {
  const factory _SubstanceSpecificationRepresentation(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept type,
      String representation,
      Attachment attachment}) = _$_SubstanceSpecificationRepresentation;

  factory _SubstanceSpecificationRepresentation.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSpecificationRepresentation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get type;
  @override
  String get representation;
  @override
  Attachment get attachment;
  @override
  _$SubstanceSpecificationRepresentationCopyWith<
      _SubstanceSpecificationRepresentation> get copyWith;
}

SubstanceSpecificationCode _$SubstanceSpecificationCodeFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationCode.fromJson(json);
}

class _$SubstanceSpecificationCodeTearOff {
  const _$SubstanceSpecificationCodeTearOff();

  _SubstanceSpecificationCode call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      CodeableConcept status,
      FhirDateTime statusDate,
      String comment,
      List<Reference> source}) {
    return _SubstanceSpecificationCode(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      code: code,
      status: status,
      statusDate: statusDate,
      comment: comment,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationCode = _$SubstanceSpecificationCodeTearOff();

mixin _$SubstanceSpecificationCode {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get code;
  CodeableConcept get status;
  FhirDateTime get statusDate;
  String get comment;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationCodeCopyWith<SubstanceSpecificationCode> get copyWith;
}

abstract class $SubstanceSpecificationCodeCopyWith<$Res> {
  factory $SubstanceSpecificationCodeCopyWith(SubstanceSpecificationCode value,
          $Res Function(SubstanceSpecificationCode) then) =
      _$SubstanceSpecificationCodeCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      CodeableConcept status,
      FhirDateTime statusDate,
      String comment,
      List<Reference> source});

  $CodeableConceptCopyWith<$Res> get code;
  $CodeableConceptCopyWith<$Res> get status;
}

class _$SubstanceSpecificationCodeCopyWithImpl<$Res>
    implements $SubstanceSpecificationCodeCopyWith<$Res> {
  _$SubstanceSpecificationCodeCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationCode _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationCode) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object status = freezed,
    Object statusDate = freezed,
    Object comment = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      statusDate: statusDate == freezed
          ? _value.statusDate
          : statusDate as FhirDateTime,
      comment: comment == freezed ? _value.comment : comment as String,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get code {
    if (_value.code == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

abstract class _$SubstanceSpecificationCodeCopyWith<$Res>
    implements $SubstanceSpecificationCodeCopyWith<$Res> {
  factory _$SubstanceSpecificationCodeCopyWith(
          _SubstanceSpecificationCode value,
          $Res Function(_SubstanceSpecificationCode) then) =
      __$SubstanceSpecificationCodeCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      CodeableConcept status,
      FhirDateTime statusDate,
      String comment,
      List<Reference> source});

  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $CodeableConceptCopyWith<$Res> get status;
}

class __$SubstanceSpecificationCodeCopyWithImpl<$Res>
    extends _$SubstanceSpecificationCodeCopyWithImpl<$Res>
    implements _$SubstanceSpecificationCodeCopyWith<$Res> {
  __$SubstanceSpecificationCodeCopyWithImpl(_SubstanceSpecificationCode _value,
      $Res Function(_SubstanceSpecificationCode) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationCode));

  @override
  _SubstanceSpecificationCode get _value =>
      super._value as _SubstanceSpecificationCode;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object code = freezed,
    Object status = freezed,
    Object statusDate = freezed,
    Object comment = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceSpecificationCode(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      code: code == freezed ? _value.code : code as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      statusDate: statusDate == freezed
          ? _value.statusDate
          : statusDate as FhirDateTime,
      comment: comment == freezed ? _value.comment : comment as String,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationCode implements _SubstanceSpecificationCode {
  const _$_SubstanceSpecificationCode(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.code,
      this.status,
      this.statusDate,
      this.comment,
      this.source});

  factory _$_SubstanceSpecificationCode.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationCodeFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept code;
  @override
  final CodeableConcept status;
  @override
  final FhirDateTime statusDate;
  @override
  final String comment;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceSpecificationCode(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, code: $code, status: $status, statusDate: $statusDate, comment: $comment, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationCode &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.statusDate, statusDate) ||
                const DeepCollectionEquality()
                    .equals(other.statusDate, statusDate)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(statusDate) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceSpecificationCodeCopyWith<_SubstanceSpecificationCode>
      get copyWith => __$SubstanceSpecificationCodeCopyWithImpl<
          _SubstanceSpecificationCode>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationCodeToJson(this);
  }
}

abstract class _SubstanceSpecificationCode
    implements SubstanceSpecificationCode {
  const factory _SubstanceSpecificationCode(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept code,
      CodeableConcept status,
      FhirDateTime statusDate,
      String comment,
      List<Reference> source}) = _$_SubstanceSpecificationCode;

  factory _SubstanceSpecificationCode.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationCode.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get code;
  @override
  CodeableConcept get status;
  @override
  FhirDateTime get statusDate;
  @override
  String get comment;
  @override
  List<Reference> get source;
  @override
  _$SubstanceSpecificationCodeCopyWith<_SubstanceSpecificationCode>
      get copyWith;
}

SubstanceSpecificationName _$SubstanceSpecificationNameFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationName.fromJson(json);
}

class _$SubstanceSpecificationNameTearOff {
  const _$SubstanceSpecificationNameTearOff();

  _SubstanceSpecificationName call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      CodeableConcept status,
      Boolean preferred,
      List<CodeableConcept> language,
      List<CodeableConcept> domain,
      List<CodeableConcept> jurisdiction,
      List<SubstanceSpecificationName> synonym,
      List<SubstanceSpecificationName> translation,
      List<SubstanceSpecificationOfficial> official,
      List<Reference> source}) {
    return _SubstanceSpecificationName(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      type: type,
      status: status,
      preferred: preferred,
      language: language,
      domain: domain,
      jurisdiction: jurisdiction,
      synonym: synonym,
      translation: translation,
      official: official,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationName = _$SubstanceSpecificationNameTearOff();

mixin _$SubstanceSpecificationName {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  CodeableConcept get type;
  CodeableConcept get status;
  Boolean get preferred;
  List<CodeableConcept> get language;
  List<CodeableConcept> get domain;
  List<CodeableConcept> get jurisdiction;
  List<SubstanceSpecificationName> get synonym;
  List<SubstanceSpecificationName> get translation;
  List<SubstanceSpecificationOfficial> get official;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationNameCopyWith<SubstanceSpecificationName> get copyWith;
}

abstract class $SubstanceSpecificationNameCopyWith<$Res> {
  factory $SubstanceSpecificationNameCopyWith(SubstanceSpecificationName value,
          $Res Function(SubstanceSpecificationName) then) =
      _$SubstanceSpecificationNameCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      CodeableConcept status,
      Boolean preferred,
      List<CodeableConcept> language,
      List<CodeableConcept> domain,
      List<CodeableConcept> jurisdiction,
      List<SubstanceSpecificationName> synonym,
      List<SubstanceSpecificationName> translation,
      List<SubstanceSpecificationOfficial> official,
      List<Reference> source});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get status;
}

class _$SubstanceSpecificationNameCopyWithImpl<$Res>
    implements $SubstanceSpecificationNameCopyWith<$Res> {
  _$SubstanceSpecificationNameCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationName _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationName) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
    Object status = freezed,
    Object preferred = freezed,
    Object language = freezed,
    Object domain = freezed,
    Object jurisdiction = freezed,
    Object synonym = freezed,
    Object translation = freezed,
    Object official = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      preferred: preferred == freezed ? _value.preferred : preferred as Boolean,
      language: language == freezed
          ? _value.language
          : language as List<CodeableConcept>,
      domain:
          domain == freezed ? _value.domain : domain as List<CodeableConcept>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      synonym: synonym == freezed
          ? _value.synonym
          : synonym as List<SubstanceSpecificationName>,
      translation: translation == freezed
          ? _value.translation
          : translation as List<SubstanceSpecificationName>,
      official: official == freezed
          ? _value.official
          : official as List<SubstanceSpecificationOfficial>,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

abstract class _$SubstanceSpecificationNameCopyWith<$Res>
    implements $SubstanceSpecificationNameCopyWith<$Res> {
  factory _$SubstanceSpecificationNameCopyWith(
          _SubstanceSpecificationName value,
          $Res Function(_SubstanceSpecificationName) then) =
      __$SubstanceSpecificationNameCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      CodeableConcept status,
      Boolean preferred,
      List<CodeableConcept> language,
      List<CodeableConcept> domain,
      List<CodeableConcept> jurisdiction,
      List<SubstanceSpecificationName> synonym,
      List<SubstanceSpecificationName> translation,
      List<SubstanceSpecificationOfficial> official,
      List<Reference> source});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get status;
}

class __$SubstanceSpecificationNameCopyWithImpl<$Res>
    extends _$SubstanceSpecificationNameCopyWithImpl<$Res>
    implements _$SubstanceSpecificationNameCopyWith<$Res> {
  __$SubstanceSpecificationNameCopyWithImpl(_SubstanceSpecificationName _value,
      $Res Function(_SubstanceSpecificationName) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationName));

  @override
  _SubstanceSpecificationName get _value =>
      super._value as _SubstanceSpecificationName;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object type = freezed,
    Object status = freezed,
    Object preferred = freezed,
    Object language = freezed,
    Object domain = freezed,
    Object jurisdiction = freezed,
    Object synonym = freezed,
    Object translation = freezed,
    Object official = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceSpecificationName(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      type: type == freezed ? _value.type : type as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      preferred: preferred == freezed ? _value.preferred : preferred as Boolean,
      language: language == freezed
          ? _value.language
          : language as List<CodeableConcept>,
      domain:
          domain == freezed ? _value.domain : domain as List<CodeableConcept>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      synonym: synonym == freezed
          ? _value.synonym
          : synonym as List<SubstanceSpecificationName>,
      translation: translation == freezed
          ? _value.translation
          : translation as List<SubstanceSpecificationName>,
      official: official == freezed
          ? _value.official
          : official as List<SubstanceSpecificationOfficial>,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationName implements _SubstanceSpecificationName {
  const _$_SubstanceSpecificationName(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.type,
      this.status,
      this.preferred,
      this.language,
      this.domain,
      this.jurisdiction,
      this.synonym,
      this.translation,
      this.official,
      this.source});

  factory _$_SubstanceSpecificationName.fromJson(Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationNameFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final CodeableConcept type;
  @override
  final CodeableConcept status;
  @override
  final Boolean preferred;
  @override
  final List<CodeableConcept> language;
  @override
  final List<CodeableConcept> domain;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final List<SubstanceSpecificationName> synonym;
  @override
  final List<SubstanceSpecificationName> translation;
  @override
  final List<SubstanceSpecificationOfficial> official;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceSpecificationName(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, type: $type, status: $status, preferred: $preferred, language: $language, domain: $domain, jurisdiction: $jurisdiction, synonym: $synonym, translation: $translation, official: $official, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationName &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.preferred, preferred) ||
                const DeepCollectionEquality()
                    .equals(other.preferred, preferred)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.domain, domain) ||
                const DeepCollectionEquality().equals(other.domain, domain)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.synonym, synonym) ||
                const DeepCollectionEquality()
                    .equals(other.synonym, synonym)) &&
            (identical(other.translation, translation) ||
                const DeepCollectionEquality()
                    .equals(other.translation, translation)) &&
            (identical(other.official, official) ||
                const DeepCollectionEquality()
                    .equals(other.official, official)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(preferred) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(domain) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(synonym) ^
      const DeepCollectionEquality().hash(translation) ^
      const DeepCollectionEquality().hash(official) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceSpecificationNameCopyWith<_SubstanceSpecificationName>
      get copyWith => __$SubstanceSpecificationNameCopyWithImpl<
          _SubstanceSpecificationName>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationNameToJson(this);
  }
}

abstract class _SubstanceSpecificationName
    implements SubstanceSpecificationName {
  const factory _SubstanceSpecificationName(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      CodeableConcept type,
      CodeableConcept status,
      Boolean preferred,
      List<CodeableConcept> language,
      List<CodeableConcept> domain,
      List<CodeableConcept> jurisdiction,
      List<SubstanceSpecificationName> synonym,
      List<SubstanceSpecificationName> translation,
      List<SubstanceSpecificationOfficial> official,
      List<Reference> source}) = _$_SubstanceSpecificationName;

  factory _SubstanceSpecificationName.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationName.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  CodeableConcept get type;
  @override
  CodeableConcept get status;
  @override
  Boolean get preferred;
  @override
  List<CodeableConcept> get language;
  @override
  List<CodeableConcept> get domain;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  List<SubstanceSpecificationName> get synonym;
  @override
  List<SubstanceSpecificationName> get translation;
  @override
  List<SubstanceSpecificationOfficial> get official;
  @override
  List<Reference> get source;
  @override
  _$SubstanceSpecificationNameCopyWith<_SubstanceSpecificationName>
      get copyWith;
}

SubstanceSpecificationOfficial _$SubstanceSpecificationOfficialFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationOfficial.fromJson(json);
}

class _$SubstanceSpecificationOfficialTearOff {
  const _$SubstanceSpecificationOfficialTearOff();

  _SubstanceSpecificationOfficial call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authority,
      CodeableConcept status,
      FhirDateTime date}) {
    return _SubstanceSpecificationOfficial(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      authority: authority,
      status: status,
      date: date,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationOfficial =
    _$SubstanceSpecificationOfficialTearOff();

mixin _$SubstanceSpecificationOfficial {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  CodeableConcept get authority;
  CodeableConcept get status;
  FhirDateTime get date;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationOfficialCopyWith<SubstanceSpecificationOfficial>
      get copyWith;
}

abstract class $SubstanceSpecificationOfficialCopyWith<$Res> {
  factory $SubstanceSpecificationOfficialCopyWith(
          SubstanceSpecificationOfficial value,
          $Res Function(SubstanceSpecificationOfficial) then) =
      _$SubstanceSpecificationOfficialCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authority,
      CodeableConcept status,
      FhirDateTime date});

  $CodeableConceptCopyWith<$Res> get authority;
  $CodeableConceptCopyWith<$Res> get status;
}

class _$SubstanceSpecificationOfficialCopyWithImpl<$Res>
    implements $SubstanceSpecificationOfficialCopyWith<$Res> {
  _$SubstanceSpecificationOfficialCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationOfficial _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationOfficial) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object authority = freezed,
    Object status = freezed,
    Object date = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      authority: authority == freezed
          ? _value.authority
          : authority as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      date: date == freezed ? _value.date : date as FhirDateTime,
    ));
  }

  @override
  $CodeableConceptCopyWith<$Res> get authority {
    if (_value.authority == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.authority, (value) {
      return _then(_value.copyWith(authority: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get status {
    if (_value.status == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

abstract class _$SubstanceSpecificationOfficialCopyWith<$Res>
    implements $SubstanceSpecificationOfficialCopyWith<$Res> {
  factory _$SubstanceSpecificationOfficialCopyWith(
          _SubstanceSpecificationOfficial value,
          $Res Function(_SubstanceSpecificationOfficial) then) =
      __$SubstanceSpecificationOfficialCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authority,
      CodeableConcept status,
      FhirDateTime date});

  @override
  $CodeableConceptCopyWith<$Res> get authority;
  @override
  $CodeableConceptCopyWith<$Res> get status;
}

class __$SubstanceSpecificationOfficialCopyWithImpl<$Res>
    extends _$SubstanceSpecificationOfficialCopyWithImpl<$Res>
    implements _$SubstanceSpecificationOfficialCopyWith<$Res> {
  __$SubstanceSpecificationOfficialCopyWithImpl(
      _SubstanceSpecificationOfficial _value,
      $Res Function(_SubstanceSpecificationOfficial) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationOfficial));

  @override
  _SubstanceSpecificationOfficial get _value =>
      super._value as _SubstanceSpecificationOfficial;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object authority = freezed,
    Object status = freezed,
    Object date = freezed,
  }) {
    return _then(_SubstanceSpecificationOfficial(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      authority: authority == freezed
          ? _value.authority
          : authority as CodeableConcept,
      status: status == freezed ? _value.status : status as CodeableConcept,
      date: date == freezed ? _value.date : date as FhirDateTime,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationOfficial
    implements _SubstanceSpecificationOfficial {
  const _$_SubstanceSpecificationOfficial(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.authority,
      this.status,
      this.date});

  factory _$_SubstanceSpecificationOfficial.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationOfficialFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final CodeableConcept authority;
  @override
  final CodeableConcept status;
  @override
  final FhirDateTime date;

  @override
  String toString() {
    return 'SubstanceSpecificationOfficial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, authority: $authority, status: $status, date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationOfficial &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.authority, authority) ||
                const DeepCollectionEquality()
                    .equals(other.authority, authority)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(authority) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(date);

  @override
  _$SubstanceSpecificationOfficialCopyWith<_SubstanceSpecificationOfficial>
      get copyWith => __$SubstanceSpecificationOfficialCopyWithImpl<
          _SubstanceSpecificationOfficial>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationOfficialToJson(this);
  }
}

abstract class _SubstanceSpecificationOfficial
    implements SubstanceSpecificationOfficial {
  const factory _SubstanceSpecificationOfficial(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      CodeableConcept authority,
      CodeableConcept status,
      FhirDateTime date}) = _$_SubstanceSpecificationOfficial;

  factory _SubstanceSpecificationOfficial.fromJson(Map<String, dynamic> json) =
      _$_SubstanceSpecificationOfficial.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  CodeableConcept get authority;
  @override
  CodeableConcept get status;
  @override
  FhirDateTime get date;
  @override
  _$SubstanceSpecificationOfficialCopyWith<_SubstanceSpecificationOfficial>
      get copyWith;
}

SubstanceSpecificationRelationship _$SubstanceSpecificationRelationshipFromJson(
    Map<String, dynamic> json) {
  return _SubstanceSpecificationRelationship.fromJson(json);
}

class _$SubstanceSpecificationRelationshipTearOff {
  const _$SubstanceSpecificationRelationshipTearOff();

  _SubstanceSpecificationRelationship call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference substanceReference,
      CodeableConcept substanceCodeableConcept,
      CodeableConcept relationship,
      Boolean isDefining,
      Quantity amountQuantity,
      Range amountRange,
      Ratio amountRatio,
      String amountString,
      Ratio amountRatioLowLimit,
      CodeableConcept amountType,
      List<Reference> source}) {
    return _SubstanceSpecificationRelationship(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      substanceReference: substanceReference,
      substanceCodeableConcept: substanceCodeableConcept,
      relationship: relationship,
      isDefining: isDefining,
      amountQuantity: amountQuantity,
      amountRange: amountRange,
      amountRatio: amountRatio,
      amountString: amountString,
      amountRatioLowLimit: amountRatioLowLimit,
      amountType: amountType,
      source: source,
    );
  }
}

// ignore: unused_element
const $SubstanceSpecificationRelationship =
    _$SubstanceSpecificationRelationshipTearOff();

mixin _$SubstanceSpecificationRelationship {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Reference get substanceReference;
  CodeableConcept get substanceCodeableConcept;
  CodeableConcept get relationship;
  Boolean get isDefining;
  Quantity get amountQuantity;
  Range get amountRange;
  Ratio get amountRatio;
  String get amountString;
  Ratio get amountRatioLowLimit;
  CodeableConcept get amountType;
  List<Reference> get source;

  Map<String, dynamic> toJson();
  $SubstanceSpecificationRelationshipCopyWith<
      SubstanceSpecificationRelationship> get copyWith;
}

abstract class $SubstanceSpecificationRelationshipCopyWith<$Res> {
  factory $SubstanceSpecificationRelationshipCopyWith(
          SubstanceSpecificationRelationship value,
          $Res Function(SubstanceSpecificationRelationship) then) =
      _$SubstanceSpecificationRelationshipCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference substanceReference,
      CodeableConcept substanceCodeableConcept,
      CodeableConcept relationship,
      Boolean isDefining,
      Quantity amountQuantity,
      Range amountRange,
      Ratio amountRatio,
      String amountString,
      Ratio amountRatioLowLimit,
      CodeableConcept amountType,
      List<Reference> source});

  $ReferenceCopyWith<$Res> get substanceReference;
  $CodeableConceptCopyWith<$Res> get substanceCodeableConcept;
  $CodeableConceptCopyWith<$Res> get relationship;
  $QuantityCopyWith<$Res> get amountQuantity;
  $RangeCopyWith<$Res> get amountRange;
  $RatioCopyWith<$Res> get amountRatio;
  $RatioCopyWith<$Res> get amountRatioLowLimit;
  $CodeableConceptCopyWith<$Res> get amountType;
}

class _$SubstanceSpecificationRelationshipCopyWithImpl<$Res>
    implements $SubstanceSpecificationRelationshipCopyWith<$Res> {
  _$SubstanceSpecificationRelationshipCopyWithImpl(this._value, this._then);

  final SubstanceSpecificationRelationship _value;
  // ignore: unused_field
  final $Res Function(SubstanceSpecificationRelationship) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substanceReference = freezed,
    Object substanceCodeableConcept = freezed,
    Object relationship = freezed,
    Object isDefining = freezed,
    Object amountQuantity = freezed,
    Object amountRange = freezed,
    Object amountRatio = freezed,
    Object amountString = freezed,
    Object amountRatioLowLimit = freezed,
    Object amountType = freezed,
    Object source = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substanceReference: substanceReference == freezed
          ? _value.substanceReference
          : substanceReference as Reference,
      substanceCodeableConcept: substanceCodeableConcept == freezed
          ? _value.substanceCodeableConcept
          : substanceCodeableConcept as CodeableConcept,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as CodeableConcept,
      isDefining:
          isDefining == freezed ? _value.isDefining : isDefining as Boolean,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountRange:
          amountRange == freezed ? _value.amountRange : amountRange as Range,
      amountRatio:
          amountRatio == freezed ? _value.amountRatio : amountRatio as Ratio,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
      amountRatioLowLimit: amountRatioLowLimit == freezed
          ? _value.amountRatioLowLimit
          : amountRatioLowLimit as Ratio,
      amountType: amountType == freezed
          ? _value.amountType
          : amountType as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }

  @override
  $ReferenceCopyWith<$Res> get substanceReference {
    if (_value.substanceReference == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.substanceReference, (value) {
      return _then(_value.copyWith(substanceReference: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get substanceCodeableConcept {
    if (_value.substanceCodeableConcept == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.substanceCodeableConcept,
        (value) {
      return _then(_value.copyWith(substanceCodeableConcept: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get relationship {
    if (_value.relationship == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.relationship, (value) {
      return _then(_value.copyWith(relationship: value));
    });
  }

  @override
  $QuantityCopyWith<$Res> get amountQuantity {
    if (_value.amountQuantity == null) {
      return null;
    }
    return $QuantityCopyWith<$Res>(_value.amountQuantity, (value) {
      return _then(_value.copyWith(amountQuantity: value));
    });
  }

  @override
  $RangeCopyWith<$Res> get amountRange {
    if (_value.amountRange == null) {
      return null;
    }
    return $RangeCopyWith<$Res>(_value.amountRange, (value) {
      return _then(_value.copyWith(amountRange: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get amountRatio {
    if (_value.amountRatio == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.amountRatio, (value) {
      return _then(_value.copyWith(amountRatio: value));
    });
  }

  @override
  $RatioCopyWith<$Res> get amountRatioLowLimit {
    if (_value.amountRatioLowLimit == null) {
      return null;
    }
    return $RatioCopyWith<$Res>(_value.amountRatioLowLimit, (value) {
      return _then(_value.copyWith(amountRatioLowLimit: value));
    });
  }

  @override
  $CodeableConceptCopyWith<$Res> get amountType {
    if (_value.amountType == null) {
      return null;
    }
    return $CodeableConceptCopyWith<$Res>(_value.amountType, (value) {
      return _then(_value.copyWith(amountType: value));
    });
  }
}

abstract class _$SubstanceSpecificationRelationshipCopyWith<$Res>
    implements $SubstanceSpecificationRelationshipCopyWith<$Res> {
  factory _$SubstanceSpecificationRelationshipCopyWith(
          _SubstanceSpecificationRelationship value,
          $Res Function(_SubstanceSpecificationRelationship) then) =
      __$SubstanceSpecificationRelationshipCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference substanceReference,
      CodeableConcept substanceCodeableConcept,
      CodeableConcept relationship,
      Boolean isDefining,
      Quantity amountQuantity,
      Range amountRange,
      Ratio amountRatio,
      String amountString,
      Ratio amountRatioLowLimit,
      CodeableConcept amountType,
      List<Reference> source});

  @override
  $ReferenceCopyWith<$Res> get substanceReference;
  @override
  $CodeableConceptCopyWith<$Res> get substanceCodeableConcept;
  @override
  $CodeableConceptCopyWith<$Res> get relationship;
  @override
  $QuantityCopyWith<$Res> get amountQuantity;
  @override
  $RangeCopyWith<$Res> get amountRange;
  @override
  $RatioCopyWith<$Res> get amountRatio;
  @override
  $RatioCopyWith<$Res> get amountRatioLowLimit;
  @override
  $CodeableConceptCopyWith<$Res> get amountType;
}

class __$SubstanceSpecificationRelationshipCopyWithImpl<$Res>
    extends _$SubstanceSpecificationRelationshipCopyWithImpl<$Res>
    implements _$SubstanceSpecificationRelationshipCopyWith<$Res> {
  __$SubstanceSpecificationRelationshipCopyWithImpl(
      _SubstanceSpecificationRelationship _value,
      $Res Function(_SubstanceSpecificationRelationship) _then)
      : super(_value, (v) => _then(v as _SubstanceSpecificationRelationship));

  @override
  _SubstanceSpecificationRelationship get _value =>
      super._value as _SubstanceSpecificationRelationship;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object substanceReference = freezed,
    Object substanceCodeableConcept = freezed,
    Object relationship = freezed,
    Object isDefining = freezed,
    Object amountQuantity = freezed,
    Object amountRange = freezed,
    Object amountRatio = freezed,
    Object amountString = freezed,
    Object amountRatioLowLimit = freezed,
    Object amountType = freezed,
    Object source = freezed,
  }) {
    return _then(_SubstanceSpecificationRelationship(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      substanceReference: substanceReference == freezed
          ? _value.substanceReference
          : substanceReference as Reference,
      substanceCodeableConcept: substanceCodeableConcept == freezed
          ? _value.substanceCodeableConcept
          : substanceCodeableConcept as CodeableConcept,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as CodeableConcept,
      isDefining:
          isDefining == freezed ? _value.isDefining : isDefining as Boolean,
      amountQuantity: amountQuantity == freezed
          ? _value.amountQuantity
          : amountQuantity as Quantity,
      amountRange:
          amountRange == freezed ? _value.amountRange : amountRange as Range,
      amountRatio:
          amountRatio == freezed ? _value.amountRatio : amountRatio as Ratio,
      amountString: amountString == freezed
          ? _value.amountString
          : amountString as String,
      amountRatioLowLimit: amountRatioLowLimit == freezed
          ? _value.amountRatioLowLimit
          : amountRatioLowLimit as Ratio,
      amountType: amountType == freezed
          ? _value.amountType
          : amountType as CodeableConcept,
      source: source == freezed ? _value.source : source as List<Reference>,
    ));
  }
}

@JsonSerializable()
class _$_SubstanceSpecificationRelationship
    implements _SubstanceSpecificationRelationship {
  const _$_SubstanceSpecificationRelationship(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.substanceReference,
      this.substanceCodeableConcept,
      this.relationship,
      this.isDefining,
      this.amountQuantity,
      this.amountRange,
      this.amountRatio,
      this.amountString,
      this.amountRatioLowLimit,
      this.amountType,
      this.source});

  factory _$_SubstanceSpecificationRelationship.fromJson(
          Map<String, dynamic> json) =>
      _$_$_SubstanceSpecificationRelationshipFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Reference substanceReference;
  @override
  final CodeableConcept substanceCodeableConcept;
  @override
  final CodeableConcept relationship;
  @override
  final Boolean isDefining;
  @override
  final Quantity amountQuantity;
  @override
  final Range amountRange;
  @override
  final Ratio amountRatio;
  @override
  final String amountString;
  @override
  final Ratio amountRatioLowLimit;
  @override
  final CodeableConcept amountType;
  @override
  final List<Reference> source;

  @override
  String toString() {
    return 'SubstanceSpecificationRelationship(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, substanceReference: $substanceReference, substanceCodeableConcept: $substanceCodeableConcept, relationship: $relationship, isDefining: $isDefining, amountQuantity: $amountQuantity, amountRange: $amountRange, amountRatio: $amountRatio, amountString: $amountString, amountRatioLowLimit: $amountRatioLowLimit, amountType: $amountType, source: $source)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SubstanceSpecificationRelationship &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.substanceReference, substanceReference) ||
                const DeepCollectionEquality()
                    .equals(other.substanceReference, substanceReference)) &&
            (identical(
                    other.substanceCodeableConcept, substanceCodeableConcept) ||
                const DeepCollectionEquality().equals(
                    other.substanceCodeableConcept,
                    substanceCodeableConcept)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.isDefining, isDefining) ||
                const DeepCollectionEquality()
                    .equals(other.isDefining, isDefining)) &&
            (identical(other.amountQuantity, amountQuantity) ||
                const DeepCollectionEquality()
                    .equals(other.amountQuantity, amountQuantity)) &&
            (identical(other.amountRange, amountRange) ||
                const DeepCollectionEquality()
                    .equals(other.amountRange, amountRange)) &&
            (identical(other.amountRatio, amountRatio) ||
                const DeepCollectionEquality()
                    .equals(other.amountRatio, amountRatio)) &&
            (identical(other.amountString, amountString) ||
                const DeepCollectionEquality()
                    .equals(other.amountString, amountString)) &&
            (identical(other.amountRatioLowLimit, amountRatioLowLimit) ||
                const DeepCollectionEquality()
                    .equals(other.amountRatioLowLimit, amountRatioLowLimit)) &&
            (identical(other.amountType, amountType) ||
                const DeepCollectionEquality()
                    .equals(other.amountType, amountType)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(substanceReference) ^
      const DeepCollectionEquality().hash(substanceCodeableConcept) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(isDefining) ^
      const DeepCollectionEquality().hash(amountQuantity) ^
      const DeepCollectionEquality().hash(amountRange) ^
      const DeepCollectionEquality().hash(amountRatio) ^
      const DeepCollectionEquality().hash(amountString) ^
      const DeepCollectionEquality().hash(amountRatioLowLimit) ^
      const DeepCollectionEquality().hash(amountType) ^
      const DeepCollectionEquality().hash(source);

  @override
  _$SubstanceSpecificationRelationshipCopyWith<
          _SubstanceSpecificationRelationship>
      get copyWith => __$SubstanceSpecificationRelationshipCopyWithImpl<
          _SubstanceSpecificationRelationship>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_SubstanceSpecificationRelationshipToJson(this);
  }
}

abstract class _SubstanceSpecificationRelationship
    implements SubstanceSpecificationRelationship {
  const factory _SubstanceSpecificationRelationship(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Reference substanceReference,
      CodeableConcept substanceCodeableConcept,
      CodeableConcept relationship,
      Boolean isDefining,
      Quantity amountQuantity,
      Range amountRange,
      Ratio amountRatio,
      String amountString,
      Ratio amountRatioLowLimit,
      CodeableConcept amountType,
      List<Reference> source}) = _$_SubstanceSpecificationRelationship;

  factory _SubstanceSpecificationRelationship.fromJson(
          Map<String, dynamic> json) =
      _$_SubstanceSpecificationRelationship.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Reference get substanceReference;
  @override
  CodeableConcept get substanceCodeableConcept;
  @override
  CodeableConcept get relationship;
  @override
  Boolean get isDefining;
  @override
  Quantity get amountQuantity;
  @override
  Range get amountRange;
  @override
  Ratio get amountRatio;
  @override
  String get amountString;
  @override
  Ratio get amountRatioLowLimit;
  @override
  CodeableConcept get amountType;
  @override
  List<Reference> get source;
  @override
  _$SubstanceSpecificationRelationshipCopyWith<
      _SubstanceSpecificationRelationship> get copyWith;
}

TestReport _$TestReportFromJson(Map<String, dynamic> json) {
  return _TestReport.fromJson(json);
}

class _$TestReportTearOff {
  const _$TestReportTearOff();

  _TestReport call(
      {@required
      @JsonKey(required: true, defaultValue: 'TestReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      @JsonKey(unknownEnumValue: TestReportStatus.unknown)
          TestReportStatus status,
      @required
      @JsonKey(required: true)
          Reference testScript,
      @JsonKey(unknownEnumValue: TestReportResult.unknown)
          TestReportResult result,
      Decimal score,
      String tester,
      FhirDateTime issued,
      List<TestReportParticipant> participant,
      TestReportSetup setup,
      List<TestReportTest> test,
      TestReportTeardown teardown}) {
    return _TestReport(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      identifier: identifier,
      name: name,
      status: status,
      testScript: testScript,
      result: result,
      score: score,
      tester: tester,
      issued: issued,
      participant: participant,
      setup: setup,
      test: test,
      teardown: teardown,
    );
  }
}

// ignore: unused_element
const $TestReport = _$TestReportTearOff();

mixin _$TestReport {
  @JsonKey(required: true, defaultValue: 'TestReport')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Identifier get identifier;
  String get name;
  @JsonKey(unknownEnumValue: TestReportStatus.unknown)
  TestReportStatus get status;
  @JsonKey(required: true)
  Reference get testScript;
  @JsonKey(unknownEnumValue: TestReportResult.unknown)
  TestReportResult get result;
  Decimal get score;
  String get tester;
  FhirDateTime get issued;
  List<TestReportParticipant> get participant;
  TestReportSetup get setup;
  List<TestReportTest> get test;
  TestReportTeardown get teardown;

  Map<String, dynamic> toJson();
  $TestReportCopyWith<TestReport> get copyWith;
}

abstract class $TestReportCopyWith<$Res> {
  factory $TestReportCopyWith(
          TestReport value, $Res Function(TestReport) then) =
      _$TestReportCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'TestReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      @JsonKey(unknownEnumValue: TestReportStatus.unknown)
          TestReportStatus status,
      @JsonKey(required: true)
          Reference testScript,
      @JsonKey(unknownEnumValue: TestReportResult.unknown)
          TestReportResult result,
      Decimal score,
      String tester,
      FhirDateTime issued,
      List<TestReportParticipant> participant,
      TestReportSetup setup,
      List<TestReportTest> test,
      TestReportTeardown teardown});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $IdentifierCopyWith<$Res> get identifier;
  $ReferenceCopyWith<$Res> get testScript;
  $TestReportSetupCopyWith<$Res> get setup;
  $TestReportTeardownCopyWith<$Res> get teardown;
}

class _$TestReportCopyWithImpl<$Res> implements $TestReportCopyWith<$Res> {
  _$TestReportCopyWithImpl(this._value, this._then);

  final TestReport _value;
  // ignore: unused_field
  final $Res Function(TestReport) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object status = freezed,
    Object testScript = freezed,
    Object result = freezed,
    Object score = freezed,
    Object tester = freezed,
    Object issued = freezed,
    Object participant = freezed,
    Object setup = freezed,
    Object test = freezed,
    Object teardown = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      status: status == freezed ? _value.status : status as TestReportStatus,
      testScript:
          testScript == freezed ? _value.testScript : testScript as Reference,
      result: result == freezed ? _value.result : result as TestReportResult,
      score: score == freezed ? _value.score : score as Decimal,
      tester: tester == freezed ? _value.tester : tester as String,
      issued: issued == freezed ? _value.issued : issued as FhirDateTime,
      participant: participant == freezed
          ? _value.participant
          : participant as List<TestReportParticipant>,
      setup: setup == freezed ? _value.setup : setup as TestReportSetup,
      test: test == freezed ? _value.test : test as List<TestReportTest>,
      teardown: teardown == freezed
          ? _value.teardown
          : teardown as TestReportTeardown,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $ReferenceCopyWith<$Res> get testScript {
    if (_value.testScript == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.testScript, (value) {
      return _then(_value.copyWith(testScript: value));
    });
  }

  @override
  $TestReportSetupCopyWith<$Res> get setup {
    if (_value.setup == null) {
      return null;
    }
    return $TestReportSetupCopyWith<$Res>(_value.setup, (value) {
      return _then(_value.copyWith(setup: value));
    });
  }

  @override
  $TestReportTeardownCopyWith<$Res> get teardown {
    if (_value.teardown == null) {
      return null;
    }
    return $TestReportTeardownCopyWith<$Res>(_value.teardown, (value) {
      return _then(_value.copyWith(teardown: value));
    });
  }
}

abstract class _$TestReportCopyWith<$Res> implements $TestReportCopyWith<$Res> {
  factory _$TestReportCopyWith(
          _TestReport value, $Res Function(_TestReport) then) =
      __$TestReportCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'TestReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      @JsonKey(unknownEnumValue: TestReportStatus.unknown)
          TestReportStatus status,
      @JsonKey(required: true)
          Reference testScript,
      @JsonKey(unknownEnumValue: TestReportResult.unknown)
          TestReportResult result,
      Decimal score,
      String tester,
      FhirDateTime issued,
      List<TestReportParticipant> participant,
      TestReportSetup setup,
      List<TestReportTest> test,
      TestReportTeardown teardown});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $ReferenceCopyWith<$Res> get testScript;
  @override
  $TestReportSetupCopyWith<$Res> get setup;
  @override
  $TestReportTeardownCopyWith<$Res> get teardown;
}

class __$TestReportCopyWithImpl<$Res> extends _$TestReportCopyWithImpl<$Res>
    implements _$TestReportCopyWith<$Res> {
  __$TestReportCopyWithImpl(
      _TestReport _value, $Res Function(_TestReport) _then)
      : super(_value, (v) => _then(v as _TestReport));

  @override
  _TestReport get _value => super._value as _TestReport;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object identifier = freezed,
    Object name = freezed,
    Object status = freezed,
    Object testScript = freezed,
    Object result = freezed,
    Object score = freezed,
    Object tester = freezed,
    Object issued = freezed,
    Object participant = freezed,
    Object setup = freezed,
    Object test = freezed,
    Object teardown = freezed,
  }) {
    return _then(_TestReport(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      name: name == freezed ? _value.name : name as String,
      status: status == freezed ? _value.status : status as TestReportStatus,
      testScript:
          testScript == freezed ? _value.testScript : testScript as Reference,
      result: result == freezed ? _value.result : result as TestReportResult,
      score: score == freezed ? _value.score : score as Decimal,
      tester: tester == freezed ? _value.tester : tester as String,
      issued: issued == freezed ? _value.issued : issued as FhirDateTime,
      participant: participant == freezed
          ? _value.participant
          : participant as List<TestReportParticipant>,
      setup: setup == freezed ? _value.setup : setup as TestReportSetup,
      test: test == freezed ? _value.test : test as List<TestReportTest>,
      teardown: teardown == freezed
          ? _value.teardown
          : teardown as TestReportTeardown,
    ));
  }
}

@JsonSerializable()
class _$_TestReport implements _TestReport {
  const _$_TestReport(
      {@required
      @JsonKey(required: true, defaultValue: 'TestReport')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.identifier,
      this.name,
      @JsonKey(unknownEnumValue: TestReportStatus.unknown)
          this.status,
      @required
      @JsonKey(required: true)
          this.testScript,
      @JsonKey(unknownEnumValue: TestReportResult.unknown)
          this.result,
      this.score,
      this.tester,
      this.issued,
      this.participant,
      this.setup,
      this.test,
      this.teardown})
      : assert(resourceType != null),
        assert(testScript != null);

  factory _$_TestReport.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'TestReport')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Identifier identifier;
  @override
  final String name;
  @override
  @JsonKey(unknownEnumValue: TestReportStatus.unknown)
  final TestReportStatus status;
  @override
  @JsonKey(required: true)
  final Reference testScript;
  @override
  @JsonKey(unknownEnumValue: TestReportResult.unknown)
  final TestReportResult result;
  @override
  final Decimal score;
  @override
  final String tester;
  @override
  final FhirDateTime issued;
  @override
  final List<TestReportParticipant> participant;
  @override
  final TestReportSetup setup;
  @override
  final List<TestReportTest> test;
  @override
  final TestReportTeardown teardown;

  @override
  String toString() {
    return 'TestReport(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, name: $name, status: $status, testScript: $testScript, result: $result, score: $score, tester: $tester, issued: $issued, participant: $participant, setup: $setup, test: $test, teardown: $teardown)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReport &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.testScript, testScript) ||
                const DeepCollectionEquality()
                    .equals(other.testScript, testScript)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.tester, tester) ||
                const DeepCollectionEquality().equals(other.tester, tester)) &&
            (identical(other.issued, issued) ||
                const DeepCollectionEquality().equals(other.issued, issued)) &&
            (identical(other.participant, participant) ||
                const DeepCollectionEquality()
                    .equals(other.participant, participant)) &&
            (identical(other.setup, setup) ||
                const DeepCollectionEquality().equals(other.setup, setup)) &&
            (identical(other.test, test) ||
                const DeepCollectionEquality().equals(other.test, test)) &&
            (identical(other.teardown, teardown) ||
                const DeepCollectionEquality()
                    .equals(other.teardown, teardown)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(testScript) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(tester) ^
      const DeepCollectionEquality().hash(issued) ^
      const DeepCollectionEquality().hash(participant) ^
      const DeepCollectionEquality().hash(setup) ^
      const DeepCollectionEquality().hash(test) ^
      const DeepCollectionEquality().hash(teardown);

  @override
  _$TestReportCopyWith<_TestReport> get copyWith =>
      __$TestReportCopyWithImpl<_TestReport>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportToJson(this);
  }
}

abstract class _TestReport implements TestReport {
  const factory _TestReport(
      {@required
      @JsonKey(required: true, defaultValue: 'TestReport')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Identifier identifier,
      String name,
      @JsonKey(unknownEnumValue: TestReportStatus.unknown)
          TestReportStatus status,
      @required
      @JsonKey(required: true)
          Reference testScript,
      @JsonKey(unknownEnumValue: TestReportResult.unknown)
          TestReportResult result,
      Decimal score,
      String tester,
      FhirDateTime issued,
      List<TestReportParticipant> participant,
      TestReportSetup setup,
      List<TestReportTest> test,
      TestReportTeardown teardown}) = _$_TestReport;

  factory _TestReport.fromJson(Map<String, dynamic> json) =
      _$_TestReport.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'TestReport')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Identifier get identifier;
  @override
  String get name;
  @override
  @JsonKey(unknownEnumValue: TestReportStatus.unknown)
  TestReportStatus get status;
  @override
  @JsonKey(required: true)
  Reference get testScript;
  @override
  @JsonKey(unknownEnumValue: TestReportResult.unknown)
  TestReportResult get result;
  @override
  Decimal get score;
  @override
  String get tester;
  @override
  FhirDateTime get issued;
  @override
  List<TestReportParticipant> get participant;
  @override
  TestReportSetup get setup;
  @override
  List<TestReportTest> get test;
  @override
  TestReportTeardown get teardown;
  @override
  _$TestReportCopyWith<_TestReport> get copyWith;
}

TestReportParticipant _$TestReportParticipantFromJson(
    Map<String, dynamic> json) {
  return _TestReportParticipant.fromJson(json);
}

class _$TestReportParticipantTearOff {
  const _$TestReportParticipantTearOff();

  _TestReportParticipant call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
          TestReportParticipantType type,
      FhirUri uri,
      String display}) {
    return _TestReportParticipant(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      uri: uri,
      display: display,
    );
  }
}

// ignore: unused_element
const $TestReportParticipant = _$TestReportParticipantTearOff();

mixin _$TestReportParticipant {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
  TestReportParticipantType get type;
  FhirUri get uri;
  String get display;

  Map<String, dynamic> toJson();
  $TestReportParticipantCopyWith<TestReportParticipant> get copyWith;
}

abstract class $TestReportParticipantCopyWith<$Res> {
  factory $TestReportParticipantCopyWith(TestReportParticipant value,
          $Res Function(TestReportParticipant) then) =
      _$TestReportParticipantCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
          TestReportParticipantType type,
      FhirUri uri,
      String display});
}

class _$TestReportParticipantCopyWithImpl<$Res>
    implements $TestReportParticipantCopyWith<$Res> {
  _$TestReportParticipantCopyWithImpl(this._value, this._then);

  final TestReportParticipant _value;
  // ignore: unused_field
  final $Res Function(TestReportParticipant) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object uri = freezed,
    Object display = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as TestReportParticipantType,
      uri: uri == freezed ? _value.uri : uri as FhirUri,
      display: display == freezed ? _value.display : display as String,
    ));
  }
}

abstract class _$TestReportParticipantCopyWith<$Res>
    implements $TestReportParticipantCopyWith<$Res> {
  factory _$TestReportParticipantCopyWith(_TestReportParticipant value,
          $Res Function(_TestReportParticipant) then) =
      __$TestReportParticipantCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
          TestReportParticipantType type,
      FhirUri uri,
      String display});
}

class __$TestReportParticipantCopyWithImpl<$Res>
    extends _$TestReportParticipantCopyWithImpl<$Res>
    implements _$TestReportParticipantCopyWith<$Res> {
  __$TestReportParticipantCopyWithImpl(_TestReportParticipant _value,
      $Res Function(_TestReportParticipant) _then)
      : super(_value, (v) => _then(v as _TestReportParticipant));

  @override
  _TestReportParticipant get _value => super._value as _TestReportParticipant;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object uri = freezed,
    Object display = freezed,
  }) {
    return _then(_TestReportParticipant(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as TestReportParticipantType,
      uri: uri == freezed ? _value.uri : uri as FhirUri,
      display: display == freezed ? _value.display : display as String,
    ));
  }
}

@JsonSerializable()
class _$_TestReportParticipant implements _TestReportParticipant {
  const _$_TestReportParticipant(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: TestReportParticipantType.unknown) this.type,
      this.uri,
      this.display});

  factory _$_TestReportParticipant.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportParticipantFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
  final TestReportParticipantType type;
  @override
  final FhirUri uri;
  @override
  final String display;

  @override
  String toString() {
    return 'TestReportParticipant(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, uri: $uri, display: $display)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportParticipant &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.uri, uri) ||
                const DeepCollectionEquality().equals(other.uri, uri)) &&
            (identical(other.display, display) ||
                const DeepCollectionEquality().equals(other.display, display)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(uri) ^
      const DeepCollectionEquality().hash(display);

  @override
  _$TestReportParticipantCopyWith<_TestReportParticipant> get copyWith =>
      __$TestReportParticipantCopyWithImpl<_TestReportParticipant>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportParticipantToJson(this);
  }
}

abstract class _TestReportParticipant implements TestReportParticipant {
  const factory _TestReportParticipant(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
          TestReportParticipantType type,
      FhirUri uri,
      String display}) = _$_TestReportParticipant;

  factory _TestReportParticipant.fromJson(Map<String, dynamic> json) =
      _$_TestReportParticipant.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: TestReportParticipantType.unknown)
  TestReportParticipantType get type;
  @override
  FhirUri get uri;
  @override
  String get display;
  @override
  _$TestReportParticipantCopyWith<_TestReportParticipant> get copyWith;
}

TestReportSetup _$TestReportSetupFromJson(Map<String, dynamic> json) {
  return _TestReportSetup.fromJson(json);
}

class _$TestReportSetupTearOff {
  const _$TestReportSetupTearOff();

  _TestReportSetup call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) List<TestReportAction> action}) {
    return _TestReportSetup(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestReportSetup = _$TestReportSetupTearOff();

mixin _$TestReportSetup {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  List<TestReportAction> get action;

  Map<String, dynamic> toJson();
  $TestReportSetupCopyWith<TestReportSetup> get copyWith;
}

abstract class $TestReportSetupCopyWith<$Res> {
  factory $TestReportSetupCopyWith(
          TestReportSetup value, $Res Function(TestReportSetup) then) =
      _$TestReportSetupCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestReportAction> action});
}

class _$TestReportSetupCopyWithImpl<$Res>
    implements $TestReportSetupCopyWith<$Res> {
  _$TestReportSetupCopyWithImpl(this._value, this._then);

  final TestReportSetup _value;
  // ignore: unused_field
  final $Res Function(TestReportSetup) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestReportAction>,
    ));
  }
}

abstract class _$TestReportSetupCopyWith<$Res>
    implements $TestReportSetupCopyWith<$Res> {
  factory _$TestReportSetupCopyWith(
          _TestReportSetup value, $Res Function(_TestReportSetup) then) =
      __$TestReportSetupCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestReportAction> action});
}

class __$TestReportSetupCopyWithImpl<$Res>
    extends _$TestReportSetupCopyWithImpl<$Res>
    implements _$TestReportSetupCopyWith<$Res> {
  __$TestReportSetupCopyWithImpl(
      _TestReportSetup _value, $Res Function(_TestReportSetup) _then)
      : super(_value, (v) => _then(v as _TestReportSetup));

  @override
  _TestReportSetup get _value => super._value as _TestReportSetup;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_TestReportSetup(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestReportAction>,
    ));
  }
}

@JsonSerializable()
class _$_TestReportSetup implements _TestReportSetup {
  const _$_TestReportSetup(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestReportSetup.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportSetupFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final List<TestReportAction> action;

  @override
  String toString() {
    return 'TestReportSetup(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportSetup &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestReportSetupCopyWith<_TestReportSetup> get copyWith =>
      __$TestReportSetupCopyWithImpl<_TestReportSetup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportSetupToJson(this);
  }
}

abstract class _TestReportSetup implements TestReportSetup {
  const factory _TestReportSetup(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) List<TestReportAction> action}) =
      _$_TestReportSetup;

  factory _TestReportSetup.fromJson(Map<String, dynamic> json) =
      _$_TestReportSetup.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  List<TestReportAction> get action;
  @override
  _$TestReportSetupCopyWith<_TestReportSetup> get copyWith;
}

TestReportAction _$TestReportActionFromJson(Map<String, dynamic> json) {
  return _TestReportAction.fromJson(json);
}

class _$TestReportActionTearOff {
  const _$TestReportActionTearOff();

  _TestReportAction call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_}) {
    return _TestReportAction(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
      assert_: assert_,
    );
  }
}

// ignore: unused_element
const $TestReportAction = _$TestReportActionTearOff();

mixin _$TestReportAction {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  TestReportOperation get operation;
  @JsonKey(name: 'assert')
  TestReportAssert get assert_;

  Map<String, dynamic> toJson();
  $TestReportActionCopyWith<TestReportAction> get copyWith;
}

abstract class $TestReportActionCopyWith<$Res> {
  factory $TestReportActionCopyWith(
          TestReportAction value, $Res Function(TestReportAction) then) =
      _$TestReportActionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_});

  $TestReportOperationCopyWith<$Res> get operation;
  $TestReportAssertCopyWith<$Res> get assert_;
}

class _$TestReportActionCopyWithImpl<$Res>
    implements $TestReportActionCopyWith<$Res> {
  _$TestReportActionCopyWithImpl(this._value, this._then);

  final TestReportAction _value;
  // ignore: unused_field
  final $Res Function(TestReportAction) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestReportAssert,
    ));
  }

  @override
  $TestReportOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestReportOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }

  @override
  $TestReportAssertCopyWith<$Res> get assert_ {
    if (_value.assert_ == null) {
      return null;
    }
    return $TestReportAssertCopyWith<$Res>(_value.assert_, (value) {
      return _then(_value.copyWith(assert_: value));
    });
  }
}

abstract class _$TestReportActionCopyWith<$Res>
    implements $TestReportActionCopyWith<$Res> {
  factory _$TestReportActionCopyWith(
          _TestReportAction value, $Res Function(_TestReportAction) then) =
      __$TestReportActionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_});

  @override
  $TestReportOperationCopyWith<$Res> get operation;
  @override
  $TestReportAssertCopyWith<$Res> get assert_;
}

class __$TestReportActionCopyWithImpl<$Res>
    extends _$TestReportActionCopyWithImpl<$Res>
    implements _$TestReportActionCopyWith<$Res> {
  __$TestReportActionCopyWithImpl(
      _TestReportAction _value, $Res Function(_TestReportAction) _then)
      : super(_value, (v) => _then(v as _TestReportAction));

  @override
  _TestReportAction get _value => super._value as _TestReportAction;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_TestReportAction(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestReportAssert,
    ));
  }
}

@JsonSerializable()
class _$_TestReportAction implements _TestReportAction {
  const _$_TestReportAction(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.operation,
      @JsonKey(name: 'assert') this.assert_});

  factory _$_TestReportAction.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportActionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final TestReportOperation operation;
  @override
  @JsonKey(name: 'assert')
  final TestReportAssert assert_;

  @override
  String toString() {
    return 'TestReportAction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation, assert_: $assert_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportAction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)) &&
            (identical(other.assert_, assert_) ||
                const DeepCollectionEquality().equals(other.assert_, assert_)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation) ^
      const DeepCollectionEquality().hash(assert_);

  @override
  _$TestReportActionCopyWith<_TestReportAction> get copyWith =>
      __$TestReportActionCopyWithImpl<_TestReportAction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportActionToJson(this);
  }
}

abstract class _TestReportAction implements TestReportAction {
  const factory _TestReportAction(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_}) = _$_TestReportAction;

  factory _TestReportAction.fromJson(Map<String, dynamic> json) =
      _$_TestReportAction.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  TestReportOperation get operation;
  @override
  @JsonKey(name: 'assert')
  TestReportAssert get assert_;
  @override
  _$TestReportActionCopyWith<_TestReportAction> get copyWith;
}

TestReportOperation _$TestReportOperationFromJson(Map<String, dynamic> json) {
  return _TestReportOperation.fromJson(json);
}

class _$TestReportOperationTearOff {
  const _$TestReportOperationTearOff();

  _TestReportOperation call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: OperationResult.unknown)
          OperationResult result,
      Markdown message,
      FhirUri detail}) {
    return _TestReportOperation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      result: result,
      message: message,
      detail: detail,
    );
  }
}

// ignore: unused_element
const $TestReportOperation = _$TestReportOperationTearOff();

mixin _$TestReportOperation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: OperationResult.unknown)
  OperationResult get result;
  Markdown get message;
  FhirUri get detail;

  Map<String, dynamic> toJson();
  $TestReportOperationCopyWith<TestReportOperation> get copyWith;
}

abstract class $TestReportOperationCopyWith<$Res> {
  factory $TestReportOperationCopyWith(
          TestReportOperation value, $Res Function(TestReportOperation) then) =
      _$TestReportOperationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: OperationResult.unknown)
          OperationResult result,
      Markdown message,
      FhirUri detail});
}

class _$TestReportOperationCopyWithImpl<$Res>
    implements $TestReportOperationCopyWith<$Res> {
  _$TestReportOperationCopyWithImpl(this._value, this._then);

  final TestReportOperation _value;
  // ignore: unused_field
  final $Res Function(TestReportOperation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object result = freezed,
    Object message = freezed,
    Object detail = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      result: result == freezed ? _value.result : result as OperationResult,
      message: message == freezed ? _value.message : message as Markdown,
      detail: detail == freezed ? _value.detail : detail as FhirUri,
    ));
  }
}

abstract class _$TestReportOperationCopyWith<$Res>
    implements $TestReportOperationCopyWith<$Res> {
  factory _$TestReportOperationCopyWith(_TestReportOperation value,
          $Res Function(_TestReportOperation) then) =
      __$TestReportOperationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: OperationResult.unknown)
          OperationResult result,
      Markdown message,
      FhirUri detail});
}

class __$TestReportOperationCopyWithImpl<$Res>
    extends _$TestReportOperationCopyWithImpl<$Res>
    implements _$TestReportOperationCopyWith<$Res> {
  __$TestReportOperationCopyWithImpl(
      _TestReportOperation _value, $Res Function(_TestReportOperation) _then)
      : super(_value, (v) => _then(v as _TestReportOperation));

  @override
  _TestReportOperation get _value => super._value as _TestReportOperation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object result = freezed,
    Object message = freezed,
    Object detail = freezed,
  }) {
    return _then(_TestReportOperation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      result: result == freezed ? _value.result : result as OperationResult,
      message: message == freezed ? _value.message : message as Markdown,
      detail: detail == freezed ? _value.detail : detail as FhirUri,
    ));
  }
}

@JsonSerializable()
class _$_TestReportOperation implements _TestReportOperation {
  const _$_TestReportOperation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: OperationResult.unknown) this.result,
      this.message,
      this.detail});

  factory _$_TestReportOperation.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportOperationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: OperationResult.unknown)
  final OperationResult result;
  @override
  final Markdown message;
  @override
  final FhirUri detail;

  @override
  String toString() {
    return 'TestReportOperation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, result: $result, message: $message, detail: $detail)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportOperation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(detail);

  @override
  _$TestReportOperationCopyWith<_TestReportOperation> get copyWith =>
      __$TestReportOperationCopyWithImpl<_TestReportOperation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportOperationToJson(this);
  }
}

abstract class _TestReportOperation implements TestReportOperation {
  const factory _TestReportOperation(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: OperationResult.unknown)
          OperationResult result,
      Markdown message,
      FhirUri detail}) = _$_TestReportOperation;

  factory _TestReportOperation.fromJson(Map<String, dynamic> json) =
      _$_TestReportOperation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: OperationResult.unknown)
  OperationResult get result;
  @override
  Markdown get message;
  @override
  FhirUri get detail;
  @override
  _$TestReportOperationCopyWith<_TestReportOperation> get copyWith;
}

TestReportAssert _$TestReportAssertFromJson(Map<String, dynamic> json) {
  return _TestReportAssert.fromJson(json);
}

class _$TestReportAssertTearOff {
  const _$TestReportAssertTearOff();

  _TestReportAssert call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: AssertResult.unknown) AssertResult result,
      Markdown message,
      String detail}) {
    return _TestReportAssert(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      result: result,
      message: message,
      detail: detail,
    );
  }
}

// ignore: unused_element
const $TestReportAssert = _$TestReportAssertTearOff();

mixin _$TestReportAssert {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(unknownEnumValue: AssertResult.unknown)
  AssertResult get result;
  Markdown get message;
  String get detail;

  Map<String, dynamic> toJson();
  $TestReportAssertCopyWith<TestReportAssert> get copyWith;
}

abstract class $TestReportAssertCopyWith<$Res> {
  factory $TestReportAssertCopyWith(
          TestReportAssert value, $Res Function(TestReportAssert) then) =
      _$TestReportAssertCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: AssertResult.unknown) AssertResult result,
      Markdown message,
      String detail});
}

class _$TestReportAssertCopyWithImpl<$Res>
    implements $TestReportAssertCopyWith<$Res> {
  _$TestReportAssertCopyWithImpl(this._value, this._then);

  final TestReportAssert _value;
  // ignore: unused_field
  final $Res Function(TestReportAssert) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object result = freezed,
    Object message = freezed,
    Object detail = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      result: result == freezed ? _value.result : result as AssertResult,
      message: message == freezed ? _value.message : message as Markdown,
      detail: detail == freezed ? _value.detail : detail as String,
    ));
  }
}

abstract class _$TestReportAssertCopyWith<$Res>
    implements $TestReportAssertCopyWith<$Res> {
  factory _$TestReportAssertCopyWith(
          _TestReportAssert value, $Res Function(_TestReportAssert) then) =
      __$TestReportAssertCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: AssertResult.unknown) AssertResult result,
      Markdown message,
      String detail});
}

class __$TestReportAssertCopyWithImpl<$Res>
    extends _$TestReportAssertCopyWithImpl<$Res>
    implements _$TestReportAssertCopyWith<$Res> {
  __$TestReportAssertCopyWithImpl(
      _TestReportAssert _value, $Res Function(_TestReportAssert) _then)
      : super(_value, (v) => _then(v as _TestReportAssert));

  @override
  _TestReportAssert get _value => super._value as _TestReportAssert;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object result = freezed,
    Object message = freezed,
    Object detail = freezed,
  }) {
    return _then(_TestReportAssert(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      result: result == freezed ? _value.result : result as AssertResult,
      message: message == freezed ? _value.message : message as Markdown,
      detail: detail == freezed ? _value.detail : detail as String,
    ));
  }
}

@JsonSerializable()
class _$_TestReportAssert implements _TestReportAssert {
  const _$_TestReportAssert(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @JsonKey(unknownEnumValue: AssertResult.unknown) this.result,
      this.message,
      this.detail});

  factory _$_TestReportAssert.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportAssertFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(unknownEnumValue: AssertResult.unknown)
  final AssertResult result;
  @override
  final Markdown message;
  @override
  final String detail;

  @override
  String toString() {
    return 'TestReportAssert(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, result: $result, message: $message, detail: $detail)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportAssert &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(detail);

  @override
  _$TestReportAssertCopyWith<_TestReportAssert> get copyWith =>
      __$TestReportAssertCopyWithImpl<_TestReportAssert>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportAssertToJson(this);
  }
}

abstract class _TestReportAssert implements TestReportAssert {
  const factory _TestReportAssert(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(unknownEnumValue: AssertResult.unknown) AssertResult result,
      Markdown message,
      String detail}) = _$_TestReportAssert;

  factory _TestReportAssert.fromJson(Map<String, dynamic> json) =
      _$_TestReportAssert.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(unknownEnumValue: AssertResult.unknown)
  AssertResult get result;
  @override
  Markdown get message;
  @override
  String get detail;
  @override
  _$TestReportAssertCopyWith<_TestReportAssert> get copyWith;
}

TestReportTest _$TestReportTestFromJson(Map<String, dynamic> json) {
  return _TestReportTest.fromJson(json);
}

class _$TestReportTestTearOff {
  const _$TestReportTestTearOff();

  _TestReportTest call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @required @JsonKey(required: true) List<TestReportAction1> action}) {
    return _TestReportTest(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      description: description,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestReportTest = _$TestReportTestTearOff();

mixin _$TestReportTest {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  String get description;
  @JsonKey(required: true)
  List<TestReportAction1> get action;

  Map<String, dynamic> toJson();
  $TestReportTestCopyWith<TestReportTest> get copyWith;
}

abstract class $TestReportTestCopyWith<$Res> {
  factory $TestReportTestCopyWith(
          TestReportTest value, $Res Function(TestReportTest) then) =
      _$TestReportTestCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @JsonKey(required: true) List<TestReportAction1> action});
}

class _$TestReportTestCopyWithImpl<$Res>
    implements $TestReportTestCopyWith<$Res> {
  _$TestReportTestCopyWithImpl(this._value, this._then);

  final TestReportTest _value;
  // ignore: unused_field
  final $Res Function(TestReportTest) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object description = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      description:
          description == freezed ? _value.description : description as String,
      action:
          action == freezed ? _value.action : action as List<TestReportAction1>,
    ));
  }
}

abstract class _$TestReportTestCopyWith<$Res>
    implements $TestReportTestCopyWith<$Res> {
  factory _$TestReportTestCopyWith(
          _TestReportTest value, $Res Function(_TestReportTest) then) =
      __$TestReportTestCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @JsonKey(required: true) List<TestReportAction1> action});
}

class __$TestReportTestCopyWithImpl<$Res>
    extends _$TestReportTestCopyWithImpl<$Res>
    implements _$TestReportTestCopyWith<$Res> {
  __$TestReportTestCopyWithImpl(
      _TestReportTest _value, $Res Function(_TestReportTest) _then)
      : super(_value, (v) => _then(v as _TestReportTest));

  @override
  _TestReportTest get _value => super._value as _TestReportTest;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object description = freezed,
    Object action = freezed,
  }) {
    return _then(_TestReportTest(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      description:
          description == freezed ? _value.description : description as String,
      action:
          action == freezed ? _value.action : action as List<TestReportAction1>,
    ));
  }
}

@JsonSerializable()
class _$_TestReportTest implements _TestReportTest {
  const _$_TestReportTest(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.description,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestReportTest.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportTestFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final String description;
  @override
  @JsonKey(required: true)
  final List<TestReportAction1> action;

  @override
  String toString() {
    return 'TestReportTest(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, description: $description, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportTest &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestReportTestCopyWith<_TestReportTest> get copyWith =>
      __$TestReportTestCopyWithImpl<_TestReportTest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportTestToJson(this);
  }
}

abstract class _TestReportTest implements TestReportTest {
  const factory _TestReportTest(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String name,
          String description,
          @required @JsonKey(required: true) List<TestReportAction1> action}) =
      _$_TestReportTest;

  factory _TestReportTest.fromJson(Map<String, dynamic> json) =
      _$_TestReportTest.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  String get description;
  @override
  @JsonKey(required: true)
  List<TestReportAction1> get action;
  @override
  _$TestReportTestCopyWith<_TestReportTest> get copyWith;
}

TestReportAction1 _$TestReportAction1FromJson(Map<String, dynamic> json) {
  return _TestReportAction1.fromJson(json);
}

class _$TestReportAction1TearOff {
  const _$TestReportAction1TearOff();

  _TestReportAction1 call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_}) {
    return _TestReportAction1(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
      assert_: assert_,
    );
  }
}

// ignore: unused_element
const $TestReportAction1 = _$TestReportAction1TearOff();

mixin _$TestReportAction1 {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  TestReportOperation get operation;
  @JsonKey(name: 'assert')
  TestReportAssert get assert_;

  Map<String, dynamic> toJson();
  $TestReportAction1CopyWith<TestReportAction1> get copyWith;
}

abstract class $TestReportAction1CopyWith<$Res> {
  factory $TestReportAction1CopyWith(
          TestReportAction1 value, $Res Function(TestReportAction1) then) =
      _$TestReportAction1CopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_});

  $TestReportOperationCopyWith<$Res> get operation;
  $TestReportAssertCopyWith<$Res> get assert_;
}

class _$TestReportAction1CopyWithImpl<$Res>
    implements $TestReportAction1CopyWith<$Res> {
  _$TestReportAction1CopyWithImpl(this._value, this._then);

  final TestReportAction1 _value;
  // ignore: unused_field
  final $Res Function(TestReportAction1) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestReportAssert,
    ));
  }

  @override
  $TestReportOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestReportOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }

  @override
  $TestReportAssertCopyWith<$Res> get assert_ {
    if (_value.assert_ == null) {
      return null;
    }
    return $TestReportAssertCopyWith<$Res>(_value.assert_, (value) {
      return _then(_value.copyWith(assert_: value));
    });
  }
}

abstract class _$TestReportAction1CopyWith<$Res>
    implements $TestReportAction1CopyWith<$Res> {
  factory _$TestReportAction1CopyWith(
          _TestReportAction1 value, $Res Function(_TestReportAction1) then) =
      __$TestReportAction1CopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestReportOperation operation,
      @JsonKey(name: 'assert') TestReportAssert assert_});

  @override
  $TestReportOperationCopyWith<$Res> get operation;
  @override
  $TestReportAssertCopyWith<$Res> get assert_;
}

class __$TestReportAction1CopyWithImpl<$Res>
    extends _$TestReportAction1CopyWithImpl<$Res>
    implements _$TestReportAction1CopyWith<$Res> {
  __$TestReportAction1CopyWithImpl(
      _TestReportAction1 _value, $Res Function(_TestReportAction1) _then)
      : super(_value, (v) => _then(v as _TestReportAction1));

  @override
  _TestReportAction1 get _value => super._value as _TestReportAction1;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_TestReportAction1(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestReportAssert,
    ));
  }
}

@JsonSerializable()
class _$_TestReportAction1 implements _TestReportAction1 {
  const _$_TestReportAction1(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.operation,
      @JsonKey(name: 'assert') this.assert_});

  factory _$_TestReportAction1.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportAction1FromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final TestReportOperation operation;
  @override
  @JsonKey(name: 'assert')
  final TestReportAssert assert_;

  @override
  String toString() {
    return 'TestReportAction1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation, assert_: $assert_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportAction1 &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)) &&
            (identical(other.assert_, assert_) ||
                const DeepCollectionEquality().equals(other.assert_, assert_)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation) ^
      const DeepCollectionEquality().hash(assert_);

  @override
  _$TestReportAction1CopyWith<_TestReportAction1> get copyWith =>
      __$TestReportAction1CopyWithImpl<_TestReportAction1>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportAction1ToJson(this);
  }
}

abstract class _TestReportAction1 implements TestReportAction1 {
  const factory _TestReportAction1(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          TestReportOperation operation,
          @JsonKey(name: 'assert') TestReportAssert assert_}) =
      _$_TestReportAction1;

  factory _TestReportAction1.fromJson(Map<String, dynamic> json) =
      _$_TestReportAction1.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  TestReportOperation get operation;
  @override
  @JsonKey(name: 'assert')
  TestReportAssert get assert_;
  @override
  _$TestReportAction1CopyWith<_TestReportAction1> get copyWith;
}

TestReportTeardown _$TestReportTeardownFromJson(Map<String, dynamic> json) {
  return _TestReportTeardown.fromJson(json);
}

class _$TestReportTeardownTearOff {
  const _$TestReportTeardownTearOff();

  _TestReportTeardown call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) List<TestReportAction2> action}) {
    return _TestReportTeardown(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestReportTeardown = _$TestReportTeardownTearOff();

mixin _$TestReportTeardown {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  List<TestReportAction2> get action;

  Map<String, dynamic> toJson();
  $TestReportTeardownCopyWith<TestReportTeardown> get copyWith;
}

abstract class $TestReportTeardownCopyWith<$Res> {
  factory $TestReportTeardownCopyWith(
          TestReportTeardown value, $Res Function(TestReportTeardown) then) =
      _$TestReportTeardownCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestReportAction2> action});
}

class _$TestReportTeardownCopyWithImpl<$Res>
    implements $TestReportTeardownCopyWith<$Res> {
  _$TestReportTeardownCopyWithImpl(this._value, this._then);

  final TestReportTeardown _value;
  // ignore: unused_field
  final $Res Function(TestReportTeardown) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestReportAction2>,
    ));
  }
}

abstract class _$TestReportTeardownCopyWith<$Res>
    implements $TestReportTeardownCopyWith<$Res> {
  factory _$TestReportTeardownCopyWith(
          _TestReportTeardown value, $Res Function(_TestReportTeardown) then) =
      __$TestReportTeardownCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestReportAction2> action});
}

class __$TestReportTeardownCopyWithImpl<$Res>
    extends _$TestReportTeardownCopyWithImpl<$Res>
    implements _$TestReportTeardownCopyWith<$Res> {
  __$TestReportTeardownCopyWithImpl(
      _TestReportTeardown _value, $Res Function(_TestReportTeardown) _then)
      : super(_value, (v) => _then(v as _TestReportTeardown));

  @override
  _TestReportTeardown get _value => super._value as _TestReportTeardown;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_TestReportTeardown(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestReportAction2>,
    ));
  }
}

@JsonSerializable()
class _$_TestReportTeardown implements _TestReportTeardown {
  const _$_TestReportTeardown(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestReportTeardown.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportTeardownFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final List<TestReportAction2> action;

  @override
  String toString() {
    return 'TestReportTeardown(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportTeardown &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestReportTeardownCopyWith<_TestReportTeardown> get copyWith =>
      __$TestReportTeardownCopyWithImpl<_TestReportTeardown>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportTeardownToJson(this);
  }
}

abstract class _TestReportTeardown implements TestReportTeardown {
  const factory _TestReportTeardown(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) List<TestReportAction2> action}) =
      _$_TestReportTeardown;

  factory _TestReportTeardown.fromJson(Map<String, dynamic> json) =
      _$_TestReportTeardown.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  List<TestReportAction2> get action;
  @override
  _$TestReportTeardownCopyWith<_TestReportTeardown> get copyWith;
}

TestReportAction2 _$TestReportAction2FromJson(Map<String, dynamic> json) {
  return _TestReportAction2.fromJson(json);
}

class _$TestReportAction2TearOff {
  const _$TestReportAction2TearOff();

  _TestReportAction2 call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) TestReportOperation operation}) {
    return _TestReportAction2(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
    );
  }
}

// ignore: unused_element
const $TestReportAction2 = _$TestReportAction2TearOff();

mixin _$TestReportAction2 {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  TestReportOperation get operation;

  Map<String, dynamic> toJson();
  $TestReportAction2CopyWith<TestReportAction2> get copyWith;
}

abstract class $TestReportAction2CopyWith<$Res> {
  factory $TestReportAction2CopyWith(
          TestReportAction2 value, $Res Function(TestReportAction2) then) =
      _$TestReportAction2CopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) TestReportOperation operation});

  $TestReportOperationCopyWith<$Res> get operation;
}

class _$TestReportAction2CopyWithImpl<$Res>
    implements $TestReportAction2CopyWith<$Res> {
  _$TestReportAction2CopyWithImpl(this._value, this._then);

  final TestReportAction2 _value;
  // ignore: unused_field
  final $Res Function(TestReportAction2) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
    ));
  }

  @override
  $TestReportOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestReportOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }
}

abstract class _$TestReportAction2CopyWith<$Res>
    implements $TestReportAction2CopyWith<$Res> {
  factory _$TestReportAction2CopyWith(
          _TestReportAction2 value, $Res Function(_TestReportAction2) then) =
      __$TestReportAction2CopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) TestReportOperation operation});

  @override
  $TestReportOperationCopyWith<$Res> get operation;
}

class __$TestReportAction2CopyWithImpl<$Res>
    extends _$TestReportAction2CopyWithImpl<$Res>
    implements _$TestReportAction2CopyWith<$Res> {
  __$TestReportAction2CopyWithImpl(
      _TestReportAction2 _value, $Res Function(_TestReportAction2) _then)
      : super(_value, (v) => _then(v as _TestReportAction2));

  @override
  _TestReportAction2 get _value => super._value as _TestReportAction2;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
  }) {
    return _then(_TestReportAction2(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestReportOperation,
    ));
  }
}

@JsonSerializable()
class _$_TestReportAction2 implements _TestReportAction2 {
  const _$_TestReportAction2(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.operation})
      : assert(operation != null);

  factory _$_TestReportAction2.fromJson(Map<String, dynamic> json) =>
      _$_$_TestReportAction2FromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final TestReportOperation operation;

  @override
  String toString() {
    return 'TestReportAction2(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestReportAction2 &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation);

  @override
  _$TestReportAction2CopyWith<_TestReportAction2> get copyWith =>
      __$TestReportAction2CopyWithImpl<_TestReportAction2>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestReportAction2ToJson(this);
  }
}

abstract class _TestReportAction2 implements TestReportAction2 {
  const factory _TestReportAction2(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) TestReportOperation operation}) =
      _$_TestReportAction2;

  factory _TestReportAction2.fromJson(Map<String, dynamic> json) =
      _$_TestReportAction2.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  TestReportOperation get operation;
  @override
  _$TestReportAction2CopyWith<_TestReportAction2> get copyWith;
}

TestScript _$TestScriptFromJson(Map<String, dynamic> json) {
  return _TestScript.fromJson(json);
}

class _$TestScriptTearOff {
  const _$TestScriptTearOff();

  _TestScript call(
      {@required
      @JsonKey(required: true, defaultValue: 'TestScript')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      Identifier identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
          TestScriptStatus status,
      Boolean experimental,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      List<TestScriptOrigin> origin,
      List<TestScriptDestination> destination,
      TestScriptMetadata metadata,
      List<TestScriptFixture> fixture,
      List<Reference> profile,
      List<TestScriptVariable> variable,
      TestScriptSetup setup,
      List<TestScriptTest> test,
      TestScriptTeardown teardown}) {
    return _TestScript(
      resourceType: resourceType,
      id: id,
      meta: meta,
      implicitRules: implicitRules,
      language: language,
      text: text,
      contained: contained,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      identifier: identifier,
      version: version,
      name: name,
      title: title,
      status: status,
      experimental: experimental,
      date: date,
      publisher: publisher,
      contact: contact,
      description: description,
      useContext: useContext,
      jurisdiction: jurisdiction,
      purpose: purpose,
      copyright: copyright,
      origin: origin,
      destination: destination,
      metadata: metadata,
      fixture: fixture,
      profile: profile,
      variable: variable,
      setup: setup,
      test: test,
      teardown: teardown,
    );
  }
}

// ignore: unused_element
const $TestScript = _$TestScriptTearOff();

mixin _$TestScript {
  @JsonKey(required: true, defaultValue: 'TestScript')
  String get resourceType;
  Id get id;
  Meta get meta;
  FhirUri get implicitRules;
  Code get language;
  Narrative get text;
  List<Resource> get contained;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  Identifier get identifier;
  String get version;
  String get name;
  String get title;
  @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
  TestScriptStatus get status;
  Boolean get experimental;
  FhirDateTime get date;
  String get publisher;
  List<ContactDetail> get contact;
  Markdown get description;
  List<UsageContext> get useContext;
  List<CodeableConcept> get jurisdiction;
  Markdown get purpose;
  Markdown get copyright;
  List<TestScriptOrigin> get origin;
  List<TestScriptDestination> get destination;
  TestScriptMetadata get metadata;
  List<TestScriptFixture> get fixture;
  List<Reference> get profile;
  List<TestScriptVariable> get variable;
  TestScriptSetup get setup;
  List<TestScriptTest> get test;
  TestScriptTeardown get teardown;

  Map<String, dynamic> toJson();
  $TestScriptCopyWith<TestScript> get copyWith;
}

abstract class $TestScriptCopyWith<$Res> {
  factory $TestScriptCopyWith(
          TestScript value, $Res Function(TestScript) then) =
      _$TestScriptCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(required: true, defaultValue: 'TestScript')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      Identifier identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
          TestScriptStatus status,
      Boolean experimental,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      List<TestScriptOrigin> origin,
      List<TestScriptDestination> destination,
      TestScriptMetadata metadata,
      List<TestScriptFixture> fixture,
      List<Reference> profile,
      List<TestScriptVariable> variable,
      TestScriptSetup setup,
      List<TestScriptTest> test,
      TestScriptTeardown teardown});

  $MetaCopyWith<$Res> get meta;
  $NarrativeCopyWith<$Res> get text;
  $IdentifierCopyWith<$Res> get identifier;
  $TestScriptMetadataCopyWith<$Res> get metadata;
  $TestScriptSetupCopyWith<$Res> get setup;
  $TestScriptTeardownCopyWith<$Res> get teardown;
}

class _$TestScriptCopyWithImpl<$Res> implements $TestScriptCopyWith<$Res> {
  _$TestScriptCopyWithImpl(this._value, this._then);

  final TestScript _value;
  // ignore: unused_field
  final $Res Function(TestScript) _then;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object copyright = freezed,
    Object origin = freezed,
    Object destination = freezed,
    Object metadata = freezed,
    Object fixture = freezed,
    Object profile = freezed,
    Object variable = freezed,
    Object setup = freezed,
    Object test = freezed,
    Object teardown = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed ? _value.status : status as TestScriptStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      origin:
          origin == freezed ? _value.origin : origin as List<TestScriptOrigin>,
      destination: destination == freezed
          ? _value.destination
          : destination as List<TestScriptDestination>,
      metadata: metadata == freezed
          ? _value.metadata
          : metadata as TestScriptMetadata,
      fixture: fixture == freezed
          ? _value.fixture
          : fixture as List<TestScriptFixture>,
      profile: profile == freezed ? _value.profile : profile as List<Reference>,
      variable: variable == freezed
          ? _value.variable
          : variable as List<TestScriptVariable>,
      setup: setup == freezed ? _value.setup : setup as TestScriptSetup,
      test: test == freezed ? _value.test : test as List<TestScriptTest>,
      teardown: teardown == freezed
          ? _value.teardown
          : teardown as TestScriptTeardown,
    ));
  }

  @override
  $MetaCopyWith<$Res> get meta {
    if (_value.meta == null) {
      return null;
    }
    return $MetaCopyWith<$Res>(_value.meta, (value) {
      return _then(_value.copyWith(meta: value));
    });
  }

  @override
  $NarrativeCopyWith<$Res> get text {
    if (_value.text == null) {
      return null;
    }
    return $NarrativeCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }

  @override
  $IdentifierCopyWith<$Res> get identifier {
    if (_value.identifier == null) {
      return null;
    }
    return $IdentifierCopyWith<$Res>(_value.identifier, (value) {
      return _then(_value.copyWith(identifier: value));
    });
  }

  @override
  $TestScriptMetadataCopyWith<$Res> get metadata {
    if (_value.metadata == null) {
      return null;
    }
    return $TestScriptMetadataCopyWith<$Res>(_value.metadata, (value) {
      return _then(_value.copyWith(metadata: value));
    });
  }

  @override
  $TestScriptSetupCopyWith<$Res> get setup {
    if (_value.setup == null) {
      return null;
    }
    return $TestScriptSetupCopyWith<$Res>(_value.setup, (value) {
      return _then(_value.copyWith(setup: value));
    });
  }

  @override
  $TestScriptTeardownCopyWith<$Res> get teardown {
    if (_value.teardown == null) {
      return null;
    }
    return $TestScriptTeardownCopyWith<$Res>(_value.teardown, (value) {
      return _then(_value.copyWith(teardown: value));
    });
  }
}

abstract class _$TestScriptCopyWith<$Res> implements $TestScriptCopyWith<$Res> {
  factory _$TestScriptCopyWith(
          _TestScript value, $Res Function(_TestScript) then) =
      __$TestScriptCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(required: true, defaultValue: 'TestScript')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      Identifier identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
          TestScriptStatus status,
      Boolean experimental,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      List<TestScriptOrigin> origin,
      List<TestScriptDestination> destination,
      TestScriptMetadata metadata,
      List<TestScriptFixture> fixture,
      List<Reference> profile,
      List<TestScriptVariable> variable,
      TestScriptSetup setup,
      List<TestScriptTest> test,
      TestScriptTeardown teardown});

  @override
  $MetaCopyWith<$Res> get meta;
  @override
  $NarrativeCopyWith<$Res> get text;
  @override
  $IdentifierCopyWith<$Res> get identifier;
  @override
  $TestScriptMetadataCopyWith<$Res> get metadata;
  @override
  $TestScriptSetupCopyWith<$Res> get setup;
  @override
  $TestScriptTeardownCopyWith<$Res> get teardown;
}

class __$TestScriptCopyWithImpl<$Res> extends _$TestScriptCopyWithImpl<$Res>
    implements _$TestScriptCopyWith<$Res> {
  __$TestScriptCopyWithImpl(
      _TestScript _value, $Res Function(_TestScript) _then)
      : super(_value, (v) => _then(v as _TestScript));

  @override
  _TestScript get _value => super._value as _TestScript;

  @override
  $Res call({
    Object resourceType = freezed,
    Object id = freezed,
    Object meta = freezed,
    Object implicitRules = freezed,
    Object language = freezed,
    Object text = freezed,
    Object contained = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object identifier = freezed,
    Object version = freezed,
    Object name = freezed,
    Object title = freezed,
    Object status = freezed,
    Object experimental = freezed,
    Object date = freezed,
    Object publisher = freezed,
    Object contact = freezed,
    Object description = freezed,
    Object useContext = freezed,
    Object jurisdiction = freezed,
    Object purpose = freezed,
    Object copyright = freezed,
    Object origin = freezed,
    Object destination = freezed,
    Object metadata = freezed,
    Object fixture = freezed,
    Object profile = freezed,
    Object variable = freezed,
    Object setup = freezed,
    Object test = freezed,
    Object teardown = freezed,
  }) {
    return _then(_TestScript(
      resourceType: resourceType == freezed
          ? _value.resourceType
          : resourceType as String,
      id: id == freezed ? _value.id : id as Id,
      meta: meta == freezed ? _value.meta : meta as Meta,
      implicitRules: implicitRules == freezed
          ? _value.implicitRules
          : implicitRules as FhirUri,
      language: language == freezed ? _value.language : language as Code,
      text: text == freezed ? _value.text : text as Narrative,
      contained:
          contained == freezed ? _value.contained : contained as List<Resource>,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      identifier:
          identifier == freezed ? _value.identifier : identifier as Identifier,
      version: version == freezed ? _value.version : version as String,
      name: name == freezed ? _value.name : name as String,
      title: title == freezed ? _value.title : title as String,
      status: status == freezed ? _value.status : status as TestScriptStatus,
      experimental: experimental == freezed
          ? _value.experimental
          : experimental as Boolean,
      date: date == freezed ? _value.date : date as FhirDateTime,
      publisher: publisher == freezed ? _value.publisher : publisher as String,
      contact:
          contact == freezed ? _value.contact : contact as List<ContactDetail>,
      description:
          description == freezed ? _value.description : description as Markdown,
      useContext: useContext == freezed
          ? _value.useContext
          : useContext as List<UsageContext>,
      jurisdiction: jurisdiction == freezed
          ? _value.jurisdiction
          : jurisdiction as List<CodeableConcept>,
      purpose: purpose == freezed ? _value.purpose : purpose as Markdown,
      copyright:
          copyright == freezed ? _value.copyright : copyright as Markdown,
      origin:
          origin == freezed ? _value.origin : origin as List<TestScriptOrigin>,
      destination: destination == freezed
          ? _value.destination
          : destination as List<TestScriptDestination>,
      metadata: metadata == freezed
          ? _value.metadata
          : metadata as TestScriptMetadata,
      fixture: fixture == freezed
          ? _value.fixture
          : fixture as List<TestScriptFixture>,
      profile: profile == freezed ? _value.profile : profile as List<Reference>,
      variable: variable == freezed
          ? _value.variable
          : variable as List<TestScriptVariable>,
      setup: setup == freezed ? _value.setup : setup as TestScriptSetup,
      test: test == freezed ? _value.test : test as List<TestScriptTest>,
      teardown: teardown == freezed
          ? _value.teardown
          : teardown as TestScriptTeardown,
    ));
  }
}

@JsonSerializable()
class _$_TestScript implements _TestScript {
  const _$_TestScript(
      {@required
      @JsonKey(required: true, defaultValue: 'TestScript')
          this.resourceType,
      this.id,
      this.meta,
      this.implicitRules,
      this.language,
      this.text,
      this.contained,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.url,
      this.identifier,
      this.version,
      this.name,
      this.title,
      @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
          this.status,
      this.experimental,
      this.date,
      this.publisher,
      this.contact,
      this.description,
      this.useContext,
      this.jurisdiction,
      this.purpose,
      this.copyright,
      this.origin,
      this.destination,
      this.metadata,
      this.fixture,
      this.profile,
      this.variable,
      this.setup,
      this.test,
      this.teardown})
      : assert(resourceType != null);

  factory _$_TestScript.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptFromJson(json);

  @override
  @JsonKey(required: true, defaultValue: 'TestScript')
  final String resourceType;
  @override
  final Id id;
  @override
  final Meta meta;
  @override
  final FhirUri implicitRules;
  @override
  final Code language;
  @override
  final Narrative text;
  @override
  final List<Resource> contained;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final Identifier identifier;
  @override
  final String version;
  @override
  final String name;
  @override
  final String title;
  @override
  @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
  final TestScriptStatus status;
  @override
  final Boolean experimental;
  @override
  final FhirDateTime date;
  @override
  final String publisher;
  @override
  final List<ContactDetail> contact;
  @override
  final Markdown description;
  @override
  final List<UsageContext> useContext;
  @override
  final List<CodeableConcept> jurisdiction;
  @override
  final Markdown purpose;
  @override
  final Markdown copyright;
  @override
  final List<TestScriptOrigin> origin;
  @override
  final List<TestScriptDestination> destination;
  @override
  final TestScriptMetadata metadata;
  @override
  final List<TestScriptFixture> fixture;
  @override
  final List<Reference> profile;
  @override
  final List<TestScriptVariable> variable;
  @override
  final TestScriptSetup setup;
  @override
  final List<TestScriptTest> test;
  @override
  final TestScriptTeardown teardown;

  @override
  String toString() {
    return 'TestScript(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, language: $language, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, identifier: $identifier, version: $version, name: $name, title: $title, status: $status, experimental: $experimental, date: $date, publisher: $publisher, contact: $contact, description: $description, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, copyright: $copyright, origin: $origin, destination: $destination, metadata: $metadata, fixture: $fixture, profile: $profile, variable: $variable, setup: $setup, test: $test, teardown: $teardown)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScript &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.implicitRules, implicitRules) ||
                const DeepCollectionEquality()
                    .equals(other.implicitRules, implicitRules)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.contained, contained) ||
                const DeepCollectionEquality()
                    .equals(other.contained, contained)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.experimental, experimental) ||
                const DeepCollectionEquality()
                    .equals(other.experimental, experimental)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.contact, contact) ||
                const DeepCollectionEquality()
                    .equals(other.contact, contact)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.useContext, useContext) ||
                const DeepCollectionEquality()
                    .equals(other.useContext, useContext)) &&
            (identical(other.jurisdiction, jurisdiction) ||
                const DeepCollectionEquality()
                    .equals(other.jurisdiction, jurisdiction)) &&
            (identical(other.purpose, purpose) ||
                const DeepCollectionEquality()
                    .equals(other.purpose, purpose)) &&
            (identical(other.copyright, copyright) ||
                const DeepCollectionEquality()
                    .equals(other.copyright, copyright)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)) &&
            (identical(other.destination, destination) ||
                const DeepCollectionEquality()
                    .equals(other.destination, destination)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.fixture, fixture) || const DeepCollectionEquality().equals(other.fixture, fixture)) &&
            (identical(other.profile, profile) || const DeepCollectionEquality().equals(other.profile, profile)) &&
            (identical(other.variable, variable) || const DeepCollectionEquality().equals(other.variable, variable)) &&
            (identical(other.setup, setup) || const DeepCollectionEquality().equals(other.setup, setup)) &&
            (identical(other.test, test) || const DeepCollectionEquality().equals(other.test, test)) &&
            (identical(other.teardown, teardown) || const DeepCollectionEquality().equals(other.teardown, teardown)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(implicitRules) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(contained) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(experimental) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(contact) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(useContext) ^
      const DeepCollectionEquality().hash(jurisdiction) ^
      const DeepCollectionEquality().hash(purpose) ^
      const DeepCollectionEquality().hash(copyright) ^
      const DeepCollectionEquality().hash(origin) ^
      const DeepCollectionEquality().hash(destination) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(fixture) ^
      const DeepCollectionEquality().hash(profile) ^
      const DeepCollectionEquality().hash(variable) ^
      const DeepCollectionEquality().hash(setup) ^
      const DeepCollectionEquality().hash(test) ^
      const DeepCollectionEquality().hash(teardown);

  @override
  _$TestScriptCopyWith<_TestScript> get copyWith =>
      __$TestScriptCopyWithImpl<_TestScript>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptToJson(this);
  }
}

abstract class _TestScript implements TestScript {
  const factory _TestScript(
      {@required
      @JsonKey(required: true, defaultValue: 'TestScript')
          String resourceType,
      Id id,
      Meta meta,
      FhirUri implicitRules,
      Code language,
      Narrative text,
      List<Resource> contained,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      Identifier identifier,
      String version,
      String name,
      String title,
      @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
          TestScriptStatus status,
      Boolean experimental,
      FhirDateTime date,
      String publisher,
      List<ContactDetail> contact,
      Markdown description,
      List<UsageContext> useContext,
      List<CodeableConcept> jurisdiction,
      Markdown purpose,
      Markdown copyright,
      List<TestScriptOrigin> origin,
      List<TestScriptDestination> destination,
      TestScriptMetadata metadata,
      List<TestScriptFixture> fixture,
      List<Reference> profile,
      List<TestScriptVariable> variable,
      TestScriptSetup setup,
      List<TestScriptTest> test,
      TestScriptTeardown teardown}) = _$_TestScript;

  factory _TestScript.fromJson(Map<String, dynamic> json) =
      _$_TestScript.fromJson;

  @override
  @JsonKey(required: true, defaultValue: 'TestScript')
  String get resourceType;
  @override
  Id get id;
  @override
  Meta get meta;
  @override
  FhirUri get implicitRules;
  @override
  Code get language;
  @override
  Narrative get text;
  @override
  List<Resource> get contained;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  Identifier get identifier;
  @override
  String get version;
  @override
  String get name;
  @override
  String get title;
  @override
  @JsonKey(unknownEnumValue: TestScriptStatus.unknown)
  TestScriptStatus get status;
  @override
  Boolean get experimental;
  @override
  FhirDateTime get date;
  @override
  String get publisher;
  @override
  List<ContactDetail> get contact;
  @override
  Markdown get description;
  @override
  List<UsageContext> get useContext;
  @override
  List<CodeableConcept> get jurisdiction;
  @override
  Markdown get purpose;
  @override
  Markdown get copyright;
  @override
  List<TestScriptOrigin> get origin;
  @override
  List<TestScriptDestination> get destination;
  @override
  TestScriptMetadata get metadata;
  @override
  List<TestScriptFixture> get fixture;
  @override
  List<Reference> get profile;
  @override
  List<TestScriptVariable> get variable;
  @override
  TestScriptSetup get setup;
  @override
  List<TestScriptTest> get test;
  @override
  TestScriptTeardown get teardown;
  @override
  _$TestScriptCopyWith<_TestScript> get copyWith;
}

TestScriptOrigin _$TestScriptOriginFromJson(Map<String, dynamic> json) {
  return _TestScriptOrigin.fromJson(json);
}

class _$TestScriptOriginTearOff {
  const _$TestScriptOriginTearOff();

  _TestScriptOrigin call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @required @JsonKey(required: true) Coding profile}) {
    return _TestScriptOrigin(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      index: index,
      profile: profile,
    );
  }
}

// ignore: unused_element
const $TestScriptOrigin = _$TestScriptOriginTearOff();

mixin _$TestScriptOrigin {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get index;
  @JsonKey(required: true)
  Coding get profile;

  Map<String, dynamic> toJson();
  $TestScriptOriginCopyWith<TestScriptOrigin> get copyWith;
}

abstract class $TestScriptOriginCopyWith<$Res> {
  factory $TestScriptOriginCopyWith(
          TestScriptOrigin value, $Res Function(TestScriptOrigin) then) =
      _$TestScriptOriginCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @JsonKey(required: true) Coding profile});

  $CodingCopyWith<$Res> get profile;
}

class _$TestScriptOriginCopyWithImpl<$Res>
    implements $TestScriptOriginCopyWith<$Res> {
  _$TestScriptOriginCopyWithImpl(this._value, this._then);

  final TestScriptOrigin _value;
  // ignore: unused_field
  final $Res Function(TestScriptOrigin) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object index = freezed,
    Object profile = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      index: index == freezed ? _value.index : index as Integer,
      profile: profile == freezed ? _value.profile : profile as Coding,
    ));
  }

  @override
  $CodingCopyWith<$Res> get profile {
    if (_value.profile == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.profile, (value) {
      return _then(_value.copyWith(profile: value));
    });
  }
}

abstract class _$TestScriptOriginCopyWith<$Res>
    implements $TestScriptOriginCopyWith<$Res> {
  factory _$TestScriptOriginCopyWith(
          _TestScriptOrigin value, $Res Function(_TestScriptOrigin) then) =
      __$TestScriptOriginCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @JsonKey(required: true) Coding profile});

  @override
  $CodingCopyWith<$Res> get profile;
}

class __$TestScriptOriginCopyWithImpl<$Res>
    extends _$TestScriptOriginCopyWithImpl<$Res>
    implements _$TestScriptOriginCopyWith<$Res> {
  __$TestScriptOriginCopyWithImpl(
      _TestScriptOrigin _value, $Res Function(_TestScriptOrigin) _then)
      : super(_value, (v) => _then(v as _TestScriptOrigin));

  @override
  _TestScriptOrigin get _value => super._value as _TestScriptOrigin;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object index = freezed,
    Object profile = freezed,
  }) {
    return _then(_TestScriptOrigin(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      index: index == freezed ? _value.index : index as Integer,
      profile: profile == freezed ? _value.profile : profile as Coding,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptOrigin implements _TestScriptOrigin {
  const _$_TestScriptOrigin(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.index,
      @required @JsonKey(required: true) this.profile})
      : assert(profile != null);

  factory _$_TestScriptOrigin.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptOriginFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer index;
  @override
  @JsonKey(required: true)
  final Coding profile;

  @override
  String toString() {
    return 'TestScriptOrigin(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, index: $index, profile: $profile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptOrigin &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(profile);

  @override
  _$TestScriptOriginCopyWith<_TestScriptOrigin> get copyWith =>
      __$TestScriptOriginCopyWithImpl<_TestScriptOrigin>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptOriginToJson(this);
  }
}

abstract class _TestScriptOrigin implements TestScriptOrigin {
  const factory _TestScriptOrigin(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @required @JsonKey(required: true) Coding profile}) = _$_TestScriptOrigin;

  factory _TestScriptOrigin.fromJson(Map<String, dynamic> json) =
      _$_TestScriptOrigin.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get index;
  @override
  @JsonKey(required: true)
  Coding get profile;
  @override
  _$TestScriptOriginCopyWith<_TestScriptOrigin> get copyWith;
}

TestScriptDestination _$TestScriptDestinationFromJson(
    Map<String, dynamic> json) {
  return _TestScriptDestination.fromJson(json);
}

class _$TestScriptDestinationTearOff {
  const _$TestScriptDestinationTearOff();

  _TestScriptDestination call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @required @JsonKey(required: true) Coding profile}) {
    return _TestScriptDestination(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      index: index,
      profile: profile,
    );
  }
}

// ignore: unused_element
const $TestScriptDestination = _$TestScriptDestinationTearOff();

mixin _$TestScriptDestination {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Integer get index;
  @JsonKey(required: true)
  Coding get profile;

  Map<String, dynamic> toJson();
  $TestScriptDestinationCopyWith<TestScriptDestination> get copyWith;
}

abstract class $TestScriptDestinationCopyWith<$Res> {
  factory $TestScriptDestinationCopyWith(TestScriptDestination value,
          $Res Function(TestScriptDestination) then) =
      _$TestScriptDestinationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @JsonKey(required: true) Coding profile});

  $CodingCopyWith<$Res> get profile;
}

class _$TestScriptDestinationCopyWithImpl<$Res>
    implements $TestScriptDestinationCopyWith<$Res> {
  _$TestScriptDestinationCopyWithImpl(this._value, this._then);

  final TestScriptDestination _value;
  // ignore: unused_field
  final $Res Function(TestScriptDestination) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object index = freezed,
    Object profile = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      index: index == freezed ? _value.index : index as Integer,
      profile: profile == freezed ? _value.profile : profile as Coding,
    ));
  }

  @override
  $CodingCopyWith<$Res> get profile {
    if (_value.profile == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.profile, (value) {
      return _then(_value.copyWith(profile: value));
    });
  }
}

abstract class _$TestScriptDestinationCopyWith<$Res>
    implements $TestScriptDestinationCopyWith<$Res> {
  factory _$TestScriptDestinationCopyWith(_TestScriptDestination value,
          $Res Function(_TestScriptDestination) then) =
      __$TestScriptDestinationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Integer index,
      @JsonKey(required: true) Coding profile});

  @override
  $CodingCopyWith<$Res> get profile;
}

class __$TestScriptDestinationCopyWithImpl<$Res>
    extends _$TestScriptDestinationCopyWithImpl<$Res>
    implements _$TestScriptDestinationCopyWith<$Res> {
  __$TestScriptDestinationCopyWithImpl(_TestScriptDestination _value,
      $Res Function(_TestScriptDestination) _then)
      : super(_value, (v) => _then(v as _TestScriptDestination));

  @override
  _TestScriptDestination get _value => super._value as _TestScriptDestination;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object index = freezed,
    Object profile = freezed,
  }) {
    return _then(_TestScriptDestination(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      index: index == freezed ? _value.index : index as Integer,
      profile: profile == freezed ? _value.profile : profile as Coding,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptDestination implements _TestScriptDestination {
  const _$_TestScriptDestination(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.index,
      @required @JsonKey(required: true) this.profile})
      : assert(profile != null);

  factory _$_TestScriptDestination.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptDestinationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Integer index;
  @override
  @JsonKey(required: true)
  final Coding profile;

  @override
  String toString() {
    return 'TestScriptDestination(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, index: $index, profile: $profile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptDestination &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.index, index) ||
                const DeepCollectionEquality().equals(other.index, index)) &&
            (identical(other.profile, profile) ||
                const DeepCollectionEquality().equals(other.profile, profile)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(index) ^
      const DeepCollectionEquality().hash(profile);

  @override
  _$TestScriptDestinationCopyWith<_TestScriptDestination> get copyWith =>
      __$TestScriptDestinationCopyWithImpl<_TestScriptDestination>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptDestinationToJson(this);
  }
}

abstract class _TestScriptDestination implements TestScriptDestination {
  const factory _TestScriptDestination(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          Integer index,
          @required @JsonKey(required: true) Coding profile}) =
      _$_TestScriptDestination;

  factory _TestScriptDestination.fromJson(Map<String, dynamic> json) =
      _$_TestScriptDestination.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Integer get index;
  @override
  @JsonKey(required: true)
  Coding get profile;
  @override
  _$TestScriptDestinationCopyWith<_TestScriptDestination> get copyWith;
}

TestScriptMetadata _$TestScriptMetadataFromJson(Map<String, dynamic> json) {
  return _TestScriptMetadata.fromJson(json);
}

class _$TestScriptMetadataTearOff {
  const _$TestScriptMetadataTearOff();

  _TestScriptMetadata call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<TestScriptLink> link,
      @required
      @JsonKey(required: true)
          List<TestScriptCapability> capability}) {
    return _TestScriptMetadata(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      link: link,
      capability: capability,
    );
  }
}

// ignore: unused_element
const $TestScriptMetadata = _$TestScriptMetadataTearOff();

mixin _$TestScriptMetadata {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  List<TestScriptLink> get link;
  @JsonKey(required: true)
  List<TestScriptCapability> get capability;

  Map<String, dynamic> toJson();
  $TestScriptMetadataCopyWith<TestScriptMetadata> get copyWith;
}

abstract class $TestScriptMetadataCopyWith<$Res> {
  factory $TestScriptMetadataCopyWith(
          TestScriptMetadata value, $Res Function(TestScriptMetadata) then) =
      _$TestScriptMetadataCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<TestScriptLink> link,
      @JsonKey(required: true) List<TestScriptCapability> capability});
}

class _$TestScriptMetadataCopyWithImpl<$Res>
    implements $TestScriptMetadataCopyWith<$Res> {
  _$TestScriptMetadataCopyWithImpl(this._value, this._then);

  final TestScriptMetadata _value;
  // ignore: unused_field
  final $Res Function(TestScriptMetadata) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object link = freezed,
    Object capability = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      link: link == freezed ? _value.link : link as List<TestScriptLink>,
      capability: capability == freezed
          ? _value.capability
          : capability as List<TestScriptCapability>,
    ));
  }
}

abstract class _$TestScriptMetadataCopyWith<$Res>
    implements $TestScriptMetadataCopyWith<$Res> {
  factory _$TestScriptMetadataCopyWith(
          _TestScriptMetadata value, $Res Function(_TestScriptMetadata) then) =
      __$TestScriptMetadataCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<TestScriptLink> link,
      @JsonKey(required: true) List<TestScriptCapability> capability});
}

class __$TestScriptMetadataCopyWithImpl<$Res>
    extends _$TestScriptMetadataCopyWithImpl<$Res>
    implements _$TestScriptMetadataCopyWith<$Res> {
  __$TestScriptMetadataCopyWithImpl(
      _TestScriptMetadata _value, $Res Function(_TestScriptMetadata) _then)
      : super(_value, (v) => _then(v as _TestScriptMetadata));

  @override
  _TestScriptMetadata get _value => super._value as _TestScriptMetadata;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object link = freezed,
    Object capability = freezed,
  }) {
    return _then(_TestScriptMetadata(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      link: link == freezed ? _value.link : link as List<TestScriptLink>,
      capability: capability == freezed
          ? _value.capability
          : capability as List<TestScriptCapability>,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptMetadata implements _TestScriptMetadata {
  const _$_TestScriptMetadata(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.link,
      @required @JsonKey(required: true) this.capability})
      : assert(capability != null);

  factory _$_TestScriptMetadata.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptMetadataFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final List<TestScriptLink> link;
  @override
  @JsonKey(required: true)
  final List<TestScriptCapability> capability;

  @override
  String toString() {
    return 'TestScriptMetadata(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, link: $link, capability: $capability)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptMetadata &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.link, link) ||
                const DeepCollectionEquality().equals(other.link, link)) &&
            (identical(other.capability, capability) ||
                const DeepCollectionEquality()
                    .equals(other.capability, capability)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(link) ^
      const DeepCollectionEquality().hash(capability);

  @override
  _$TestScriptMetadataCopyWith<_TestScriptMetadata> get copyWith =>
      __$TestScriptMetadataCopyWithImpl<_TestScriptMetadata>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptMetadataToJson(this);
  }
}

abstract class _TestScriptMetadata implements TestScriptMetadata {
  const factory _TestScriptMetadata(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      List<TestScriptLink> link,
      @required
      @JsonKey(required: true)
          List<TestScriptCapability> capability}) = _$_TestScriptMetadata;

  factory _TestScriptMetadata.fromJson(Map<String, dynamic> json) =
      _$_TestScriptMetadata.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  List<TestScriptLink> get link;
  @override
  @JsonKey(required: true)
  List<TestScriptCapability> get capability;
  @override
  _$TestScriptMetadataCopyWith<_TestScriptMetadata> get copyWith;
}

TestScriptLink _$TestScriptLinkFromJson(Map<String, dynamic> json) {
  return _TestScriptLink.fromJson(json);
}

class _$TestScriptLinkTearOff {
  const _$TestScriptLinkTearOff();

  _TestScriptLink call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      String description}) {
    return _TestScriptLink(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      url: url,
      description: description,
    );
  }
}

// ignore: unused_element
const $TestScriptLink = _$TestScriptLinkTearOff();

mixin _$TestScriptLink {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  FhirUri get url;
  String get description;

  Map<String, dynamic> toJson();
  $TestScriptLinkCopyWith<TestScriptLink> get copyWith;
}

abstract class $TestScriptLinkCopyWith<$Res> {
  factory $TestScriptLinkCopyWith(
          TestScriptLink value, $Res Function(TestScriptLink) then) =
      _$TestScriptLinkCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      String description});
}

class _$TestScriptLinkCopyWithImpl<$Res>
    implements $TestScriptLinkCopyWith<$Res> {
  _$TestScriptLinkCopyWithImpl(this._value, this._then);

  final TestScriptLink _value;
  // ignore: unused_field
  final $Res Function(TestScriptLink) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object description = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      description:
          description == freezed ? _value.description : description as String,
    ));
  }
}

abstract class _$TestScriptLinkCopyWith<$Res>
    implements $TestScriptLinkCopyWith<$Res> {
  factory _$TestScriptLinkCopyWith(
          _TestScriptLink value, $Res Function(_TestScriptLink) then) =
      __$TestScriptLinkCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      String description});
}

class __$TestScriptLinkCopyWithImpl<$Res>
    extends _$TestScriptLinkCopyWithImpl<$Res>
    implements _$TestScriptLinkCopyWith<$Res> {
  __$TestScriptLinkCopyWithImpl(
      _TestScriptLink _value, $Res Function(_TestScriptLink) _then)
      : super(_value, (v) => _then(v as _TestScriptLink));

  @override
  _TestScriptLink get _value => super._value as _TestScriptLink;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object url = freezed,
    Object description = freezed,
  }) {
    return _then(_TestScriptLink(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      url: url == freezed ? _value.url : url as FhirUri,
      description:
          description == freezed ? _value.description : description as String,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptLink implements _TestScriptLink {
  const _$_TestScriptLink(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.url,
      this.description});

  factory _$_TestScriptLink.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptLinkFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final FhirUri url;
  @override
  final String description;

  @override
  String toString() {
    return 'TestScriptLink(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptLink &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(description);

  @override
  _$TestScriptLinkCopyWith<_TestScriptLink> get copyWith =>
      __$TestScriptLinkCopyWithImpl<_TestScriptLink>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptLinkToJson(this);
  }
}

abstract class _TestScriptLink implements TestScriptLink {
  const factory _TestScriptLink(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      FhirUri url,
      String description}) = _$_TestScriptLink;

  factory _TestScriptLink.fromJson(Map<String, dynamic> json) =
      _$_TestScriptLink.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  FhirUri get url;
  @override
  String get description;
  @override
  _$TestScriptLinkCopyWith<_TestScriptLink> get copyWith;
}

TestScriptCapability _$TestScriptCapabilityFromJson(Map<String, dynamic> json) {
  return _TestScriptCapability.fromJson(json);
}

class _$TestScriptCapabilityTearOff {
  const _$TestScriptCapabilityTearOff();

  _TestScriptCapability call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'required') Boolean required_,
      Boolean validated,
      String description,
      List<Integer> origin,
      Integer destination,
      List<FhirUri> link,
      @required @JsonKey(required: true) Canonical capabilities}) {
    return _TestScriptCapability(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      required_: required_,
      validated: validated,
      description: description,
      origin: origin,
      destination: destination,
      link: link,
      capabilities: capabilities,
    );
  }
}

// ignore: unused_element
const $TestScriptCapability = _$TestScriptCapabilityTearOff();

mixin _$TestScriptCapability {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(name: 'required')
  Boolean get required_;
  Boolean get validated;
  String get description;
  List<Integer> get origin;
  Integer get destination;
  List<FhirUri> get link;
  @JsonKey(required: true)
  Canonical get capabilities;

  Map<String, dynamic> toJson();
  $TestScriptCapabilityCopyWith<TestScriptCapability> get copyWith;
}

abstract class $TestScriptCapabilityCopyWith<$Res> {
  factory $TestScriptCapabilityCopyWith(TestScriptCapability value,
          $Res Function(TestScriptCapability) then) =
      _$TestScriptCapabilityCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'required') Boolean required_,
      Boolean validated,
      String description,
      List<Integer> origin,
      Integer destination,
      List<FhirUri> link,
      @JsonKey(required: true) Canonical capabilities});
}

class _$TestScriptCapabilityCopyWithImpl<$Res>
    implements $TestScriptCapabilityCopyWith<$Res> {
  _$TestScriptCapabilityCopyWithImpl(this._value, this._then);

  final TestScriptCapability _value;
  // ignore: unused_field
  final $Res Function(TestScriptCapability) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object required_ = freezed,
    Object validated = freezed,
    Object description = freezed,
    Object origin = freezed,
    Object destination = freezed,
    Object link = freezed,
    Object capabilities = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      required_: required_ == freezed ? _value.required_ : required_ as Boolean,
      validated: validated == freezed ? _value.validated : validated as Boolean,
      description:
          description == freezed ? _value.description : description as String,
      origin: origin == freezed ? _value.origin : origin as List<Integer>,
      destination:
          destination == freezed ? _value.destination : destination as Integer,
      link: link == freezed ? _value.link : link as List<FhirUri>,
      capabilities: capabilities == freezed
          ? _value.capabilities
          : capabilities as Canonical,
    ));
  }
}

abstract class _$TestScriptCapabilityCopyWith<$Res>
    implements $TestScriptCapabilityCopyWith<$Res> {
  factory _$TestScriptCapabilityCopyWith(_TestScriptCapability value,
          $Res Function(_TestScriptCapability) then) =
      __$TestScriptCapabilityCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(name: 'required') Boolean required_,
      Boolean validated,
      String description,
      List<Integer> origin,
      Integer destination,
      List<FhirUri> link,
      @JsonKey(required: true) Canonical capabilities});
}

class __$TestScriptCapabilityCopyWithImpl<$Res>
    extends _$TestScriptCapabilityCopyWithImpl<$Res>
    implements _$TestScriptCapabilityCopyWith<$Res> {
  __$TestScriptCapabilityCopyWithImpl(
      _TestScriptCapability _value, $Res Function(_TestScriptCapability) _then)
      : super(_value, (v) => _then(v as _TestScriptCapability));

  @override
  _TestScriptCapability get _value => super._value as _TestScriptCapability;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object required_ = freezed,
    Object validated = freezed,
    Object description = freezed,
    Object origin = freezed,
    Object destination = freezed,
    Object link = freezed,
    Object capabilities = freezed,
  }) {
    return _then(_TestScriptCapability(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      required_: required_ == freezed ? _value.required_ : required_ as Boolean,
      validated: validated == freezed ? _value.validated : validated as Boolean,
      description:
          description == freezed ? _value.description : description as String,
      origin: origin == freezed ? _value.origin : origin as List<Integer>,
      destination:
          destination == freezed ? _value.destination : destination as Integer,
      link: link == freezed ? _value.link : link as List<FhirUri>,
      capabilities: capabilities == freezed
          ? _value.capabilities
          : capabilities as Canonical,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptCapability implements _TestScriptCapability {
  const _$_TestScriptCapability(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @JsonKey(name: 'required') this.required_,
      this.validated,
      this.description,
      this.origin,
      this.destination,
      this.link,
      @required @JsonKey(required: true) this.capabilities})
      : assert(capabilities != null);

  factory _$_TestScriptCapability.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptCapabilityFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(name: 'required')
  final Boolean required_;
  @override
  final Boolean validated;
  @override
  final String description;
  @override
  final List<Integer> origin;
  @override
  final Integer destination;
  @override
  final List<FhirUri> link;
  @override
  @JsonKey(required: true)
  final Canonical capabilities;

  @override
  String toString() {
    return 'TestScriptCapability(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, required_: $required_, validated: $validated, description: $description, origin: $origin, destination: $destination, link: $link, capabilities: $capabilities)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptCapability &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.required_, required_) ||
                const DeepCollectionEquality()
                    .equals(other.required_, required_)) &&
            (identical(other.validated, validated) ||
                const DeepCollectionEquality()
                    .equals(other.validated, validated)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)) &&
            (identical(other.destination, destination) ||
                const DeepCollectionEquality()
                    .equals(other.destination, destination)) &&
            (identical(other.link, link) ||
                const DeepCollectionEquality().equals(other.link, link)) &&
            (identical(other.capabilities, capabilities) ||
                const DeepCollectionEquality()
                    .equals(other.capabilities, capabilities)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(required_) ^
      const DeepCollectionEquality().hash(validated) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(origin) ^
      const DeepCollectionEquality().hash(destination) ^
      const DeepCollectionEquality().hash(link) ^
      const DeepCollectionEquality().hash(capabilities);

  @override
  _$TestScriptCapabilityCopyWith<_TestScriptCapability> get copyWith =>
      __$TestScriptCapabilityCopyWithImpl<_TestScriptCapability>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptCapabilityToJson(this);
  }
}

abstract class _TestScriptCapability implements TestScriptCapability {
  const factory _TestScriptCapability(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @JsonKey(name: 'required') Boolean required_,
          Boolean validated,
          String description,
          List<Integer> origin,
          Integer destination,
          List<FhirUri> link,
          @required @JsonKey(required: true) Canonical capabilities}) =
      _$_TestScriptCapability;

  factory _TestScriptCapability.fromJson(Map<String, dynamic> json) =
      _$_TestScriptCapability.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(name: 'required')
  Boolean get required_;
  @override
  Boolean get validated;
  @override
  String get description;
  @override
  List<Integer> get origin;
  @override
  Integer get destination;
  @override
  List<FhirUri> get link;
  @override
  @JsonKey(required: true)
  Canonical get capabilities;
  @override
  _$TestScriptCapabilityCopyWith<_TestScriptCapability> get copyWith;
}

TestScriptFixture _$TestScriptFixtureFromJson(Map<String, dynamic> json) {
  return _TestScriptFixture.fromJson(json);
}

class _$TestScriptFixtureTearOff {
  const _$TestScriptFixtureTearOff();

  _TestScriptFixture call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean autocreate,
      Boolean autodelete,
      Reference resource}) {
    return _TestScriptFixture(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      autocreate: autocreate,
      autodelete: autodelete,
      resource: resource,
    );
  }
}

// ignore: unused_element
const $TestScriptFixture = _$TestScriptFixtureTearOff();

mixin _$TestScriptFixture {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Boolean get autocreate;
  Boolean get autodelete;
  Reference get resource;

  Map<String, dynamic> toJson();
  $TestScriptFixtureCopyWith<TestScriptFixture> get copyWith;
}

abstract class $TestScriptFixtureCopyWith<$Res> {
  factory $TestScriptFixtureCopyWith(
          TestScriptFixture value, $Res Function(TestScriptFixture) then) =
      _$TestScriptFixtureCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean autocreate,
      Boolean autodelete,
      Reference resource});

  $ReferenceCopyWith<$Res> get resource;
}

class _$TestScriptFixtureCopyWithImpl<$Res>
    implements $TestScriptFixtureCopyWith<$Res> {
  _$TestScriptFixtureCopyWithImpl(this._value, this._then);

  final TestScriptFixture _value;
  // ignore: unused_field
  final $Res Function(TestScriptFixture) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object autocreate = freezed,
    Object autodelete = freezed,
    Object resource = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      autocreate:
          autocreate == freezed ? _value.autocreate : autocreate as Boolean,
      autodelete:
          autodelete == freezed ? _value.autodelete : autodelete as Boolean,
      resource: resource == freezed ? _value.resource : resource as Reference,
    ));
  }

  @override
  $ReferenceCopyWith<$Res> get resource {
    if (_value.resource == null) {
      return null;
    }
    return $ReferenceCopyWith<$Res>(_value.resource, (value) {
      return _then(_value.copyWith(resource: value));
    });
  }
}

abstract class _$TestScriptFixtureCopyWith<$Res>
    implements $TestScriptFixtureCopyWith<$Res> {
  factory _$TestScriptFixtureCopyWith(
          _TestScriptFixture value, $Res Function(_TestScriptFixture) then) =
      __$TestScriptFixtureCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean autocreate,
      Boolean autodelete,
      Reference resource});

  @override
  $ReferenceCopyWith<$Res> get resource;
}

class __$TestScriptFixtureCopyWithImpl<$Res>
    extends _$TestScriptFixtureCopyWithImpl<$Res>
    implements _$TestScriptFixtureCopyWith<$Res> {
  __$TestScriptFixtureCopyWithImpl(
      _TestScriptFixture _value, $Res Function(_TestScriptFixture) _then)
      : super(_value, (v) => _then(v as _TestScriptFixture));

  @override
  _TestScriptFixture get _value => super._value as _TestScriptFixture;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object autocreate = freezed,
    Object autodelete = freezed,
    Object resource = freezed,
  }) {
    return _then(_TestScriptFixture(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      autocreate:
          autocreate == freezed ? _value.autocreate : autocreate as Boolean,
      autodelete:
          autodelete == freezed ? _value.autodelete : autodelete as Boolean,
      resource: resource == freezed ? _value.resource : resource as Reference,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptFixture implements _TestScriptFixture {
  const _$_TestScriptFixture(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.autocreate,
      this.autodelete,
      this.resource});

  factory _$_TestScriptFixture.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptFixtureFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Boolean autocreate;
  @override
  final Boolean autodelete;
  @override
  final Reference resource;

  @override
  String toString() {
    return 'TestScriptFixture(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, autocreate: $autocreate, autodelete: $autodelete, resource: $resource)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptFixture &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.autocreate, autocreate) ||
                const DeepCollectionEquality()
                    .equals(other.autocreate, autocreate)) &&
            (identical(other.autodelete, autodelete) ||
                const DeepCollectionEquality()
                    .equals(other.autodelete, autodelete)) &&
            (identical(other.resource, resource) ||
                const DeepCollectionEquality()
                    .equals(other.resource, resource)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(autocreate) ^
      const DeepCollectionEquality().hash(autodelete) ^
      const DeepCollectionEquality().hash(resource);

  @override
  _$TestScriptFixtureCopyWith<_TestScriptFixture> get copyWith =>
      __$TestScriptFixtureCopyWithImpl<_TestScriptFixture>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptFixtureToJson(this);
  }
}

abstract class _TestScriptFixture implements TestScriptFixture {
  const factory _TestScriptFixture(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Boolean autocreate,
      Boolean autodelete,
      Reference resource}) = _$_TestScriptFixture;

  factory _TestScriptFixture.fromJson(Map<String, dynamic> json) =
      _$_TestScriptFixture.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Boolean get autocreate;
  @override
  Boolean get autodelete;
  @override
  Reference get resource;
  @override
  _$TestScriptFixtureCopyWith<_TestScriptFixture> get copyWith;
}

TestScriptVariable _$TestScriptVariableFromJson(Map<String, dynamic> json) {
  return _TestScriptVariable.fromJson(json);
}

class _$TestScriptVariableTearOff {
  const _$TestScriptVariableTearOff();

  _TestScriptVariable call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String defaultValue,
      String description,
      String expression,
      String headerField,
      String hint,
      String path,
      Id sourceId}) {
    return _TestScriptVariable(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      defaultValue: defaultValue,
      description: description,
      expression: expression,
      headerField: headerField,
      hint: hint,
      path: path,
      sourceId: sourceId,
    );
  }
}

// ignore: unused_element
const $TestScriptVariable = _$TestScriptVariableTearOff();

mixin _$TestScriptVariable {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  String get defaultValue;
  String get description;
  String get expression;
  String get headerField;
  String get hint;
  String get path;
  Id get sourceId;

  Map<String, dynamic> toJson();
  $TestScriptVariableCopyWith<TestScriptVariable> get copyWith;
}

abstract class $TestScriptVariableCopyWith<$Res> {
  factory $TestScriptVariableCopyWith(
          TestScriptVariable value, $Res Function(TestScriptVariable) then) =
      _$TestScriptVariableCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String defaultValue,
      String description,
      String expression,
      String headerField,
      String hint,
      String path,
      Id sourceId});
}

class _$TestScriptVariableCopyWithImpl<$Res>
    implements $TestScriptVariableCopyWith<$Res> {
  _$TestScriptVariableCopyWithImpl(this._value, this._then);

  final TestScriptVariable _value;
  // ignore: unused_field
  final $Res Function(TestScriptVariable) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object defaultValue = freezed,
    Object description = freezed,
    Object expression = freezed,
    Object headerField = freezed,
    Object hint = freezed,
    Object path = freezed,
    Object sourceId = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue as String,
      description:
          description == freezed ? _value.description : description as String,
      expression:
          expression == freezed ? _value.expression : expression as String,
      headerField:
          headerField == freezed ? _value.headerField : headerField as String,
      hint: hint == freezed ? _value.hint : hint as String,
      path: path == freezed ? _value.path : path as String,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
    ));
  }
}

abstract class _$TestScriptVariableCopyWith<$Res>
    implements $TestScriptVariableCopyWith<$Res> {
  factory _$TestScriptVariableCopyWith(
          _TestScriptVariable value, $Res Function(_TestScriptVariable) then) =
      __$TestScriptVariableCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String defaultValue,
      String description,
      String expression,
      String headerField,
      String hint,
      String path,
      Id sourceId});
}

class __$TestScriptVariableCopyWithImpl<$Res>
    extends _$TestScriptVariableCopyWithImpl<$Res>
    implements _$TestScriptVariableCopyWith<$Res> {
  __$TestScriptVariableCopyWithImpl(
      _TestScriptVariable _value, $Res Function(_TestScriptVariable) _then)
      : super(_value, (v) => _then(v as _TestScriptVariable));

  @override
  _TestScriptVariable get _value => super._value as _TestScriptVariable;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object defaultValue = freezed,
    Object description = freezed,
    Object expression = freezed,
    Object headerField = freezed,
    Object hint = freezed,
    Object path = freezed,
    Object sourceId = freezed,
  }) {
    return _then(_TestScriptVariable(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue as String,
      description:
          description == freezed ? _value.description : description as String,
      expression:
          expression == freezed ? _value.expression : expression as String,
      headerField:
          headerField == freezed ? _value.headerField : headerField as String,
      hint: hint == freezed ? _value.hint : hint as String,
      path: path == freezed ? _value.path : path as String,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptVariable implements _TestScriptVariable {
  const _$_TestScriptVariable(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.defaultValue,
      this.description,
      this.expression,
      this.headerField,
      this.hint,
      this.path,
      this.sourceId});

  factory _$_TestScriptVariable.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptVariableFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final String defaultValue;
  @override
  final String description;
  @override
  final String expression;
  @override
  final String headerField;
  @override
  final String hint;
  @override
  final String path;
  @override
  final Id sourceId;

  @override
  String toString() {
    return 'TestScriptVariable(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, defaultValue: $defaultValue, description: $description, expression: $expression, headerField: $headerField, hint: $hint, path: $path, sourceId: $sourceId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptVariable &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultValue, defaultValue) ||
                const DeepCollectionEquality()
                    .equals(other.defaultValue, defaultValue)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.expression, expression) ||
                const DeepCollectionEquality()
                    .equals(other.expression, expression)) &&
            (identical(other.headerField, headerField) ||
                const DeepCollectionEquality()
                    .equals(other.headerField, headerField)) &&
            (identical(other.hint, hint) ||
                const DeepCollectionEquality().equals(other.hint, hint)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.sourceId, sourceId) ||
                const DeepCollectionEquality()
                    .equals(other.sourceId, sourceId)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultValue) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(expression) ^
      const DeepCollectionEquality().hash(headerField) ^
      const DeepCollectionEquality().hash(hint) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(sourceId);

  @override
  _$TestScriptVariableCopyWith<_TestScriptVariable> get copyWith =>
      __$TestScriptVariableCopyWithImpl<_TestScriptVariable>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptVariableToJson(this);
  }
}

abstract class _TestScriptVariable implements TestScriptVariable {
  const factory _TestScriptVariable(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String defaultValue,
      String description,
      String expression,
      String headerField,
      String hint,
      String path,
      Id sourceId}) = _$_TestScriptVariable;

  factory _TestScriptVariable.fromJson(Map<String, dynamic> json) =
      _$_TestScriptVariable.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  String get defaultValue;
  @override
  String get description;
  @override
  String get expression;
  @override
  String get headerField;
  @override
  String get hint;
  @override
  String get path;
  @override
  Id get sourceId;
  @override
  _$TestScriptVariableCopyWith<_TestScriptVariable> get copyWith;
}

TestScriptSetup _$TestScriptSetupFromJson(Map<String, dynamic> json) {
  return _TestScriptSetup.fromJson(json);
}

class _$TestScriptSetupTearOff {
  const _$TestScriptSetupTearOff();

  _TestScriptSetup call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) List<TestScriptAction> action}) {
    return _TestScriptSetup(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestScriptSetup = _$TestScriptSetupTearOff();

mixin _$TestScriptSetup {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  List<TestScriptAction> get action;

  Map<String, dynamic> toJson();
  $TestScriptSetupCopyWith<TestScriptSetup> get copyWith;
}

abstract class $TestScriptSetupCopyWith<$Res> {
  factory $TestScriptSetupCopyWith(
          TestScriptSetup value, $Res Function(TestScriptSetup) then) =
      _$TestScriptSetupCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestScriptAction> action});
}

class _$TestScriptSetupCopyWithImpl<$Res>
    implements $TestScriptSetupCopyWith<$Res> {
  _$TestScriptSetupCopyWithImpl(this._value, this._then);

  final TestScriptSetup _value;
  // ignore: unused_field
  final $Res Function(TestScriptSetup) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction>,
    ));
  }
}

abstract class _$TestScriptSetupCopyWith<$Res>
    implements $TestScriptSetupCopyWith<$Res> {
  factory _$TestScriptSetupCopyWith(
          _TestScriptSetup value, $Res Function(_TestScriptSetup) then) =
      __$TestScriptSetupCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestScriptAction> action});
}

class __$TestScriptSetupCopyWithImpl<$Res>
    extends _$TestScriptSetupCopyWithImpl<$Res>
    implements _$TestScriptSetupCopyWith<$Res> {
  __$TestScriptSetupCopyWithImpl(
      _TestScriptSetup _value, $Res Function(_TestScriptSetup) _then)
      : super(_value, (v) => _then(v as _TestScriptSetup));

  @override
  _TestScriptSetup get _value => super._value as _TestScriptSetup;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_TestScriptSetup(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction>,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptSetup implements _TestScriptSetup {
  const _$_TestScriptSetup(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestScriptSetup.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptSetupFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final List<TestScriptAction> action;

  @override
  String toString() {
    return 'TestScriptSetup(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptSetup &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestScriptSetupCopyWith<_TestScriptSetup> get copyWith =>
      __$TestScriptSetupCopyWithImpl<_TestScriptSetup>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptSetupToJson(this);
  }
}

abstract class _TestScriptSetup implements TestScriptSetup {
  const factory _TestScriptSetup(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) List<TestScriptAction> action}) =
      _$_TestScriptSetup;

  factory _TestScriptSetup.fromJson(Map<String, dynamic> json) =
      _$_TestScriptSetup.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  List<TestScriptAction> get action;
  @override
  _$TestScriptSetupCopyWith<_TestScriptSetup> get copyWith;
}

TestScriptAction _$TestScriptActionFromJson(Map<String, dynamic> json) {
  return _TestScriptAction.fromJson(json);
}

class _$TestScriptActionTearOff {
  const _$TestScriptActionTearOff();

  _TestScriptAction call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_}) {
    return _TestScriptAction(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
      assert_: assert_,
    );
  }
}

// ignore: unused_element
const $TestScriptAction = _$TestScriptActionTearOff();

mixin _$TestScriptAction {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  TestScriptOperation get operation;
  @JsonKey(name: 'assert')
  TestScriptAssert get assert_;

  Map<String, dynamic> toJson();
  $TestScriptActionCopyWith<TestScriptAction> get copyWith;
}

abstract class $TestScriptActionCopyWith<$Res> {
  factory $TestScriptActionCopyWith(
          TestScriptAction value, $Res Function(TestScriptAction) then) =
      _$TestScriptActionCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_});

  $TestScriptOperationCopyWith<$Res> get operation;
  $TestScriptAssertCopyWith<$Res> get assert_;
}

class _$TestScriptActionCopyWithImpl<$Res>
    implements $TestScriptActionCopyWith<$Res> {
  _$TestScriptActionCopyWithImpl(this._value, this._then);

  final TestScriptAction _value;
  // ignore: unused_field
  final $Res Function(TestScriptAction) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestScriptAssert,
    ));
  }

  @override
  $TestScriptOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestScriptOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }

  @override
  $TestScriptAssertCopyWith<$Res> get assert_ {
    if (_value.assert_ == null) {
      return null;
    }
    return $TestScriptAssertCopyWith<$Res>(_value.assert_, (value) {
      return _then(_value.copyWith(assert_: value));
    });
  }
}

abstract class _$TestScriptActionCopyWith<$Res>
    implements $TestScriptActionCopyWith<$Res> {
  factory _$TestScriptActionCopyWith(
          _TestScriptAction value, $Res Function(_TestScriptAction) then) =
      __$TestScriptActionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_});

  @override
  $TestScriptOperationCopyWith<$Res> get operation;
  @override
  $TestScriptAssertCopyWith<$Res> get assert_;
}

class __$TestScriptActionCopyWithImpl<$Res>
    extends _$TestScriptActionCopyWithImpl<$Res>
    implements _$TestScriptActionCopyWith<$Res> {
  __$TestScriptActionCopyWithImpl(
      _TestScriptAction _value, $Res Function(_TestScriptAction) _then)
      : super(_value, (v) => _then(v as _TestScriptAction));

  @override
  _TestScriptAction get _value => super._value as _TestScriptAction;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_TestScriptAction(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestScriptAssert,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptAction implements _TestScriptAction {
  const _$_TestScriptAction(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.operation,
      @JsonKey(name: 'assert') this.assert_});

  factory _$_TestScriptAction.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptActionFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final TestScriptOperation operation;
  @override
  @JsonKey(name: 'assert')
  final TestScriptAssert assert_;

  @override
  String toString() {
    return 'TestScriptAction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation, assert_: $assert_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptAction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)) &&
            (identical(other.assert_, assert_) ||
                const DeepCollectionEquality().equals(other.assert_, assert_)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation) ^
      const DeepCollectionEquality().hash(assert_);

  @override
  _$TestScriptActionCopyWith<_TestScriptAction> get copyWith =>
      __$TestScriptActionCopyWithImpl<_TestScriptAction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptActionToJson(this);
  }
}

abstract class _TestScriptAction implements TestScriptAction {
  const factory _TestScriptAction(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_}) = _$_TestScriptAction;

  factory _TestScriptAction.fromJson(Map<String, dynamic> json) =
      _$_TestScriptAction.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  TestScriptOperation get operation;
  @override
  @JsonKey(name: 'assert')
  TestScriptAssert get assert_;
  @override
  _$TestScriptActionCopyWith<_TestScriptAction> get copyWith;
}

TestScriptOperation _$TestScriptOperationFromJson(Map<String, dynamic> json) {
  return _TestScriptOperation.fromJson(json);
}

class _$TestScriptOperationTearOff {
  const _$TestScriptOperationTearOff();

  _TestScriptOperation call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Coding type,
      Code resource,
      String label,
      String description,
      Code accept,
      Code contentType,
      Integer destination,
      Boolean encodeRequestUrl,
      @JsonKey(unknownEnumValue: OperationMethod.unknown)
          OperationMethod method,
      Integer origin,
      String params,
      List<TestScriptRequestHeader> requestHeader,
      Id requestId,
      Id responseId,
      Id sourceId,
      Id targetId,
      String url}) {
    return _TestScriptOperation(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      type: type,
      resource: resource,
      label: label,
      description: description,
      accept: accept,
      contentType: contentType,
      destination: destination,
      encodeRequestUrl: encodeRequestUrl,
      method: method,
      origin: origin,
      params: params,
      requestHeader: requestHeader,
      requestId: requestId,
      responseId: responseId,
      sourceId: sourceId,
      targetId: targetId,
      url: url,
    );
  }
}

// ignore: unused_element
const $TestScriptOperation = _$TestScriptOperationTearOff();

mixin _$TestScriptOperation {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  Coding get type;
  Code get resource;
  String get label;
  String get description;
  Code get accept;
  Code get contentType;
  Integer get destination;
  Boolean get encodeRequestUrl;
  @JsonKey(unknownEnumValue: OperationMethod.unknown)
  OperationMethod get method;
  Integer get origin;
  String get params;
  List<TestScriptRequestHeader> get requestHeader;
  Id get requestId;
  Id get responseId;
  Id get sourceId;
  Id get targetId;
  String get url;

  Map<String, dynamic> toJson();
  $TestScriptOperationCopyWith<TestScriptOperation> get copyWith;
}

abstract class $TestScriptOperationCopyWith<$Res> {
  factory $TestScriptOperationCopyWith(
          TestScriptOperation value, $Res Function(TestScriptOperation) then) =
      _$TestScriptOperationCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Coding type,
      Code resource,
      String label,
      String description,
      Code accept,
      Code contentType,
      Integer destination,
      Boolean encodeRequestUrl,
      @JsonKey(unknownEnumValue: OperationMethod.unknown)
          OperationMethod method,
      Integer origin,
      String params,
      List<TestScriptRequestHeader> requestHeader,
      Id requestId,
      Id responseId,
      Id sourceId,
      Id targetId,
      String url});

  $CodingCopyWith<$Res> get type;
}

class _$TestScriptOperationCopyWithImpl<$Res>
    implements $TestScriptOperationCopyWith<$Res> {
  _$TestScriptOperationCopyWithImpl(this._value, this._then);

  final TestScriptOperation _value;
  // ignore: unused_field
  final $Res Function(TestScriptOperation) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object resource = freezed,
    Object label = freezed,
    Object description = freezed,
    Object accept = freezed,
    Object contentType = freezed,
    Object destination = freezed,
    Object encodeRequestUrl = freezed,
    Object method = freezed,
    Object origin = freezed,
    Object params = freezed,
    Object requestHeader = freezed,
    Object requestId = freezed,
    Object responseId = freezed,
    Object sourceId = freezed,
    Object targetId = freezed,
    Object url = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as Coding,
      resource: resource == freezed ? _value.resource : resource as Code,
      label: label == freezed ? _value.label : label as String,
      description:
          description == freezed ? _value.description : description as String,
      accept: accept == freezed ? _value.accept : accept as Code,
      contentType:
          contentType == freezed ? _value.contentType : contentType as Code,
      destination:
          destination == freezed ? _value.destination : destination as Integer,
      encodeRequestUrl: encodeRequestUrl == freezed
          ? _value.encodeRequestUrl
          : encodeRequestUrl as Boolean,
      method: method == freezed ? _value.method : method as OperationMethod,
      origin: origin == freezed ? _value.origin : origin as Integer,
      params: params == freezed ? _value.params : params as String,
      requestHeader: requestHeader == freezed
          ? _value.requestHeader
          : requestHeader as List<TestScriptRequestHeader>,
      requestId: requestId == freezed ? _value.requestId : requestId as Id,
      responseId: responseId == freezed ? _value.responseId : responseId as Id,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
      targetId: targetId == freezed ? _value.targetId : targetId as Id,
      url: url == freezed ? _value.url : url as String,
    ));
  }

  @override
  $CodingCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $CodingCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$TestScriptOperationCopyWith<$Res>
    implements $TestScriptOperationCopyWith<$Res> {
  factory _$TestScriptOperationCopyWith(_TestScriptOperation value,
          $Res Function(_TestScriptOperation) then) =
      __$TestScriptOperationCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Coding type,
      Code resource,
      String label,
      String description,
      Code accept,
      Code contentType,
      Integer destination,
      Boolean encodeRequestUrl,
      @JsonKey(unknownEnumValue: OperationMethod.unknown)
          OperationMethod method,
      Integer origin,
      String params,
      List<TestScriptRequestHeader> requestHeader,
      Id requestId,
      Id responseId,
      Id sourceId,
      Id targetId,
      String url});

  @override
  $CodingCopyWith<$Res> get type;
}

class __$TestScriptOperationCopyWithImpl<$Res>
    extends _$TestScriptOperationCopyWithImpl<$Res>
    implements _$TestScriptOperationCopyWith<$Res> {
  __$TestScriptOperationCopyWithImpl(
      _TestScriptOperation _value, $Res Function(_TestScriptOperation) _then)
      : super(_value, (v) => _then(v as _TestScriptOperation));

  @override
  _TestScriptOperation get _value => super._value as _TestScriptOperation;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object type = freezed,
    Object resource = freezed,
    Object label = freezed,
    Object description = freezed,
    Object accept = freezed,
    Object contentType = freezed,
    Object destination = freezed,
    Object encodeRequestUrl = freezed,
    Object method = freezed,
    Object origin = freezed,
    Object params = freezed,
    Object requestHeader = freezed,
    Object requestId = freezed,
    Object responseId = freezed,
    Object sourceId = freezed,
    Object targetId = freezed,
    Object url = freezed,
  }) {
    return _then(_TestScriptOperation(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      type: type == freezed ? _value.type : type as Coding,
      resource: resource == freezed ? _value.resource : resource as Code,
      label: label == freezed ? _value.label : label as String,
      description:
          description == freezed ? _value.description : description as String,
      accept: accept == freezed ? _value.accept : accept as Code,
      contentType:
          contentType == freezed ? _value.contentType : contentType as Code,
      destination:
          destination == freezed ? _value.destination : destination as Integer,
      encodeRequestUrl: encodeRequestUrl == freezed
          ? _value.encodeRequestUrl
          : encodeRequestUrl as Boolean,
      method: method == freezed ? _value.method : method as OperationMethod,
      origin: origin == freezed ? _value.origin : origin as Integer,
      params: params == freezed ? _value.params : params as String,
      requestHeader: requestHeader == freezed
          ? _value.requestHeader
          : requestHeader as List<TestScriptRequestHeader>,
      requestId: requestId == freezed ? _value.requestId : requestId as Id,
      responseId: responseId == freezed ? _value.responseId : responseId as Id,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
      targetId: targetId == freezed ? _value.targetId : targetId as Id,
      url: url == freezed ? _value.url : url as String,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptOperation implements _TestScriptOperation {
  const _$_TestScriptOperation(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.type,
      this.resource,
      this.label,
      this.description,
      this.accept,
      this.contentType,
      this.destination,
      this.encodeRequestUrl,
      @JsonKey(unknownEnumValue: OperationMethod.unknown) this.method,
      this.origin,
      this.params,
      this.requestHeader,
      this.requestId,
      this.responseId,
      this.sourceId,
      this.targetId,
      this.url});

  factory _$_TestScriptOperation.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptOperationFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final Coding type;
  @override
  final Code resource;
  @override
  final String label;
  @override
  final String description;
  @override
  final Code accept;
  @override
  final Code contentType;
  @override
  final Integer destination;
  @override
  final Boolean encodeRequestUrl;
  @override
  @JsonKey(unknownEnumValue: OperationMethod.unknown)
  final OperationMethod method;
  @override
  final Integer origin;
  @override
  final String params;
  @override
  final List<TestScriptRequestHeader> requestHeader;
  @override
  final Id requestId;
  @override
  final Id responseId;
  @override
  final Id sourceId;
  @override
  final Id targetId;
  @override
  final String url;

  @override
  String toString() {
    return 'TestScriptOperation(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, resource: $resource, label: $label, description: $description, accept: $accept, contentType: $contentType, destination: $destination, encodeRequestUrl: $encodeRequestUrl, method: $method, origin: $origin, params: $params, requestHeader: $requestHeader, requestId: $requestId, responseId: $responseId, sourceId: $sourceId, targetId: $targetId, url: $url)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptOperation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.resource, resource) ||
                const DeepCollectionEquality()
                    .equals(other.resource, resource)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.accept, accept) ||
                const DeepCollectionEquality().equals(other.accept, accept)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.destination, destination) ||
                const DeepCollectionEquality()
                    .equals(other.destination, destination)) &&
            (identical(other.encodeRequestUrl, encodeRequestUrl) ||
                const DeepCollectionEquality()
                    .equals(other.encodeRequestUrl, encodeRequestUrl)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.origin, origin) ||
                const DeepCollectionEquality().equals(other.origin, origin)) &&
            (identical(other.params, params) ||
                const DeepCollectionEquality().equals(other.params, params)) &&
            (identical(other.requestHeader, requestHeader) ||
                const DeepCollectionEquality()
                    .equals(other.requestHeader, requestHeader)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.responseId, responseId) ||
                const DeepCollectionEquality()
                    .equals(other.responseId, responseId)) &&
            (identical(other.sourceId, sourceId) ||
                const DeepCollectionEquality()
                    .equals(other.sourceId, sourceId)) &&
            (identical(other.targetId, targetId) ||
                const DeepCollectionEquality()
                    .equals(other.targetId, targetId)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(resource) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(accept) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(destination) ^
      const DeepCollectionEquality().hash(encodeRequestUrl) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(origin) ^
      const DeepCollectionEquality().hash(params) ^
      const DeepCollectionEquality().hash(requestHeader) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(responseId) ^
      const DeepCollectionEquality().hash(sourceId) ^
      const DeepCollectionEquality().hash(targetId) ^
      const DeepCollectionEquality().hash(url);

  @override
  _$TestScriptOperationCopyWith<_TestScriptOperation> get copyWith =>
      __$TestScriptOperationCopyWithImpl<_TestScriptOperation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptOperationToJson(this);
  }
}

abstract class _TestScriptOperation implements TestScriptOperation {
  const factory _TestScriptOperation(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      Coding type,
      Code resource,
      String label,
      String description,
      Code accept,
      Code contentType,
      Integer destination,
      Boolean encodeRequestUrl,
      @JsonKey(unknownEnumValue: OperationMethod.unknown)
          OperationMethod method,
      Integer origin,
      String params,
      List<TestScriptRequestHeader> requestHeader,
      Id requestId,
      Id responseId,
      Id sourceId,
      Id targetId,
      String url}) = _$_TestScriptOperation;

  factory _TestScriptOperation.fromJson(Map<String, dynamic> json) =
      _$_TestScriptOperation.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  Coding get type;
  @override
  Code get resource;
  @override
  String get label;
  @override
  String get description;
  @override
  Code get accept;
  @override
  Code get contentType;
  @override
  Integer get destination;
  @override
  Boolean get encodeRequestUrl;
  @override
  @JsonKey(unknownEnumValue: OperationMethod.unknown)
  OperationMethod get method;
  @override
  Integer get origin;
  @override
  String get params;
  @override
  List<TestScriptRequestHeader> get requestHeader;
  @override
  Id get requestId;
  @override
  Id get responseId;
  @override
  Id get sourceId;
  @override
  Id get targetId;
  @override
  String get url;
  @override
  _$TestScriptOperationCopyWith<_TestScriptOperation> get copyWith;
}

TestScriptRequestHeader _$TestScriptRequestHeaderFromJson(
    Map<String, dynamic> json) {
  return _TestScriptRequestHeader.fromJson(json);
}

class _$TestScriptRequestHeaderTearOff {
  const _$TestScriptRequestHeaderTearOff();

  _TestScriptRequestHeader call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String field,
      String value}) {
    return _TestScriptRequestHeader(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      field: field,
      value: value,
    );
  }
}

// ignore: unused_element
const $TestScriptRequestHeader = _$TestScriptRequestHeaderTearOff();

mixin _$TestScriptRequestHeader {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get field;
  String get value;

  Map<String, dynamic> toJson();
  $TestScriptRequestHeaderCopyWith<TestScriptRequestHeader> get copyWith;
}

abstract class $TestScriptRequestHeaderCopyWith<$Res> {
  factory $TestScriptRequestHeaderCopyWith(TestScriptRequestHeader value,
          $Res Function(TestScriptRequestHeader) then) =
      _$TestScriptRequestHeaderCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String field,
      String value});
}

class _$TestScriptRequestHeaderCopyWithImpl<$Res>
    implements $TestScriptRequestHeaderCopyWith<$Res> {
  _$TestScriptRequestHeaderCopyWithImpl(this._value, this._then);

  final TestScriptRequestHeader _value;
  // ignore: unused_field
  final $Res Function(TestScriptRequestHeader) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object field = freezed,
    Object value = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      field: field == freezed ? _value.field : field as String,
      value: value == freezed ? _value.value : value as String,
    ));
  }
}

abstract class _$TestScriptRequestHeaderCopyWith<$Res>
    implements $TestScriptRequestHeaderCopyWith<$Res> {
  factory _$TestScriptRequestHeaderCopyWith(_TestScriptRequestHeader value,
          $Res Function(_TestScriptRequestHeader) then) =
      __$TestScriptRequestHeaderCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String field,
      String value});
}

class __$TestScriptRequestHeaderCopyWithImpl<$Res>
    extends _$TestScriptRequestHeaderCopyWithImpl<$Res>
    implements _$TestScriptRequestHeaderCopyWith<$Res> {
  __$TestScriptRequestHeaderCopyWithImpl(_TestScriptRequestHeader _value,
      $Res Function(_TestScriptRequestHeader) _then)
      : super(_value, (v) => _then(v as _TestScriptRequestHeader));

  @override
  _TestScriptRequestHeader get _value =>
      super._value as _TestScriptRequestHeader;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object field = freezed,
    Object value = freezed,
  }) {
    return _then(_TestScriptRequestHeader(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      field: field == freezed ? _value.field : field as String,
      value: value == freezed ? _value.value : value as String,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptRequestHeader implements _TestScriptRequestHeader {
  const _$_TestScriptRequestHeader(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.field,
      this.value});

  factory _$_TestScriptRequestHeader.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptRequestHeaderFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String field;
  @override
  final String value;

  @override
  String toString() {
    return 'TestScriptRequestHeader(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, field: $field, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptRequestHeader &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(value);

  @override
  _$TestScriptRequestHeaderCopyWith<_TestScriptRequestHeader> get copyWith =>
      __$TestScriptRequestHeaderCopyWithImpl<_TestScriptRequestHeader>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptRequestHeaderToJson(this);
  }
}

abstract class _TestScriptRequestHeader implements TestScriptRequestHeader {
  const factory _TestScriptRequestHeader(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String field,
      String value}) = _$_TestScriptRequestHeader;

  factory _TestScriptRequestHeader.fromJson(Map<String, dynamic> json) =
      _$_TestScriptRequestHeader.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get field;
  @override
  String get value;
  @override
  _$TestScriptRequestHeaderCopyWith<_TestScriptRequestHeader> get copyWith;
}

TestScriptAssert _$TestScriptAssertFromJson(Map<String, dynamic> json) {
  return _TestScriptAssert.fromJson(json);
}

class _$TestScriptAssertTearOff {
  const _$TestScriptAssertTearOff();

  _TestScriptAssert call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String label,
      String description,
      @JsonKey(unknownEnumValue: AssertDirection.unknown)
          AssertDirection direction,
      String compareToSourceId,
      String compareToSourceExpression,
      String compareToSourcePath,
      Code contentType,
      String expression,
      String headerField,
      String minimumId,
      Boolean navigationLinks,
      @JsonKey(unknownEnumValue: AssertOperator.unknown)
          AssertOperator operator,
      String path,
      @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
          AssertRequestMethod requestMethod,
      String requestURL,
      Code resource,
      @JsonKey(unknownEnumValue: AssertResponse.unknown)
          AssertResponse response,
      String responseCode,
      Id sourceId,
      Id validateProfileId,
      String value,
      Boolean warningOnly}) {
    return _TestScriptAssert(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      label: label,
      description: description,
      direction: direction,
      compareToSourceId: compareToSourceId,
      compareToSourceExpression: compareToSourceExpression,
      compareToSourcePath: compareToSourcePath,
      contentType: contentType,
      expression: expression,
      headerField: headerField,
      minimumId: minimumId,
      navigationLinks: navigationLinks,
      operator: operator,
      path: path,
      requestMethod: requestMethod,
      requestURL: requestURL,
      resource: resource,
      response: response,
      responseCode: responseCode,
      sourceId: sourceId,
      validateProfileId: validateProfileId,
      value: value,
      warningOnly: warningOnly,
    );
  }
}

// ignore: unused_element
const $TestScriptAssert = _$TestScriptAssertTearOff();

mixin _$TestScriptAssert {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get label;
  String get description;
  @JsonKey(unknownEnumValue: AssertDirection.unknown)
  AssertDirection get direction;
  String get compareToSourceId;
  String get compareToSourceExpression;
  String get compareToSourcePath;
  Code get contentType;
  String get expression;
  String get headerField;
  String get minimumId;
  Boolean get navigationLinks;
  @JsonKey(unknownEnumValue: AssertOperator.unknown)
  AssertOperator get operator;
  String get path;
  @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
  AssertRequestMethod get requestMethod;
  String get requestURL;
  Code get resource;
  @JsonKey(unknownEnumValue: AssertResponse.unknown)
  AssertResponse get response;
  String get responseCode;
  Id get sourceId;
  Id get validateProfileId;
  String get value;
  Boolean get warningOnly;

  Map<String, dynamic> toJson();
  $TestScriptAssertCopyWith<TestScriptAssert> get copyWith;
}

abstract class $TestScriptAssertCopyWith<$Res> {
  factory $TestScriptAssertCopyWith(
          TestScriptAssert value, $Res Function(TestScriptAssert) then) =
      _$TestScriptAssertCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String label,
      String description,
      @JsonKey(unknownEnumValue: AssertDirection.unknown)
          AssertDirection direction,
      String compareToSourceId,
      String compareToSourceExpression,
      String compareToSourcePath,
      Code contentType,
      String expression,
      String headerField,
      String minimumId,
      Boolean navigationLinks,
      @JsonKey(unknownEnumValue: AssertOperator.unknown)
          AssertOperator operator,
      String path,
      @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
          AssertRequestMethod requestMethod,
      String requestURL,
      Code resource,
      @JsonKey(unknownEnumValue: AssertResponse.unknown)
          AssertResponse response,
      String responseCode,
      Id sourceId,
      Id validateProfileId,
      String value,
      Boolean warningOnly});
}

class _$TestScriptAssertCopyWithImpl<$Res>
    implements $TestScriptAssertCopyWith<$Res> {
  _$TestScriptAssertCopyWithImpl(this._value, this._then);

  final TestScriptAssert _value;
  // ignore: unused_field
  final $Res Function(TestScriptAssert) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object label = freezed,
    Object description = freezed,
    Object direction = freezed,
    Object compareToSourceId = freezed,
    Object compareToSourceExpression = freezed,
    Object compareToSourcePath = freezed,
    Object contentType = freezed,
    Object expression = freezed,
    Object headerField = freezed,
    Object minimumId = freezed,
    Object navigationLinks = freezed,
    Object operator = freezed,
    Object path = freezed,
    Object requestMethod = freezed,
    Object requestURL = freezed,
    Object resource = freezed,
    Object response = freezed,
    Object responseCode = freezed,
    Object sourceId = freezed,
    Object validateProfileId = freezed,
    Object value = freezed,
    Object warningOnly = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      label: label == freezed ? _value.label : label as String,
      description:
          description == freezed ? _value.description : description as String,
      direction: direction == freezed
          ? _value.direction
          : direction as AssertDirection,
      compareToSourceId: compareToSourceId == freezed
          ? _value.compareToSourceId
          : compareToSourceId as String,
      compareToSourceExpression: compareToSourceExpression == freezed
          ? _value.compareToSourceExpression
          : compareToSourceExpression as String,
      compareToSourcePath: compareToSourcePath == freezed
          ? _value.compareToSourcePath
          : compareToSourcePath as String,
      contentType:
          contentType == freezed ? _value.contentType : contentType as Code,
      expression:
          expression == freezed ? _value.expression : expression as String,
      headerField:
          headerField == freezed ? _value.headerField : headerField as String,
      minimumId: minimumId == freezed ? _value.minimumId : minimumId as String,
      navigationLinks: navigationLinks == freezed
          ? _value.navigationLinks
          : navigationLinks as Boolean,
      operator:
          operator == freezed ? _value.operator : operator as AssertOperator,
      path: path == freezed ? _value.path : path as String,
      requestMethod: requestMethod == freezed
          ? _value.requestMethod
          : requestMethod as AssertRequestMethod,
      requestURL:
          requestURL == freezed ? _value.requestURL : requestURL as String,
      resource: resource == freezed ? _value.resource : resource as Code,
      response:
          response == freezed ? _value.response : response as AssertResponse,
      responseCode: responseCode == freezed
          ? _value.responseCode
          : responseCode as String,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
      validateProfileId: validateProfileId == freezed
          ? _value.validateProfileId
          : validateProfileId as Id,
      value: value == freezed ? _value.value : value as String,
      warningOnly:
          warningOnly == freezed ? _value.warningOnly : warningOnly as Boolean,
    ));
  }
}

abstract class _$TestScriptAssertCopyWith<$Res>
    implements $TestScriptAssertCopyWith<$Res> {
  factory _$TestScriptAssertCopyWith(
          _TestScriptAssert value, $Res Function(_TestScriptAssert) then) =
      __$TestScriptAssertCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String label,
      String description,
      @JsonKey(unknownEnumValue: AssertDirection.unknown)
          AssertDirection direction,
      String compareToSourceId,
      String compareToSourceExpression,
      String compareToSourcePath,
      Code contentType,
      String expression,
      String headerField,
      String minimumId,
      Boolean navigationLinks,
      @JsonKey(unknownEnumValue: AssertOperator.unknown)
          AssertOperator operator,
      String path,
      @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
          AssertRequestMethod requestMethod,
      String requestURL,
      Code resource,
      @JsonKey(unknownEnumValue: AssertResponse.unknown)
          AssertResponse response,
      String responseCode,
      Id sourceId,
      Id validateProfileId,
      String value,
      Boolean warningOnly});
}

class __$TestScriptAssertCopyWithImpl<$Res>
    extends _$TestScriptAssertCopyWithImpl<$Res>
    implements _$TestScriptAssertCopyWith<$Res> {
  __$TestScriptAssertCopyWithImpl(
      _TestScriptAssert _value, $Res Function(_TestScriptAssert) _then)
      : super(_value, (v) => _then(v as _TestScriptAssert));

  @override
  _TestScriptAssert get _value => super._value as _TestScriptAssert;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object label = freezed,
    Object description = freezed,
    Object direction = freezed,
    Object compareToSourceId = freezed,
    Object compareToSourceExpression = freezed,
    Object compareToSourcePath = freezed,
    Object contentType = freezed,
    Object expression = freezed,
    Object headerField = freezed,
    Object minimumId = freezed,
    Object navigationLinks = freezed,
    Object operator = freezed,
    Object path = freezed,
    Object requestMethod = freezed,
    Object requestURL = freezed,
    Object resource = freezed,
    Object response = freezed,
    Object responseCode = freezed,
    Object sourceId = freezed,
    Object validateProfileId = freezed,
    Object value = freezed,
    Object warningOnly = freezed,
  }) {
    return _then(_TestScriptAssert(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      label: label == freezed ? _value.label : label as String,
      description:
          description == freezed ? _value.description : description as String,
      direction: direction == freezed
          ? _value.direction
          : direction as AssertDirection,
      compareToSourceId: compareToSourceId == freezed
          ? _value.compareToSourceId
          : compareToSourceId as String,
      compareToSourceExpression: compareToSourceExpression == freezed
          ? _value.compareToSourceExpression
          : compareToSourceExpression as String,
      compareToSourcePath: compareToSourcePath == freezed
          ? _value.compareToSourcePath
          : compareToSourcePath as String,
      contentType:
          contentType == freezed ? _value.contentType : contentType as Code,
      expression:
          expression == freezed ? _value.expression : expression as String,
      headerField:
          headerField == freezed ? _value.headerField : headerField as String,
      minimumId: minimumId == freezed ? _value.minimumId : minimumId as String,
      navigationLinks: navigationLinks == freezed
          ? _value.navigationLinks
          : navigationLinks as Boolean,
      operator:
          operator == freezed ? _value.operator : operator as AssertOperator,
      path: path == freezed ? _value.path : path as String,
      requestMethod: requestMethod == freezed
          ? _value.requestMethod
          : requestMethod as AssertRequestMethod,
      requestURL:
          requestURL == freezed ? _value.requestURL : requestURL as String,
      resource: resource == freezed ? _value.resource : resource as Code,
      response:
          response == freezed ? _value.response : response as AssertResponse,
      responseCode: responseCode == freezed
          ? _value.responseCode
          : responseCode as String,
      sourceId: sourceId == freezed ? _value.sourceId : sourceId as Id,
      validateProfileId: validateProfileId == freezed
          ? _value.validateProfileId
          : validateProfileId as Id,
      value: value == freezed ? _value.value : value as String,
      warningOnly:
          warningOnly == freezed ? _value.warningOnly : warningOnly as Boolean,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptAssert implements _TestScriptAssert {
  const _$_TestScriptAssert(
      {this.id,
      @JsonKey(name: 'extension')
          this.extension_,
      this.modifierExtension,
      this.label,
      this.description,
      @JsonKey(unknownEnumValue: AssertDirection.unknown)
          this.direction,
      this.compareToSourceId,
      this.compareToSourceExpression,
      this.compareToSourcePath,
      this.contentType,
      this.expression,
      this.headerField,
      this.minimumId,
      this.navigationLinks,
      @JsonKey(unknownEnumValue: AssertOperator.unknown)
          this.operator,
      this.path,
      @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
          this.requestMethod,
      this.requestURL,
      this.resource,
      @JsonKey(unknownEnumValue: AssertResponse.unknown)
          this.response,
      this.responseCode,
      this.sourceId,
      this.validateProfileId,
      this.value,
      this.warningOnly});

  factory _$_TestScriptAssert.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptAssertFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String label;
  @override
  final String description;
  @override
  @JsonKey(unknownEnumValue: AssertDirection.unknown)
  final AssertDirection direction;
  @override
  final String compareToSourceId;
  @override
  final String compareToSourceExpression;
  @override
  final String compareToSourcePath;
  @override
  final Code contentType;
  @override
  final String expression;
  @override
  final String headerField;
  @override
  final String minimumId;
  @override
  final Boolean navigationLinks;
  @override
  @JsonKey(unknownEnumValue: AssertOperator.unknown)
  final AssertOperator operator;
  @override
  final String path;
  @override
  @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
  final AssertRequestMethod requestMethod;
  @override
  final String requestURL;
  @override
  final Code resource;
  @override
  @JsonKey(unknownEnumValue: AssertResponse.unknown)
  final AssertResponse response;
  @override
  final String responseCode;
  @override
  final Id sourceId;
  @override
  final Id validateProfileId;
  @override
  final String value;
  @override
  final Boolean warningOnly;

  @override
  String toString() {
    return 'TestScriptAssert(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, label: $label, description: $description, direction: $direction, compareToSourceId: $compareToSourceId, compareToSourceExpression: $compareToSourceExpression, compareToSourcePath: $compareToSourcePath, contentType: $contentType, expression: $expression, headerField: $headerField, minimumId: $minimumId, navigationLinks: $navigationLinks, operator: $operator, path: $path, requestMethod: $requestMethod, requestURL: $requestURL, resource: $resource, response: $response, responseCode: $responseCode, sourceId: $sourceId, validateProfileId: $validateProfileId, value: $value, warningOnly: $warningOnly)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptAssert &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.compareToSourceId, compareToSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.compareToSourceId, compareToSourceId)) &&
            (identical(other.compareToSourceExpression, compareToSourceExpression) ||
                const DeepCollectionEquality().equals(
                    other.compareToSourceExpression,
                    compareToSourceExpression)) &&
            (identical(other.compareToSourcePath, compareToSourcePath) ||
                const DeepCollectionEquality()
                    .equals(other.compareToSourcePath, compareToSourcePath)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.expression, expression) ||
                const DeepCollectionEquality()
                    .equals(other.expression, expression)) &&
            (identical(other.headerField, headerField) ||
                const DeepCollectionEquality()
                    .equals(other.headerField, headerField)) &&
            (identical(other.minimumId, minimumId) ||
                const DeepCollectionEquality()
                    .equals(other.minimumId, minimumId)) &&
            (identical(other.navigationLinks, navigationLinks) ||
                const DeepCollectionEquality()
                    .equals(other.navigationLinks, navigationLinks)) &&
            (identical(other.operator, operator) ||
                const DeepCollectionEquality()
                    .equals(other.operator, operator)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.requestMethod, requestMethod) ||
                const DeepCollectionEquality()
                    .equals(other.requestMethod, requestMethod)) &&
            (identical(other.requestURL, requestURL) ||
                const DeepCollectionEquality()
                    .equals(other.requestURL, requestURL)) &&
            (identical(other.resource, resource) ||
                const DeepCollectionEquality()
                    .equals(other.resource, resource)) &&
            (identical(other.response, response) || const DeepCollectionEquality().equals(other.response, response)) &&
            (identical(other.responseCode, responseCode) || const DeepCollectionEquality().equals(other.responseCode, responseCode)) &&
            (identical(other.sourceId, sourceId) || const DeepCollectionEquality().equals(other.sourceId, sourceId)) &&
            (identical(other.validateProfileId, validateProfileId) || const DeepCollectionEquality().equals(other.validateProfileId, validateProfileId)) &&
            (identical(other.value, value) || const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.warningOnly, warningOnly) || const DeepCollectionEquality().equals(other.warningOnly, warningOnly)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(compareToSourceId) ^
      const DeepCollectionEquality().hash(compareToSourceExpression) ^
      const DeepCollectionEquality().hash(compareToSourcePath) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(expression) ^
      const DeepCollectionEquality().hash(headerField) ^
      const DeepCollectionEquality().hash(minimumId) ^
      const DeepCollectionEquality().hash(navigationLinks) ^
      const DeepCollectionEquality().hash(operator) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(requestMethod) ^
      const DeepCollectionEquality().hash(requestURL) ^
      const DeepCollectionEquality().hash(resource) ^
      const DeepCollectionEquality().hash(response) ^
      const DeepCollectionEquality().hash(responseCode) ^
      const DeepCollectionEquality().hash(sourceId) ^
      const DeepCollectionEquality().hash(validateProfileId) ^
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(warningOnly);

  @override
  _$TestScriptAssertCopyWith<_TestScriptAssert> get copyWith =>
      __$TestScriptAssertCopyWithImpl<_TestScriptAssert>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptAssertToJson(this);
  }
}

abstract class _TestScriptAssert implements TestScriptAssert {
  const factory _TestScriptAssert(
      {String id,
      @JsonKey(name: 'extension')
          List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String label,
      String description,
      @JsonKey(unknownEnumValue: AssertDirection.unknown)
          AssertDirection direction,
      String compareToSourceId,
      String compareToSourceExpression,
      String compareToSourcePath,
      Code contentType,
      String expression,
      String headerField,
      String minimumId,
      Boolean navigationLinks,
      @JsonKey(unknownEnumValue: AssertOperator.unknown)
          AssertOperator operator,
      String path,
      @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
          AssertRequestMethod requestMethod,
      String requestURL,
      Code resource,
      @JsonKey(unknownEnumValue: AssertResponse.unknown)
          AssertResponse response,
      String responseCode,
      Id sourceId,
      Id validateProfileId,
      String value,
      Boolean warningOnly}) = _$_TestScriptAssert;

  factory _TestScriptAssert.fromJson(Map<String, dynamic> json) =
      _$_TestScriptAssert.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get label;
  @override
  String get description;
  @override
  @JsonKey(unknownEnumValue: AssertDirection.unknown)
  AssertDirection get direction;
  @override
  String get compareToSourceId;
  @override
  String get compareToSourceExpression;
  @override
  String get compareToSourcePath;
  @override
  Code get contentType;
  @override
  String get expression;
  @override
  String get headerField;
  @override
  String get minimumId;
  @override
  Boolean get navigationLinks;
  @override
  @JsonKey(unknownEnumValue: AssertOperator.unknown)
  AssertOperator get operator;
  @override
  String get path;
  @override
  @JsonKey(unknownEnumValue: AssertRequestMethod.unknown)
  AssertRequestMethod get requestMethod;
  @override
  String get requestURL;
  @override
  Code get resource;
  @override
  @JsonKey(unknownEnumValue: AssertResponse.unknown)
  AssertResponse get response;
  @override
  String get responseCode;
  @override
  Id get sourceId;
  @override
  Id get validateProfileId;
  @override
  String get value;
  @override
  Boolean get warningOnly;
  @override
  _$TestScriptAssertCopyWith<_TestScriptAssert> get copyWith;
}

TestScriptTest _$TestScriptTestFromJson(Map<String, dynamic> json) {
  return _TestScriptTest.fromJson(json);
}

class _$TestScriptTestTearOff {
  const _$TestScriptTestTearOff();

  _TestScriptTest call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @required @JsonKey(required: true) List<TestScriptAction1> action}) {
    return _TestScriptTest(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      name: name,
      description: description,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestScriptTest = _$TestScriptTestTearOff();

mixin _$TestScriptTest {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  String get name;
  String get description;
  @JsonKey(required: true)
  List<TestScriptAction1> get action;

  Map<String, dynamic> toJson();
  $TestScriptTestCopyWith<TestScriptTest> get copyWith;
}

abstract class $TestScriptTestCopyWith<$Res> {
  factory $TestScriptTestCopyWith(
          TestScriptTest value, $Res Function(TestScriptTest) then) =
      _$TestScriptTestCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @JsonKey(required: true) List<TestScriptAction1> action});
}

class _$TestScriptTestCopyWithImpl<$Res>
    implements $TestScriptTestCopyWith<$Res> {
  _$TestScriptTestCopyWithImpl(this._value, this._then);

  final TestScriptTest _value;
  // ignore: unused_field
  final $Res Function(TestScriptTest) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object description = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      description:
          description == freezed ? _value.description : description as String,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction1>,
    ));
  }
}

abstract class _$TestScriptTestCopyWith<$Res>
    implements $TestScriptTestCopyWith<$Res> {
  factory _$TestScriptTestCopyWith(
          _TestScriptTest value, $Res Function(_TestScriptTest) then) =
      __$TestScriptTestCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      String name,
      String description,
      @JsonKey(required: true) List<TestScriptAction1> action});
}

class __$TestScriptTestCopyWithImpl<$Res>
    extends _$TestScriptTestCopyWithImpl<$Res>
    implements _$TestScriptTestCopyWith<$Res> {
  __$TestScriptTestCopyWithImpl(
      _TestScriptTest _value, $Res Function(_TestScriptTest) _then)
      : super(_value, (v) => _then(v as _TestScriptTest));

  @override
  _TestScriptTest get _value => super._value as _TestScriptTest;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object name = freezed,
    Object description = freezed,
    Object action = freezed,
  }) {
    return _then(_TestScriptTest(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      name: name == freezed ? _value.name : name as String,
      description:
          description == freezed ? _value.description : description as String,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction1>,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptTest implements _TestScriptTest {
  const _$_TestScriptTest(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.name,
      this.description,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestScriptTest.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptTestFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final String name;
  @override
  final String description;
  @override
  @JsonKey(required: true)
  final List<TestScriptAction1> action;

  @override
  String toString() {
    return 'TestScriptTest(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, name: $name, description: $description, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptTest &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestScriptTestCopyWith<_TestScriptTest> get copyWith =>
      __$TestScriptTestCopyWithImpl<_TestScriptTest>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptTestToJson(this);
  }
}

abstract class _TestScriptTest implements TestScriptTest {
  const factory _TestScriptTest(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          String name,
          String description,
          @required @JsonKey(required: true) List<TestScriptAction1> action}) =
      _$_TestScriptTest;

  factory _TestScriptTest.fromJson(Map<String, dynamic> json) =
      _$_TestScriptTest.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  String get name;
  @override
  String get description;
  @override
  @JsonKey(required: true)
  List<TestScriptAction1> get action;
  @override
  _$TestScriptTestCopyWith<_TestScriptTest> get copyWith;
}

TestScriptAction1 _$TestScriptAction1FromJson(Map<String, dynamic> json) {
  return _TestScriptAction1.fromJson(json);
}

class _$TestScriptAction1TearOff {
  const _$TestScriptAction1TearOff();

  _TestScriptAction1 call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_}) {
    return _TestScriptAction1(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
      assert_: assert_,
    );
  }
}

// ignore: unused_element
const $TestScriptAction1 = _$TestScriptAction1TearOff();

mixin _$TestScriptAction1 {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  TestScriptOperation get operation;
  @JsonKey(name: 'assert')
  TestScriptAssert get assert_;

  Map<String, dynamic> toJson();
  $TestScriptAction1CopyWith<TestScriptAction1> get copyWith;
}

abstract class $TestScriptAction1CopyWith<$Res> {
  factory $TestScriptAction1CopyWith(
          TestScriptAction1 value, $Res Function(TestScriptAction1) then) =
      _$TestScriptAction1CopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_});

  $TestScriptOperationCopyWith<$Res> get operation;
  $TestScriptAssertCopyWith<$Res> get assert_;
}

class _$TestScriptAction1CopyWithImpl<$Res>
    implements $TestScriptAction1CopyWith<$Res> {
  _$TestScriptAction1CopyWithImpl(this._value, this._then);

  final TestScriptAction1 _value;
  // ignore: unused_field
  final $Res Function(TestScriptAction1) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestScriptAssert,
    ));
  }

  @override
  $TestScriptOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestScriptOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }

  @override
  $TestScriptAssertCopyWith<$Res> get assert_ {
    if (_value.assert_ == null) {
      return null;
    }
    return $TestScriptAssertCopyWith<$Res>(_value.assert_, (value) {
      return _then(_value.copyWith(assert_: value));
    });
  }
}

abstract class _$TestScriptAction1CopyWith<$Res>
    implements $TestScriptAction1CopyWith<$Res> {
  factory _$TestScriptAction1CopyWith(
          _TestScriptAction1 value, $Res Function(_TestScriptAction1) then) =
      __$TestScriptAction1CopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      TestScriptOperation operation,
      @JsonKey(name: 'assert') TestScriptAssert assert_});

  @override
  $TestScriptOperationCopyWith<$Res> get operation;
  @override
  $TestScriptAssertCopyWith<$Res> get assert_;
}

class __$TestScriptAction1CopyWithImpl<$Res>
    extends _$TestScriptAction1CopyWithImpl<$Res>
    implements _$TestScriptAction1CopyWith<$Res> {
  __$TestScriptAction1CopyWithImpl(
      _TestScriptAction1 _value, $Res Function(_TestScriptAction1) _then)
      : super(_value, (v) => _then(v as _TestScriptAction1));

  @override
  _TestScriptAction1 get _value => super._value as _TestScriptAction1;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
    Object assert_ = freezed,
  }) {
    return _then(_TestScriptAction1(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
      assert_:
          assert_ == freezed ? _value.assert_ : assert_ as TestScriptAssert,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptAction1 implements _TestScriptAction1 {
  const _$_TestScriptAction1(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      this.operation,
      @JsonKey(name: 'assert') this.assert_});

  factory _$_TestScriptAction1.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptAction1FromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  final TestScriptOperation operation;
  @override
  @JsonKey(name: 'assert')
  final TestScriptAssert assert_;

  @override
  String toString() {
    return 'TestScriptAction1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation, assert_: $assert_)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptAction1 &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)) &&
            (identical(other.assert_, assert_) ||
                const DeepCollectionEquality().equals(other.assert_, assert_)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation) ^
      const DeepCollectionEquality().hash(assert_);

  @override
  _$TestScriptAction1CopyWith<_TestScriptAction1> get copyWith =>
      __$TestScriptAction1CopyWithImpl<_TestScriptAction1>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptAction1ToJson(this);
  }
}

abstract class _TestScriptAction1 implements TestScriptAction1 {
  const factory _TestScriptAction1(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          TestScriptOperation operation,
          @JsonKey(name: 'assert') TestScriptAssert assert_}) =
      _$_TestScriptAction1;

  factory _TestScriptAction1.fromJson(Map<String, dynamic> json) =
      _$_TestScriptAction1.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  TestScriptOperation get operation;
  @override
  @JsonKey(name: 'assert')
  TestScriptAssert get assert_;
  @override
  _$TestScriptAction1CopyWith<_TestScriptAction1> get copyWith;
}

TestScriptTeardown _$TestScriptTeardownFromJson(Map<String, dynamic> json) {
  return _TestScriptTeardown.fromJson(json);
}

class _$TestScriptTeardownTearOff {
  const _$TestScriptTeardownTearOff();

  _TestScriptTeardown call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) List<TestScriptAction2> action}) {
    return _TestScriptTeardown(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      action: action,
    );
  }
}

// ignore: unused_element
const $TestScriptTeardown = _$TestScriptTeardownTearOff();

mixin _$TestScriptTeardown {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  List<TestScriptAction2> get action;

  Map<String, dynamic> toJson();
  $TestScriptTeardownCopyWith<TestScriptTeardown> get copyWith;
}

abstract class $TestScriptTeardownCopyWith<$Res> {
  factory $TestScriptTeardownCopyWith(
          TestScriptTeardown value, $Res Function(TestScriptTeardown) then) =
      _$TestScriptTeardownCopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestScriptAction2> action});
}

class _$TestScriptTeardownCopyWithImpl<$Res>
    implements $TestScriptTeardownCopyWith<$Res> {
  _$TestScriptTeardownCopyWithImpl(this._value, this._then);

  final TestScriptTeardown _value;
  // ignore: unused_field
  final $Res Function(TestScriptTeardown) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction2>,
    ));
  }
}

abstract class _$TestScriptTeardownCopyWith<$Res>
    implements $TestScriptTeardownCopyWith<$Res> {
  factory _$TestScriptTeardownCopyWith(
          _TestScriptTeardown value, $Res Function(_TestScriptTeardown) then) =
      __$TestScriptTeardownCopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) List<TestScriptAction2> action});
}

class __$TestScriptTeardownCopyWithImpl<$Res>
    extends _$TestScriptTeardownCopyWithImpl<$Res>
    implements _$TestScriptTeardownCopyWith<$Res> {
  __$TestScriptTeardownCopyWithImpl(
      _TestScriptTeardown _value, $Res Function(_TestScriptTeardown) _then)
      : super(_value, (v) => _then(v as _TestScriptTeardown));

  @override
  _TestScriptTeardown get _value => super._value as _TestScriptTeardown;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object action = freezed,
  }) {
    return _then(_TestScriptTeardown(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      action:
          action == freezed ? _value.action : action as List<TestScriptAction2>,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptTeardown implements _TestScriptTeardown {
  const _$_TestScriptTeardown(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.action})
      : assert(action != null);

  factory _$_TestScriptTeardown.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptTeardownFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final List<TestScriptAction2> action;

  @override
  String toString() {
    return 'TestScriptTeardown(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, action: $action)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptTeardown &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(action);

  @override
  _$TestScriptTeardownCopyWith<_TestScriptTeardown> get copyWith =>
      __$TestScriptTeardownCopyWithImpl<_TestScriptTeardown>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptTeardownToJson(this);
  }
}

abstract class _TestScriptTeardown implements TestScriptTeardown {
  const factory _TestScriptTeardown(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) List<TestScriptAction2> action}) =
      _$_TestScriptTeardown;

  factory _TestScriptTeardown.fromJson(Map<String, dynamic> json) =
      _$_TestScriptTeardown.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  List<TestScriptAction2> get action;
  @override
  _$TestScriptTeardownCopyWith<_TestScriptTeardown> get copyWith;
}

TestScriptAction2 _$TestScriptAction2FromJson(Map<String, dynamic> json) {
  return _TestScriptAction2.fromJson(json);
}

class _$TestScriptAction2TearOff {
  const _$TestScriptAction2TearOff();

  _TestScriptAction2 call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @required @JsonKey(required: true) TestScriptOperation operation}) {
    return _TestScriptAction2(
      id: id,
      extension_: extension_,
      modifierExtension: modifierExtension,
      operation: operation,
    );
  }
}

// ignore: unused_element
const $TestScriptAction2 = _$TestScriptAction2TearOff();

mixin _$TestScriptAction2 {
  String get id;
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  List<FhirExtension> get modifierExtension;
  @JsonKey(required: true)
  TestScriptOperation get operation;

  Map<String, dynamic> toJson();
  $TestScriptAction2CopyWith<TestScriptAction2> get copyWith;
}

abstract class $TestScriptAction2CopyWith<$Res> {
  factory $TestScriptAction2CopyWith(
          TestScriptAction2 value, $Res Function(TestScriptAction2) then) =
      _$TestScriptAction2CopyWithImpl<$Res>;
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) TestScriptOperation operation});

  $TestScriptOperationCopyWith<$Res> get operation;
}

class _$TestScriptAction2CopyWithImpl<$Res>
    implements $TestScriptAction2CopyWith<$Res> {
  _$TestScriptAction2CopyWithImpl(this._value, this._then);

  final TestScriptAction2 _value;
  // ignore: unused_field
  final $Res Function(TestScriptAction2) _then;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
    ));
  }

  @override
  $TestScriptOperationCopyWith<$Res> get operation {
    if (_value.operation == null) {
      return null;
    }
    return $TestScriptOperationCopyWith<$Res>(_value.operation, (value) {
      return _then(_value.copyWith(operation: value));
    });
  }
}

abstract class _$TestScriptAction2CopyWith<$Res>
    implements $TestScriptAction2CopyWith<$Res> {
  factory _$TestScriptAction2CopyWith(
          _TestScriptAction2 value, $Res Function(_TestScriptAction2) then) =
      __$TestScriptAction2CopyWithImpl<$Res>;
  @override
  $Res call(
      {String id,
      @JsonKey(name: 'extension') List<FhirExtension> extension_,
      List<FhirExtension> modifierExtension,
      @JsonKey(required: true) TestScriptOperation operation});

  @override
  $TestScriptOperationCopyWith<$Res> get operation;
}

class __$TestScriptAction2CopyWithImpl<$Res>
    extends _$TestScriptAction2CopyWithImpl<$Res>
    implements _$TestScriptAction2CopyWith<$Res> {
  __$TestScriptAction2CopyWithImpl(
      _TestScriptAction2 _value, $Res Function(_TestScriptAction2) _then)
      : super(_value, (v) => _then(v as _TestScriptAction2));

  @override
  _TestScriptAction2 get _value => super._value as _TestScriptAction2;

  @override
  $Res call({
    Object id = freezed,
    Object extension_ = freezed,
    Object modifierExtension = freezed,
    Object operation = freezed,
  }) {
    return _then(_TestScriptAction2(
      id: id == freezed ? _value.id : id as String,
      extension_: extension_ == freezed
          ? _value.extension_
          : extension_ as List<FhirExtension>,
      modifierExtension: modifierExtension == freezed
          ? _value.modifierExtension
          : modifierExtension as List<FhirExtension>,
      operation: operation == freezed
          ? _value.operation
          : operation as TestScriptOperation,
    ));
  }
}

@JsonSerializable()
class _$_TestScriptAction2 implements _TestScriptAction2 {
  const _$_TestScriptAction2(
      {this.id,
      @JsonKey(name: 'extension') this.extension_,
      this.modifierExtension,
      @required @JsonKey(required: true) this.operation})
      : assert(operation != null);

  factory _$_TestScriptAction2.fromJson(Map<String, dynamic> json) =>
      _$_$_TestScriptAction2FromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'extension')
  final List<FhirExtension> extension_;
  @override
  final List<FhirExtension> modifierExtension;
  @override
  @JsonKey(required: true)
  final TestScriptOperation operation;

  @override
  String toString() {
    return 'TestScriptAction2(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, operation: $operation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TestScriptAction2 &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.extension_, extension_) ||
                const DeepCollectionEquality()
                    .equals(other.extension_, extension_)) &&
            (identical(other.modifierExtension, modifierExtension) ||
                const DeepCollectionEquality()
                    .equals(other.modifierExtension, modifierExtension)) &&
            (identical(other.operation, operation) ||
                const DeepCollectionEquality()
                    .equals(other.operation, operation)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(extension_) ^
      const DeepCollectionEquality().hash(modifierExtension) ^
      const DeepCollectionEquality().hash(operation);

  @override
  _$TestScriptAction2CopyWith<_TestScriptAction2> get copyWith =>
      __$TestScriptAction2CopyWithImpl<_TestScriptAction2>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_TestScriptAction2ToJson(this);
  }
}

abstract class _TestScriptAction2 implements TestScriptAction2 {
  const factory _TestScriptAction2(
          {String id,
          @JsonKey(name: 'extension') List<FhirExtension> extension_,
          List<FhirExtension> modifierExtension,
          @required @JsonKey(required: true) TestScriptOperation operation}) =
      _$_TestScriptAction2;

  factory _TestScriptAction2.fromJson(Map<String, dynamic> json) =
      _$_TestScriptAction2.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension> get extension_;
  @override
  List<FhirExtension> get modifierExtension;
  @override
  @JsonKey(required: true)
  TestScriptOperation get operation;
  @override
  _$TestScriptAction2CopyWith<_TestScriptAction2> get copyWith;
}
