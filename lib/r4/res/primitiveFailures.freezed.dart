// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'primitiveFailures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$PrimitiveFailureTearOff {
  const _$PrimitiveFailureTearOff();

  InvalidBase64Binary<T> invalidBase64Binary<T>({@required T failedValue}) {
    return InvalidBase64Binary<T>(
      failedValue: failedValue,
    );
  }

  InvalidBoolean<T> invalidBoolean<T>({@required T failedValue}) {
    return InvalidBoolean<T>(
      failedValue: failedValue,
    );
  }

  InvalidCanonical<T> invalidCanonical<T>({@required T failedValue}) {
    return InvalidCanonical<T>(
      failedValue: failedValue,
    );
  }

  InvalidCode<T> invalidCode<T>({@required T failedValue}) {
    return InvalidCode<T>(
      failedValue: failedValue,
    );
  }

  InvalidDate<T> invalidDate<T>({@required T failedValue}) {
    return InvalidDate<T>(
      failedValue: failedValue,
    );
  }

  InvalidDateTime<T> invalidFhirDateTime<T>({@required T failedValue}) {
    return InvalidDateTime<T>(
      failedValue: failedValue,
    );
  }

  InvalidDecimal<T> invalidDecimal<T>({@required T failedValue}) {
    return InvalidDecimal<T>(
      failedValue: failedValue,
    );
  }

  InvalidId<T> invalidId<T>({@required T failedValue}) {
    return InvalidId<T>(
      failedValue: failedValue,
    );
  }

  InvalidInstant<T> invalidInstant<T>({@required T failedValue}) {
    return InvalidInstant<T>(
      failedValue: failedValue,
    );
  }

  InvalidInteger<T> invalidInteger<T>({@required T failedValue}) {
    return InvalidInteger<T>(
      failedValue: failedValue,
    );
  }

  InvalidMarkdown<T> invalidMarkdown<T>({@required T failedValue}) {
    return InvalidMarkdown<T>(
      failedValue: failedValue,
    );
  }

  InvalidOid<T> invalidOid<T>({@required T failedValue}) {
    return InvalidOid<T>(
      failedValue: failedValue,
    );
  }

  InvalidPositiveInt<T> invalidPositiveInt<T>({@required T failedValue}) {
    return InvalidPositiveInt<T>(
      failedValue: failedValue,
    );
  }

  InvalidTime<T> invalidTime<T>({@required T failedValue}) {
    return InvalidTime<T>(
      failedValue: failedValue,
    );
  }

  InvalidUnsignedInt<T> invalidUnsignedInt<T>({@required T failedValue}) {
    return InvalidUnsignedInt<T>(
      failedValue: failedValue,
    );
  }

  InvalidFhirUri<T> invalidFhirUri<T>({@required T failedValue}) {
    return InvalidFhirUri<T>(
      failedValue: failedValue,
    );
  }

  InvalidFhirUrl<T> invalidFhirUrl<T>({@required T failedValue}) {
    return InvalidFhirUrl<T>(
      failedValue: failedValue,
    );
  }

  InvalidUuid<T> invalidUuid<T>({@required T failedValue}) {
    return InvalidUuid<T>(
      failedValue: failedValue,
    );
  }

  InvalidEnum<T> invalidEnum<T>({@required T failedValue}) {
    return InvalidEnum<T>(
      failedValue: failedValue,
    );
  }
}

// ignore: unused_element
const $PrimitiveFailure = _$PrimitiveFailureTearOff();

mixin _$PrimitiveFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  });

  $PrimitiveFailureCopyWith<T, PrimitiveFailure<T>> get copyWith;
}

abstract class $PrimitiveFailureCopyWith<T, $Res> {
  factory $PrimitiveFailureCopyWith(
          PrimitiveFailure<T> value, $Res Function(PrimitiveFailure<T>) then) =
      _$PrimitiveFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

class _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  _$PrimitiveFailureCopyWithImpl(this._value, this._then);

  final PrimitiveFailure<T> _value;
  // ignore: unused_field
  final $Res Function(PrimitiveFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

abstract class $InvalidBase64BinaryCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidBase64BinaryCopyWith(InvalidBase64Binary<T> value,
          $Res Function(InvalidBase64Binary<T>) then) =
      _$InvalidBase64BinaryCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidBase64BinaryCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidBase64BinaryCopyWith<T, $Res> {
  _$InvalidBase64BinaryCopyWithImpl(InvalidBase64Binary<T> _value,
      $Res Function(InvalidBase64Binary<T>) _then)
      : super(_value, (v) => _then(v as InvalidBase64Binary<T>));

  @override
  InvalidBase64Binary<T> get _value => super._value as InvalidBase64Binary<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidBase64Binary<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidBase64Binary<T> implements InvalidBase64Binary<T> {
  const _$InvalidBase64Binary({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidBase64Binary(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidBase64Binary<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidBase64BinaryCopyWith<T, InvalidBase64Binary<T>> get copyWith =>
      _$InvalidBase64BinaryCopyWithImpl<T, InvalidBase64Binary<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidBase64Binary(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidBase64Binary != null) {
      return invalidBase64Binary(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidBase64Binary(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidBase64Binary != null) {
      return invalidBase64Binary(this);
    }
    return orElse();
  }
}

abstract class InvalidBase64Binary<T> implements PrimitiveFailure<T> {
  const factory InvalidBase64Binary({@required T failedValue}) =
      _$InvalidBase64Binary<T>;

  @override
  T get failedValue;
  @override
  $InvalidBase64BinaryCopyWith<T, InvalidBase64Binary<T>> get copyWith;
}

abstract class $InvalidBooleanCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidBooleanCopyWith(
          InvalidBoolean<T> value, $Res Function(InvalidBoolean<T>) then) =
      _$InvalidBooleanCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidBooleanCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidBooleanCopyWith<T, $Res> {
  _$InvalidBooleanCopyWithImpl(
      InvalidBoolean<T> _value, $Res Function(InvalidBoolean<T>) _then)
      : super(_value, (v) => _then(v as InvalidBoolean<T>));

  @override
  InvalidBoolean<T> get _value => super._value as InvalidBoolean<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidBoolean<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidBoolean<T> implements InvalidBoolean<T> {
  const _$InvalidBoolean({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidBoolean(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidBoolean<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidBooleanCopyWith<T, InvalidBoolean<T>> get copyWith =>
      _$InvalidBooleanCopyWithImpl<T, InvalidBoolean<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidBoolean(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidBoolean != null) {
      return invalidBoolean(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidBoolean(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidBoolean != null) {
      return invalidBoolean(this);
    }
    return orElse();
  }
}

abstract class InvalidBoolean<T> implements PrimitiveFailure<T> {
  const factory InvalidBoolean({@required T failedValue}) = _$InvalidBoolean<T>;

  @override
  T get failedValue;
  @override
  $InvalidBooleanCopyWith<T, InvalidBoolean<T>> get copyWith;
}

abstract class $InvalidCanonicalCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidCanonicalCopyWith(
          InvalidCanonical<T> value, $Res Function(InvalidCanonical<T>) then) =
      _$InvalidCanonicalCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidCanonicalCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidCanonicalCopyWith<T, $Res> {
  _$InvalidCanonicalCopyWithImpl(
      InvalidCanonical<T> _value, $Res Function(InvalidCanonical<T>) _then)
      : super(_value, (v) => _then(v as InvalidCanonical<T>));

  @override
  InvalidCanonical<T> get _value => super._value as InvalidCanonical<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidCanonical<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidCanonical<T> implements InvalidCanonical<T> {
  const _$InvalidCanonical({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidCanonical(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCanonical<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidCanonicalCopyWith<T, InvalidCanonical<T>> get copyWith =>
      _$InvalidCanonicalCopyWithImpl<T, InvalidCanonical<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidCanonical(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCanonical != null) {
      return invalidCanonical(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidCanonical(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCanonical != null) {
      return invalidCanonical(this);
    }
    return orElse();
  }
}

abstract class InvalidCanonical<T> implements PrimitiveFailure<T> {
  const factory InvalidCanonical({@required T failedValue}) =
      _$InvalidCanonical<T>;

  @override
  T get failedValue;
  @override
  $InvalidCanonicalCopyWith<T, InvalidCanonical<T>> get copyWith;
}

abstract class $InvalidCodeCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidCodeCopyWith(
          InvalidCode<T> value, $Res Function(InvalidCode<T>) then) =
      _$InvalidCodeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidCodeCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidCodeCopyWith<T, $Res> {
  _$InvalidCodeCopyWithImpl(
      InvalidCode<T> _value, $Res Function(InvalidCode<T>) _then)
      : super(_value, (v) => _then(v as InvalidCode<T>));

  @override
  InvalidCode<T> get _value => super._value as InvalidCode<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidCode<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidCode<T> implements InvalidCode<T> {
  const _$InvalidCode({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidCode(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCode<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidCodeCopyWith<T, InvalidCode<T>> get copyWith =>
      _$InvalidCodeCopyWithImpl<T, InvalidCode<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidCode(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCode != null) {
      return invalidCode(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidCode(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidCode != null) {
      return invalidCode(this);
    }
    return orElse();
  }
}

abstract class InvalidCode<T> implements PrimitiveFailure<T> {
  const factory InvalidCode({@required T failedValue}) = _$InvalidCode<T>;

  @override
  T get failedValue;
  @override
  $InvalidCodeCopyWith<T, InvalidCode<T>> get copyWith;
}

abstract class $InvalidDateCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidDateCopyWith(
          InvalidDate<T> value, $Res Function(InvalidDate<T>) then) =
      _$InvalidDateCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidDateCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidDateCopyWith<T, $Res> {
  _$InvalidDateCopyWithImpl(
      InvalidDate<T> _value, $Res Function(InvalidDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidDate<T>));

  @override
  InvalidDate<T> get _value => super._value as InvalidDate<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDate<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidDate<T> implements InvalidDate<T> {
  const _$InvalidDate({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDate<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith =>
      _$InvalidDateCopyWithImpl<T, InvalidDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidDate(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidDate(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDate != null) {
      return invalidDate(this);
    }
    return orElse();
  }
}

abstract class InvalidDate<T> implements PrimitiveFailure<T> {
  const factory InvalidDate({@required T failedValue}) = _$InvalidDate<T>;

  @override
  T get failedValue;
  @override
  $InvalidDateCopyWith<T, InvalidDate<T>> get copyWith;
}

abstract class $InvalidDateTimeCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidDateTimeCopyWith(
          InvalidDateTime<T> value, $Res Function(InvalidDateTime<T>) then) =
      _$InvalidDateTimeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidDateTimeCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidDateTimeCopyWith<T, $Res> {
  _$InvalidDateTimeCopyWithImpl(
      InvalidDateTime<T> _value, $Res Function(InvalidDateTime<T>) _then)
      : super(_value, (v) => _then(v as InvalidDateTime<T>));

  @override
  InvalidDateTime<T> get _value => super._value as InvalidDateTime<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDateTime<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidDateTime<T> implements InvalidDateTime<T> {
  const _$InvalidDateTime({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidFhirDateTime(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDateTime<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDateTimeCopyWith<T, InvalidDateTime<T>> get copyWith =>
      _$InvalidDateTimeCopyWithImpl<T, InvalidDateTime<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirDateTime(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirDateTime != null) {
      return invalidFhirDateTime(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirDateTime(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirDateTime != null) {
      return invalidFhirDateTime(this);
    }
    return orElse();
  }
}

abstract class InvalidDateTime<T> implements PrimitiveFailure<T> {
  const factory InvalidDateTime({@required T failedValue}) =
      _$InvalidDateTime<T>;

  @override
  T get failedValue;
  @override
  $InvalidDateTimeCopyWith<T, InvalidDateTime<T>> get copyWith;
}

abstract class $InvalidDecimalCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidDecimalCopyWith(
          InvalidDecimal<T> value, $Res Function(InvalidDecimal<T>) then) =
      _$InvalidDecimalCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidDecimalCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidDecimalCopyWith<T, $Res> {
  _$InvalidDecimalCopyWithImpl(
      InvalidDecimal<T> _value, $Res Function(InvalidDecimal<T>) _then)
      : super(_value, (v) => _then(v as InvalidDecimal<T>));

  @override
  InvalidDecimal<T> get _value => super._value as InvalidDecimal<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDecimal<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidDecimal<T> implements InvalidDecimal<T> {
  const _$InvalidDecimal({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidDecimal(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDecimal<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDecimalCopyWith<T, InvalidDecimal<T>> get copyWith =>
      _$InvalidDecimalCopyWithImpl<T, InvalidDecimal<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidDecimal(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDecimal != null) {
      return invalidDecimal(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidDecimal(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidDecimal != null) {
      return invalidDecimal(this);
    }
    return orElse();
  }
}

abstract class InvalidDecimal<T> implements PrimitiveFailure<T> {
  const factory InvalidDecimal({@required T failedValue}) = _$InvalidDecimal<T>;

  @override
  T get failedValue;
  @override
  $InvalidDecimalCopyWith<T, InvalidDecimal<T>> get copyWith;
}

abstract class $InvalidIdCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidIdCopyWith(
          InvalidId<T> value, $Res Function(InvalidId<T>) then) =
      _$InvalidIdCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidIdCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidIdCopyWith<T, $Res> {
  _$InvalidIdCopyWithImpl(
      InvalidId<T> _value, $Res Function(InvalidId<T>) _then)
      : super(_value, (v) => _then(v as InvalidId<T>));

  @override
  InvalidId<T> get _value => super._value as InvalidId<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidId<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidId<T> implements InvalidId<T> {
  const _$InvalidId({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidId(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidId<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidIdCopyWith<T, InvalidId<T>> get copyWith =>
      _$InvalidIdCopyWithImpl<T, InvalidId<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidId(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidId != null) {
      return invalidId(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidId(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidId != null) {
      return invalidId(this);
    }
    return orElse();
  }
}

abstract class InvalidId<T> implements PrimitiveFailure<T> {
  const factory InvalidId({@required T failedValue}) = _$InvalidId<T>;

  @override
  T get failedValue;
  @override
  $InvalidIdCopyWith<T, InvalidId<T>> get copyWith;
}

abstract class $InvalidInstantCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidInstantCopyWith(
          InvalidInstant<T> value, $Res Function(InvalidInstant<T>) then) =
      _$InvalidInstantCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidInstantCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidInstantCopyWith<T, $Res> {
  _$InvalidInstantCopyWithImpl(
      InvalidInstant<T> _value, $Res Function(InvalidInstant<T>) _then)
      : super(_value, (v) => _then(v as InvalidInstant<T>));

  @override
  InvalidInstant<T> get _value => super._value as InvalidInstant<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidInstant<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidInstant<T> implements InvalidInstant<T> {
  const _$InvalidInstant({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidInstant(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidInstant<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidInstantCopyWith<T, InvalidInstant<T>> get copyWith =>
      _$InvalidInstantCopyWithImpl<T, InvalidInstant<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidInstant(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidInstant != null) {
      return invalidInstant(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidInstant(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidInstant != null) {
      return invalidInstant(this);
    }
    return orElse();
  }
}

abstract class InvalidInstant<T> implements PrimitiveFailure<T> {
  const factory InvalidInstant({@required T failedValue}) = _$InvalidInstant<T>;

  @override
  T get failedValue;
  @override
  $InvalidInstantCopyWith<T, InvalidInstant<T>> get copyWith;
}

abstract class $InvalidIntegerCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidIntegerCopyWith(
          InvalidInteger<T> value, $Res Function(InvalidInteger<T>) then) =
      _$InvalidIntegerCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidIntegerCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidIntegerCopyWith<T, $Res> {
  _$InvalidIntegerCopyWithImpl(
      InvalidInteger<T> _value, $Res Function(InvalidInteger<T>) _then)
      : super(_value, (v) => _then(v as InvalidInteger<T>));

  @override
  InvalidInteger<T> get _value => super._value as InvalidInteger<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidInteger<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidInteger<T> implements InvalidInteger<T> {
  const _$InvalidInteger({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidInteger(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidInteger<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidIntegerCopyWith<T, InvalidInteger<T>> get copyWith =>
      _$InvalidIntegerCopyWithImpl<T, InvalidInteger<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidInteger(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidInteger != null) {
      return invalidInteger(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidInteger(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidInteger != null) {
      return invalidInteger(this);
    }
    return orElse();
  }
}

abstract class InvalidInteger<T> implements PrimitiveFailure<T> {
  const factory InvalidInteger({@required T failedValue}) = _$InvalidInteger<T>;

  @override
  T get failedValue;
  @override
  $InvalidIntegerCopyWith<T, InvalidInteger<T>> get copyWith;
}

abstract class $InvalidMarkdownCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidMarkdownCopyWith(
          InvalidMarkdown<T> value, $Res Function(InvalidMarkdown<T>) then) =
      _$InvalidMarkdownCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidMarkdownCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidMarkdownCopyWith<T, $Res> {
  _$InvalidMarkdownCopyWithImpl(
      InvalidMarkdown<T> _value, $Res Function(InvalidMarkdown<T>) _then)
      : super(_value, (v) => _then(v as InvalidMarkdown<T>));

  @override
  InvalidMarkdown<T> get _value => super._value as InvalidMarkdown<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidMarkdown<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidMarkdown<T> implements InvalidMarkdown<T> {
  const _$InvalidMarkdown({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidMarkdown(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidMarkdown<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidMarkdownCopyWith<T, InvalidMarkdown<T>> get copyWith =>
      _$InvalidMarkdownCopyWithImpl<T, InvalidMarkdown<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidMarkdown(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidMarkdown != null) {
      return invalidMarkdown(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidMarkdown(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidMarkdown != null) {
      return invalidMarkdown(this);
    }
    return orElse();
  }
}

abstract class InvalidMarkdown<T> implements PrimitiveFailure<T> {
  const factory InvalidMarkdown({@required T failedValue}) =
      _$InvalidMarkdown<T>;

  @override
  T get failedValue;
  @override
  $InvalidMarkdownCopyWith<T, InvalidMarkdown<T>> get copyWith;
}

abstract class $InvalidOidCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidOidCopyWith(
          InvalidOid<T> value, $Res Function(InvalidOid<T>) then) =
      _$InvalidOidCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidOidCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidOidCopyWith<T, $Res> {
  _$InvalidOidCopyWithImpl(
      InvalidOid<T> _value, $Res Function(InvalidOid<T>) _then)
      : super(_value, (v) => _then(v as InvalidOid<T>));

  @override
  InvalidOid<T> get _value => super._value as InvalidOid<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidOid<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidOid<T> implements InvalidOid<T> {
  const _$InvalidOid({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidOid(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidOid<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidOidCopyWith<T, InvalidOid<T>> get copyWith =>
      _$InvalidOidCopyWithImpl<T, InvalidOid<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidOid(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidOid != null) {
      return invalidOid(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidOid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidOid != null) {
      return invalidOid(this);
    }
    return orElse();
  }
}

abstract class InvalidOid<T> implements PrimitiveFailure<T> {
  const factory InvalidOid({@required T failedValue}) = _$InvalidOid<T>;

  @override
  T get failedValue;
  @override
  $InvalidOidCopyWith<T, InvalidOid<T>> get copyWith;
}

abstract class $InvalidPositiveIntCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidPositiveIntCopyWith(InvalidPositiveInt<T> value,
          $Res Function(InvalidPositiveInt<T>) then) =
      _$InvalidPositiveIntCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidPositiveIntCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidPositiveIntCopyWith<T, $Res> {
  _$InvalidPositiveIntCopyWithImpl(
      InvalidPositiveInt<T> _value, $Res Function(InvalidPositiveInt<T>) _then)
      : super(_value, (v) => _then(v as InvalidPositiveInt<T>));

  @override
  InvalidPositiveInt<T> get _value => super._value as InvalidPositiveInt<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPositiveInt<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidPositiveInt<T> implements InvalidPositiveInt<T> {
  const _$InvalidPositiveInt({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidPositiveInt(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPositiveInt<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPositiveIntCopyWith<T, InvalidPositiveInt<T>> get copyWith =>
      _$InvalidPositiveIntCopyWithImpl<T, InvalidPositiveInt<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidPositiveInt(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPositiveInt != null) {
      return invalidPositiveInt(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidPositiveInt(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidPositiveInt != null) {
      return invalidPositiveInt(this);
    }
    return orElse();
  }
}

abstract class InvalidPositiveInt<T> implements PrimitiveFailure<T> {
  const factory InvalidPositiveInt({@required T failedValue}) =
      _$InvalidPositiveInt<T>;

  @override
  T get failedValue;
  @override
  $InvalidPositiveIntCopyWith<T, InvalidPositiveInt<T>> get copyWith;
}

abstract class $InvalidTimeCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidTimeCopyWith(
          InvalidTime<T> value, $Res Function(InvalidTime<T>) then) =
      _$InvalidTimeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidTimeCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidTimeCopyWith<T, $Res> {
  _$InvalidTimeCopyWithImpl(
      InvalidTime<T> _value, $Res Function(InvalidTime<T>) _then)
      : super(_value, (v) => _then(v as InvalidTime<T>));

  @override
  InvalidTime<T> get _value => super._value as InvalidTime<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidTime<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidTime<T> implements InvalidTime<T> {
  const _$InvalidTime({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidTime(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidTime<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidTimeCopyWith<T, InvalidTime<T>> get copyWith =>
      _$InvalidTimeCopyWithImpl<T, InvalidTime<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidTime(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidTime != null) {
      return invalidTime(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidTime(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidTime != null) {
      return invalidTime(this);
    }
    return orElse();
  }
}

abstract class InvalidTime<T> implements PrimitiveFailure<T> {
  const factory InvalidTime({@required T failedValue}) = _$InvalidTime<T>;

  @override
  T get failedValue;
  @override
  $InvalidTimeCopyWith<T, InvalidTime<T>> get copyWith;
}

abstract class $InvalidUnsignedIntCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidUnsignedIntCopyWith(InvalidUnsignedInt<T> value,
          $Res Function(InvalidUnsignedInt<T>) then) =
      _$InvalidUnsignedIntCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidUnsignedIntCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidUnsignedIntCopyWith<T, $Res> {
  _$InvalidUnsignedIntCopyWithImpl(
      InvalidUnsignedInt<T> _value, $Res Function(InvalidUnsignedInt<T>) _then)
      : super(_value, (v) => _then(v as InvalidUnsignedInt<T>));

  @override
  InvalidUnsignedInt<T> get _value => super._value as InvalidUnsignedInt<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUnsignedInt<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidUnsignedInt<T> implements InvalidUnsignedInt<T> {
  const _$InvalidUnsignedInt({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidUnsignedInt(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUnsignedInt<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUnsignedIntCopyWith<T, InvalidUnsignedInt<T>> get copyWith =>
      _$InvalidUnsignedIntCopyWithImpl<T, InvalidUnsignedInt<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidUnsignedInt(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUnsignedInt != null) {
      return invalidUnsignedInt(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidUnsignedInt(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUnsignedInt != null) {
      return invalidUnsignedInt(this);
    }
    return orElse();
  }
}

abstract class InvalidUnsignedInt<T> implements PrimitiveFailure<T> {
  const factory InvalidUnsignedInt({@required T failedValue}) =
      _$InvalidUnsignedInt<T>;

  @override
  T get failedValue;
  @override
  $InvalidUnsignedIntCopyWith<T, InvalidUnsignedInt<T>> get copyWith;
}

abstract class $InvalidFhirUriCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidFhirUriCopyWith(
          InvalidFhirUri<T> value, $Res Function(InvalidFhirUri<T>) then) =
      _$InvalidFhirUriCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidFhirUriCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidFhirUriCopyWith<T, $Res> {
  _$InvalidFhirUriCopyWithImpl(
      InvalidFhirUri<T> _value, $Res Function(InvalidFhirUri<T>) _then)
      : super(_value, (v) => _then(v as InvalidFhirUri<T>));

  @override
  InvalidFhirUri<T> get _value => super._value as InvalidFhirUri<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidFhirUri<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidFhirUri<T> implements InvalidFhirUri<T> {
  const _$InvalidFhirUri({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidFhirUri(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidFhirUri<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidFhirUriCopyWith<T, InvalidFhirUri<T>> get copyWith =>
      _$InvalidFhirUriCopyWithImpl<T, InvalidFhirUri<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirUri(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirUri != null) {
      return invalidFhirUri(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirUri(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirUri != null) {
      return invalidFhirUri(this);
    }
    return orElse();
  }
}

abstract class InvalidFhirUri<T> implements PrimitiveFailure<T> {
  const factory InvalidFhirUri({@required T failedValue}) = _$InvalidFhirUri<T>;

  @override
  T get failedValue;
  @override
  $InvalidFhirUriCopyWith<T, InvalidFhirUri<T>> get copyWith;
}

abstract class $InvalidFhirUrlCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidFhirUrlCopyWith(
          InvalidFhirUrl<T> value, $Res Function(InvalidFhirUrl<T>) then) =
      _$InvalidFhirUrlCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidFhirUrlCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidFhirUrlCopyWith<T, $Res> {
  _$InvalidFhirUrlCopyWithImpl(
      InvalidFhirUrl<T> _value, $Res Function(InvalidFhirUrl<T>) _then)
      : super(_value, (v) => _then(v as InvalidFhirUrl<T>));

  @override
  InvalidFhirUrl<T> get _value => super._value as InvalidFhirUrl<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidFhirUrl<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidFhirUrl<T> implements InvalidFhirUrl<T> {
  const _$InvalidFhirUrl({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidFhirUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidFhirUrl<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidFhirUrlCopyWith<T, InvalidFhirUrl<T>> get copyWith =>
      _$InvalidFhirUrlCopyWithImpl<T, InvalidFhirUrl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirUrl != null) {
      return invalidFhirUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidFhirUrl(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidFhirUrl != null) {
      return invalidFhirUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidFhirUrl<T> implements PrimitiveFailure<T> {
  const factory InvalidFhirUrl({@required T failedValue}) = _$InvalidFhirUrl<T>;

  @override
  T get failedValue;
  @override
  $InvalidFhirUrlCopyWith<T, InvalidFhirUrl<T>> get copyWith;
}

abstract class $InvalidUuidCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidUuidCopyWith(
          InvalidUuid<T> value, $Res Function(InvalidUuid<T>) then) =
      _$InvalidUuidCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidUuidCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidUuidCopyWith<T, $Res> {
  _$InvalidUuidCopyWithImpl(
      InvalidUuid<T> _value, $Res Function(InvalidUuid<T>) _then)
      : super(_value, (v) => _then(v as InvalidUuid<T>));

  @override
  InvalidUuid<T> get _value => super._value as InvalidUuid<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidUuid<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidUuid<T> implements InvalidUuid<T> {
  const _$InvalidUuid({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidUuid(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidUuid<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidUuidCopyWith<T, InvalidUuid<T>> get copyWith =>
      _$InvalidUuidCopyWithImpl<T, InvalidUuid<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidUuid(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUuid != null) {
      return invalidUuid(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidUuid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidUuid != null) {
      return invalidUuid(this);
    }
    return orElse();
  }
}

abstract class InvalidUuid<T> implements PrimitiveFailure<T> {
  const factory InvalidUuid({@required T failedValue}) = _$InvalidUuid<T>;

  @override
  T get failedValue;
  @override
  $InvalidUuidCopyWith<T, InvalidUuid<T>> get copyWith;
}

abstract class $InvalidEnumCopyWith<T, $Res>
    implements $PrimitiveFailureCopyWith<T, $Res> {
  factory $InvalidEnumCopyWith(
          InvalidEnum<T> value, $Res Function(InvalidEnum<T>) then) =
      _$InvalidEnumCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

class _$InvalidEnumCopyWithImpl<T, $Res>
    extends _$PrimitiveFailureCopyWithImpl<T, $Res>
    implements $InvalidEnumCopyWith<T, $Res> {
  _$InvalidEnumCopyWithImpl(
      InvalidEnum<T> _value, $Res Function(InvalidEnum<T>) _then)
      : super(_value, (v) => _then(v as InvalidEnum<T>));

  @override
  InvalidEnum<T> get _value => super._value as InvalidEnum<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEnum<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

class _$InvalidEnum<T> implements InvalidEnum<T> {
  const _$InvalidEnum({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'PrimitiveFailure<$T>.invalidEnum(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEnum<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidEnumCopyWith<T, InvalidEnum<T>> get copyWith =>
      _$InvalidEnumCopyWithImpl<T, InvalidEnum<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidBase64Binary(T failedValue),
    @required Result invalidBoolean(T failedValue),
    @required Result invalidCanonical(T failedValue),
    @required Result invalidCode(T failedValue),
    @required Result invalidDate(T failedValue),
    @required Result invalidFhirDateTime(T failedValue),
    @required Result invalidDecimal(T failedValue),
    @required Result invalidId(T failedValue),
    @required Result invalidInstant(T failedValue),
    @required Result invalidInteger(T failedValue),
    @required Result invalidMarkdown(T failedValue),
    @required Result invalidOid(T failedValue),
    @required Result invalidPositiveInt(T failedValue),
    @required Result invalidTime(T failedValue),
    @required Result invalidUnsignedInt(T failedValue),
    @required Result invalidFhirUri(T failedValue),
    @required Result invalidFhirUrl(T failedValue),
    @required Result invalidUuid(T failedValue),
    @required Result invalidEnum(T failedValue),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidEnum(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidBase64Binary(T failedValue),
    Result invalidBoolean(T failedValue),
    Result invalidCanonical(T failedValue),
    Result invalidCode(T failedValue),
    Result invalidDate(T failedValue),
    Result invalidFhirDateTime(T failedValue),
    Result invalidDecimal(T failedValue),
    Result invalidId(T failedValue),
    Result invalidInstant(T failedValue),
    Result invalidInteger(T failedValue),
    Result invalidMarkdown(T failedValue),
    Result invalidOid(T failedValue),
    Result invalidPositiveInt(T failedValue),
    Result invalidTime(T failedValue),
    Result invalidUnsignedInt(T failedValue),
    Result invalidFhirUri(T failedValue),
    Result invalidFhirUrl(T failedValue),
    Result invalidUuid(T failedValue),
    Result invalidEnum(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEnum != null) {
      return invalidEnum(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidBase64Binary(InvalidBase64Binary<T> value),
    @required Result invalidBoolean(InvalidBoolean<T> value),
    @required Result invalidCanonical(InvalidCanonical<T> value),
    @required Result invalidCode(InvalidCode<T> value),
    @required Result invalidDate(InvalidDate<T> value),
    @required Result invalidFhirDateTime(InvalidDateTime<T> value),
    @required Result invalidDecimal(InvalidDecimal<T> value),
    @required Result invalidId(InvalidId<T> value),
    @required Result invalidInstant(InvalidInstant<T> value),
    @required Result invalidInteger(InvalidInteger<T> value),
    @required Result invalidMarkdown(InvalidMarkdown<T> value),
    @required Result invalidOid(InvalidOid<T> value),
    @required Result invalidPositiveInt(InvalidPositiveInt<T> value),
    @required Result invalidTime(InvalidTime<T> value),
    @required Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    @required Result invalidFhirUri(InvalidFhirUri<T> value),
    @required Result invalidFhirUrl(InvalidFhirUrl<T> value),
    @required Result invalidUuid(InvalidUuid<T> value),
    @required Result invalidEnum(InvalidEnum<T> value),
  }) {
    assert(invalidBase64Binary != null);
    assert(invalidBoolean != null);
    assert(invalidCanonical != null);
    assert(invalidCode != null);
    assert(invalidDate != null);
    assert(invalidFhirDateTime != null);
    assert(invalidDecimal != null);
    assert(invalidId != null);
    assert(invalidInstant != null);
    assert(invalidInteger != null);
    assert(invalidMarkdown != null);
    assert(invalidOid != null);
    assert(invalidPositiveInt != null);
    assert(invalidTime != null);
    assert(invalidUnsignedInt != null);
    assert(invalidFhirUri != null);
    assert(invalidFhirUrl != null);
    assert(invalidUuid != null);
    assert(invalidEnum != null);
    return invalidEnum(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidBase64Binary(InvalidBase64Binary<T> value),
    Result invalidBoolean(InvalidBoolean<T> value),
    Result invalidCanonical(InvalidCanonical<T> value),
    Result invalidCode(InvalidCode<T> value),
    Result invalidDate(InvalidDate<T> value),
    Result invalidFhirDateTime(InvalidDateTime<T> value),
    Result invalidDecimal(InvalidDecimal<T> value),
    Result invalidId(InvalidId<T> value),
    Result invalidInstant(InvalidInstant<T> value),
    Result invalidInteger(InvalidInteger<T> value),
    Result invalidMarkdown(InvalidMarkdown<T> value),
    Result invalidOid(InvalidOid<T> value),
    Result invalidPositiveInt(InvalidPositiveInt<T> value),
    Result invalidTime(InvalidTime<T> value),
    Result invalidUnsignedInt(InvalidUnsignedInt<T> value),
    Result invalidFhirUri(InvalidFhirUri<T> value),
    Result invalidFhirUrl(InvalidFhirUrl<T> value),
    Result invalidUuid(InvalidUuid<T> value),
    Result invalidEnum(InvalidEnum<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidEnum != null) {
      return invalidEnum(this);
    }
    return orElse();
  }
}

abstract class InvalidEnum<T> implements PrimitiveFailure<T> {
  const factory InvalidEnum({@required T failedValue}) = _$InvalidEnum<T>;

  @override
  T get failedValue;
  @override
  $InvalidEnumCopyWith<T, InvalidEnum<T>> get copyWith;
}
